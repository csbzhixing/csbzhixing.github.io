
<!DOCTYPE HTML>
<html>
<head>
	<script data-cfasync="false" type="text/javascript" src="//use.typekit.net/axj3cfp.js"></script>
	<script data-cfasync="false" type="text/javascript">try{Typekit.load();}catch(e){}</script>
	<meta charset="utf-8">
	<title>在这里记录一点一滴的成长  | 之行海涯</title>

<meta name="author" content="之行"> 

<meta name="description" content="开头 这篇文章是在http://www.cnblogs.com/dsxniubility/p/4757760.html的基础上加入了一点自己的思考，主要内容都转自上文，所以算一篇文章的读后感+转载吧。 正文 iOS警告收录及科学快速的消除方法 警告，是在编码中出现的最多的问题。不同于error &hellip;"> <meta name="keywords" content="">

	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="之行海涯" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<script type="text/javascript" src="/javascripts/jquery.fancybox.pack.js"></script>

<script language="Javascript" type="text/javascript">
$(document).ready(
  function() {
    (function($) {
      $(".fancybox[data-content-id]").each(function() {
        this.href = $(this).data('content-id');
      });
      $(".fancybox").fancybox({
        beforeLoad: function() {
          var el, 
              id = $(this.element).data('title-id');

          if (id) {
            el = $('#' + id);

            if (el.length) {
              this.title = el.html();
            }
          }
          if ($(this).data('content')) {
            this.content = $(this).data('content');
          }
        },
        helpers: {
          title: {
            type: 'inside'
          }
        }
      });
    })(jQuery);
  }
);
</script>

	
</head>



<body>
	<header id="header" class="inner"><h1><a href="/">之行海涯</a></h1>
<h4>在这里记录一点一滴的成长</h4>
<nav id="main-nav"><ul>
	<li><a href="/">Blog</a></li>
	<li><a href="/archives">Archive</a></li>
	<li><a href="/about">关于我</a></li>

</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul>
	<li><a href="/">Blog</a></li>
	<li><a href="/archives">Archive</a></li>
	<li><a href="/about">关于我</a></li>

</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:csbzhixing.github.io">
			</form>
		</div>
	</div>
</nav>


</header>

	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/09/14/warning-blog/">
		
			Warning Blog</a>
	</h2>
	<div class="entry-content">
		<h2>开头</h2>

<p>这篇文章是在<a href="http://www.cnblogs.com/dsxniubility/p/4757760.html">http://www.cnblogs.com/dsxniubility/p/4757760.html</a>的基础上加入了一点自己的思考，主要内容都转自上文，所以算一篇文章的读后感+转载吧。</p>

<h2>正文</h2>

<h3>iOS警告收录及科学快速的消除方法</h3>

<p>警告，是在编码中出现的最多的问题。不同于error, warning的出现可能不并不影响程序的正常运行，所以很多时候许多程序员都会选择性的去忽略warning。但是作为一个优秀的程序员，我们应该立足于一个优秀的产品开发者，尽可能避免任何有可能使产品崩溃的现象出现。所以对一切warning都要做到尽可能的消除。</p>

<p>在iOS开发中，我也经常碰多许多摸不着头脑的warning。多数是因为版本的问题。由于苹果在不同版本之间会有一些区别，想要兼容多版本就要使用不同版本共有的方法。而一些stroyboard的问题更是没法定位，只能靠经验去分辨，在几个开发中已经发现了很多坑，而今天看到的这篇文章感觉非常不错，所以转载在这里给自己做一个笔记。</p>

<p>(下面为转载内容)</p>

<blockquote><p>详细科学的消除警告</p>

<p>其实笔者本意是想把一些第一眼看不懂比较坑的警告收录进来，但是后来发现那基本没几个需要些写了，所以就采用了全收录的方法，遇到的就记录下以后也会不断更新。 可以直接按command+F 在本页面搜索警告</p>

<p>Unused variable &lsquo;replyURL&rsquo;</p>

<p>1.没有使用</p>

<p>Cannot find protocol definition for &lsquo;TencentSessionDelegate&rsquo;</p>

<p>2.这种明明都能运行还说我没有定义的警告，是因为你这个协议虽然定义了，但是你这个协议可能还遵守了XX协议，然后这个XX协议没有定义导致会报这种警告，所以遇到这种警告要往“父协议”找。 举个栗子，上面这行就是腾讯授权的库里面报的警告，</p>

<p>1 <code>@protocol TencentSessionDelegate</code>
此协议遵守了TencentApiInterfaceDelegate协议，在TencentOAuth.h类中#import &ldquo;TencentApiInterface.h&rdquo; 警告可破</p>

<p>Null passed to a callee that requires a non-null argument</p>

<p>3.这个警告比较新，是xcode6.3开始 为了让OC也能有swift的？和！的功能，你在声明一个属性的时候加上 <strong>nullable（？可以为空）与</strong>nonnull（！不能为空） 如果放在@property里面的话不用写下划线</p>

<p>1 <code>@property (nonatomic, copy, nonnull) NSString * tickets;</code>
2  <code>@property (nonatomic, copy) NSString * __nonnull tickets;</code></p>

<p>或者用宏NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END 包住多个属性全部具备nonnull，然后仅对需要nullable的改下就行，有点类似于f-no-objc-arc那种先整体给个路线在单独改个别文件的思想。 此警告就是某属性说好的不能为空，你又在某地方写了XX = nil 所以冲突了。</p>

<p>Auto property synthesis will not synthesize property &lsquo;privateCacheDirectory&rsquo;; it will be implemented by its superclass, use @dynamic to acknowledge intention</p>

<p>4.他说你的父类实现了setget方法，但是如果你什么都不写，就会系统自动生成出最一般的setget方法，请用@dynamic 来承认父类实现的这个getset方法。</p>

<p>Unsupported Configuration: Scene is unreachable due to lack of entry points and does not have an identifier for runtime access via -instantiateViewControllerWithIdentifier:.</p>

<p>5.一般是storyboard报的警告，简而言之就是你有的页面没有和箭头所指的控制器连起来，导致最终改页面可能无法显示。</p>

<p>Deprecated: Push segues are deprecated in iOS 8.0 and later</p>

<p>6.iOS8之后呢，不要再用push拖线了，统一用show，他会自己根据你是否有导航栏来判断走push还是走modal</p>

<p>Unsupported Configuration: Plain Style unsupported in a Navigation Item</p>

<p>7.导航栏的item 不支持用plain ，那就用Bordered呗。</p>

<p>The launch image set &ldquo;LaunchImage&rdquo; has 2 unassigned images.</p>

<p>The app icon set &ldquo;AppIcon&rdquo; has 2 unassigned images.</p>

<p>8.几张图标还是启动图找不到自己的位置，可能是一次导入了全部尺寸图片，但是右边的设置只勾了iOS8的 那iOS7尺寸的图标就会报此警告。删掉，或者对照右边匹配。</p>

<p>&lsquo;sizeWithFont:constrainedToSize:lineBreakMode:&rsquo; is deprecated: first deprecated in iOS 7.0 - Use -boundingRectWithSize:options:attributes:context:</p>

<p>9.方法废除，旧的方法sizeWithFontToSize在iOS7后就废除了取而代之是boundingRectWithSize方法</p>

<p>Undeclared selector &lsquo;historyAction&rsquo;</p>

<p>10.使用未声明的方法，一般出现在@selector() 括号里写了个不存在的方法或方法名写错了。</p>

<p>PerformSelector may cause a leak because its selector is unknown</p>

<p>11.这个和上面类似就是直接把上面那个@SEL拿来用会报这个警告</p>

<p>&lsquo;strongify&rsquo; macro redefined</p>

<p>12.这个宏声明重复,删一个吧</p>

<p>&lsquo;UITextAttributeFont&rsquo; is deprecated: first deprecated in iOS 7.0 - Use NSFontAttributeName</p>

<p>&lsquo;UITextAttributeTextColor&rsquo; is deprecated: first deprecated in iOS 7.0 - Use NSForegroundColorAttributeName</p>

<p>&lsquo;UITextAttributeTextShadowColor&rsquo; is deprecated: first deprecated in iOS 7.0 - Use NSShadowAttributeName with an NSShadow instance as the value</p>

<p>13.方法废除,一般一起出现</p>

<p>Code will never be executed</p>

<p>14.他说这代码永远也轮不到他执行，估计是有几行代码写在了return之后</p>

<p>Assigning to &lsquo;id&rsquo; from incompatible type &lsquo;SXTabViewController *const __strong&rsquo;</p>

<p>15.一般出现在xxx.delegate = self ，应该在上面遵守协议</p>

<p>Format specifies type &lsquo;unsigned long&rsquo; but the argument has type &lsquo;unsigned int&rsquo;</p>

<p>16.这个警告一般会出现在NSStringWithFormat里面 前面%d %lu 什么的和后面填进去的参数不匹配就报了警告</p>

<p>Values of type &lsquo;NSInteger&rsquo; should not be used as format arguments; add an explicit cast to &lsquo;long&rsquo; instead</p>

<p>17.类似于上面，也是format里面前后写的不匹配</p>

<p>Method &lsquo;dealWithURL:andTitle:andKeyword:&rsquo; in protocol &lsquo;SXPostAdDelegate&rsquo; not implemented</p>

<p>18.经典警告，遵守了协议，但是没有实现协议方法。 也可能你实现了只是又加了个参数或是你写的方法和协议方法名字有点轻微不同</p>

<p>Using integer absolute value function &lsquo;abs&rsquo; when argument is of floating point type</p>

<p>19.这个可以自动修正，就是说abs适用于整数绝对值，要是float取绝对值要用fabsf</p>

<p>Attribute Unavailable: Automatic Preferred Max Layout Width is not available on iOS versions prior to 8.0</p>

<p>20.有的方法你用的太落后了，也有的方法你用的太超前了。 说这个最大宽度在iOS8之前的系统是要坑的</p>

<p>Too many personality routines for compact unwind to encode</p>

<p>21.你可以在otherlink 中加入 -Wl,-no_compact_unwind 去掉该警告，根据苹果的解释，这个是由于某些地方 c/c++/oc/oc++混用会造成编译警告。一般没有什么伤害。</p>

<p>Property &lsquo;ssid&rsquo; requires method &lsquo;ssid&rsquo; to be defined - use @synthesize, @dynamic or provide a method implementation in this class implementation</p>

<p>22.说这个ssid必须要定义个这个属性的getter方法，如果警告是setSsid就是setter方法， 用@synthesize和@dynamic 都行，一个是让编译器生成getter和setter，一个是自己生成，如果你有模型分发或kvc之类的，选@dynamic就行</p>

<p>Unknown escape sequence &lsquo;)&rsquo;</p>

<p>23.未知的转义序列。 一般有个斜杠再加个东西他都会以为是转义字符，一看\）不认识就报警告了，一般正则表达式容易报这种警告</p>

<p>Property &lsquo;LoginPort&rsquo; not found on object of type &lsquo;LoginLvsTestTask *&rsquo;; did you mean to access property loginPort?</p>

<p>24.这种可以点击自动修复，是典型的大小写写错了，他提醒了一下。</p>

<p>Variable &lsquo;type&rsquo; is used uninitialized whenever switch default is taken</p>

<p>25.这是出现在switch语句中的警告， 一般可能是switch外面定义了个type但是并没有初始化（初始化操作都写在switch的各个分支里），然后在最后return type。 但是switch的有个分支没有对type初始化，他说如果你来到这个分支的话，那还没初始化就要被return。</p></blockquote>

<h2>我们该怎么面对warning</h2>

<p>从第一天开始编程，warning几乎比error都要更多的见到我。在正式做项目前，我几乎都是抱着“小婊砸哪里凉快去哪里的”态度的。在进入公司实习后，在某个强迫症的同事带领下，开始重视起来起来对warning的处理。事实上，warning应该比error更要重视。正是因为warning可以使编译通过，但是会造成我们并不知道的问题存在。这种“我知道你要挂但是我就是不告诉你”的事情，只有我们自己去解决warning，才是避免一切可怕的事情出现的根本。</p>

<p>有了强迫症，我们也可以通过warning为我们做点事情，比如通过``#warning TODO 来提示我们要需要注意的地方（特别是挖坑的时候）。</p>

<p>如果是自己写的文件或第三方库，有了新的接口，然后提示旧的接口废除的话需要在方法后加上宏NS_DEPRECATED_IOS和范围</p>

<p><code>- (void)addTapAction:(SEL)tapAction target:(id)target NS_DEPRECATED_IOS(2_0, 4_0);</code></p>

<p>如果需要在此方法后加上带信息的警告则需要这么写</p>

<p><code>
- (void)addTapAction:(SEL)tapAction target:(id)target __attribute((deprecated("这个接口会爆内存 不建议使用")));
-</code></p>

<p>最后想说一句：重视warning，避免Bug，养成强迫症。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-09-14T22:40:16+08:00" pubdate data-updated="true"></time></div>
	


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/09/13/socket/">
		
			Socket</a>
	</h2>
	<div class="entry-content">
		<h2>写在前面</h2>

<p>最近一直在找更好的实习，发现网络编程是一个优秀的程序员必备的技能。而自己在学校中学到的东西很少（逃。要不是有之前的实习和做个一个小小的项目，对于很多知识可能还只是停留在书本上（其实就是没进脑）。最近有人问我是否了解socket，我顿时语塞。对与socket的认识还是学习java的时候知道可以使用socket进行客户端与服务器端的通信，可是当时并没有去实践。欠下的债都是要还的。</p>

<p>此外为什么我每篇博文的开头都写点自己的感受。我觉得博客不仅仅是记录自己的技术积累，也是抒发自己心情的一个途经，所以我会在每篇文章前面写一点点自己在写博文的时候的心情。</p>

<h2>正文</h2>

<p>socket，套接字，是基于TCP/IP协议族下的一种网络通信方式。我们知道，在本地，进程之间有多种方法去通信。在网络中，我们同样可以使用socket进行通信。接下来一步步来看socket是如何使网络上的进程相互通信的。</p>

<p>我们知道，要像让进程通信，首先必须确认进程的身份。如同我们只有知道了和自己谈话的是谁，我们才知道谈什么。在本地，进程拥有唯一的标识PID。在网络上，基于TCP/IP协议，通过<em>IP，协议，端口号</em>，我们可以确认一个进程的唯一身份。</p>

<p>使用TCP/IP协议的应用程序通常采用应用编程接口，有本文讲到的socket（套接字）和TIL（被淘汰了）。目前而言，绝多大数的应用程序都是基于socket进行网络通信的，所以了解socket是一个程序员必备的。</p>

<h2>scocket 究竟是什么</h2>

<p>socket起源于UNIX。我们知道UNIX的设计原理就是<em>一切皆文件</em>，操作都是<em>open -> read/write -> close</em>。所以说，我们可以认为socket也是一个文件，是基于上述设计原理的实现。socket函数就是专门来完成相应操作的。</p>

<h2>socket 操作</h2>

<p>在上面我们知道了socket是一个文件，那么socket自然有对应的操作方法，下面是基于TCP的几个基本操作。
(注，本文的方法是使用Objective-C写的，其实socket在任何语言都是差不多的)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// 创建并初始化socket，返回socket的文件描述符，如果返回值为-1则创建失败</span>
</span><span class='line'><span class="kt">int</span> <span class="n">socket</span><span class="p">(</span><span class="kt">int</span> <span class="n">addresFamily</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 关闭socket</span>
</span><span class='line'><span class="kt">int</span> <span class="n">close</span><span class="p">(</span><span class="kt">int</span> <span class="n">socketFileDescriptor</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 将socket与特定的IP地址和端口号绑定，成功返回0，失败返回-1</span>
</span><span class='line'><span class="kt">int</span> <span class="n">bind</span><span class="p">(</span><span class="kt">int</span> <span class="n">socketFileDescriptor</span><span class="p">,</span> <span class="n">sockadd</span> <span class="o">*</span><span class="n">addressToBind</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 接受客户端的请求并且将客户端的网络地址信息存入clientAddress</span>
</span><span class='line'><span class="c1">// 当客户端的连接请求被接受后，双方的通信链路就建立好了，两者就可以开始通信了。</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">accept</span><span class="p">(</span><span class="kt">int</span> <span class="n">socketFileDescriptor</span><span class="p">,</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">clientAddress</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clientAddressStructLength</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 客户端向特定的IP的服务器发送连接请求，成功返回0，失败返回-1</span>
</span><span class='line'><span class="c1">// 当服务器建立好后，客户端就可以通过这个函数与服务器端建立连接。</span>
</span><span class='line'><span class="c1">// 对于UDP来说，该接口是可选的，如果调用了这个接口表明设置了UDP socket默认的网络地址.</span>
</span><span class='line'><span class="c1">// 对于TCP来说，这里就是三次握手发生的地方</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">connect</span><span class="p">(</span><span class="kt">int</span> <span class="n">socketFileDescriptor</span><span class="p">,</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">serverAddress</span><span class="p">,</span> <span class="kt">int</span> <span class="n">serverAddressLength</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 通过DNS查找特定的IP，如果找不到返回NULL</span>
</span><span class='line'><span class="n">hostent</span> <span class="o">*</span><span class="n">gethostbyname</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 发送数据，发送成功后返回成功发送的字节数，否则返回-1</span>
</span><span class='line'><span class="kt">int</span> <span class="n">send</span><span class="p">(</span><span class="kt">int</span> <span class="n">socketFileDescriptor</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 接收数据，成功后返回成功读取的字节数，否则返回-1</span>
</span><span class='line'><span class="kt">int</span> <span class="n">receive</span><span class="p">(</span><span class="kt">int</span> <span class="n">socketFileDesciptor</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 下面两个方法是UDP的方法</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// UDP发送,返回状态同上</span>
</span><span class='line'><span class="kt">int</span> <span class="n">sendto</span><span class="p">(</span><span class="kt">int</span> <span class="n">socketFileDesciptor</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufferLength</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">destinationAddress</span><span class="p">,</span> <span class="kt">int</span> <span class="n">destinationAddressLength</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// UDP读取，返回状态同上</span>
</span><span class='line'><span class="kt">int</span> <span class="n">recvfrom</span><span class="p">(</span><span class="kt">int</span> <span class="n">socketFileDesciptor</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufferLength</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">fromAddress</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fromAddressLength</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过观察方法，我们发现socket其实就是<em>确认目标 ->建立连接 -> 传送/读取 -> 断开</em> 的过程</p>

<p>我们再来看看TCP和UDP下socket操作的不同的地方</p>

<h4>TCP</h4>

<p><img src="http://www.coderyi.com//qiniu/429/image/5269612b25e6df1b3ee5ab8352b2c3b6.jpg" alt="TCP" /></p>

<h4>UDP</h4>

<p><img src="http://www.coderyi.com//qiniu/429/image/cd6d1690d3d6eefd300987e590c1483f.jpg" alt="UDP" /></p>

<h2>最后</h2>

<p>到此，对于socket编程的概念有了个一个初步的认识了。在实际开发中，我们一般不会直接调用这些底层的API。借助于一些开源的第三方库更有利于项目的开发运行。不过，对于基本的理论知识还是必须要掌握的。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-09-13T05:27:26+08:00" pubdate data-updated="true"></time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/network/'>network</a>

</div>


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/09/12/gcd/">
		
			GCD小结</a>
	</h2>
	<div class="entry-content">
		<h1>写在最前面</h1>

<p>最近发现自己学东西的效率好像高了，难道是因为写博客做笔记的原因吗？的确通过写博客来记录自己学习的成果能够加强自己对很多问题的理解。只有能够通过自己的语言将学习到的内容讲出来才是真的理解。所以以后看来要多写写。</p>

<h1>正文</h1>

<h2>GCD是什么鬼</h2>

<p>GCD，简单的来说就是苹果自己出的一套多核运算的解决方案。虽然苹果没有安卓那么多核心，但是并行化运算能够提高流程性是不可争辩的事实。GCD内部自动管理线程 的生命周期，不需要我们自己去手动管理。我们只需要调用对应的API就可以了。GCD是基于C语言开发的，不过由于使用了block，所以使用起来很方便。在了解GCD之前，我们需要了解一点多线程运行的原理。</p>

<h2>基本概念</h2>

<p>GCD中有两个重要的概念：<em>任务</em> 和 <em>队列</em></p>

<ol>
<li>任务。我们可以理解任务就是一个动作，放在GCD中就是一个代码块（block）。执行任务有两种，分别为<em>同步执行</em> 和 <em>异步执行</em>。同步和异步的区别其实很好理解。<code>同步执行</code>既是当前任务执行完前会阻塞当前进程，<code>而异步执行</code>就不会。</li>
<li>队列。队列是用来存放任务的。我们可以理解为任务就是队列中排队等待执行。队列分为<em>串行队列</em>和<em>并行队列</em>。</li>
<li>串行队列，就像排队一样，严格遵守FIFO。</li>
<li>并行队列，同样执行FIFO。不同的是，取出来的任务会根据情况放到别的线程上。由于多个线程出队的时间间隔可能很短，所以容易认为是非FIFO的。不过即使这样，系统也会根据硬件条件来判断，并不一定会所有任务都在同时执行。</li>
</ol>


<hr />

<p>  创建队列的操作如下图所示</p>

<p>  <img src="http://i3.tietuku.com/045e13ec06064ef3.png" alt="queue" /></p>

<hr />

<p>  创建任务如下如图所示</p>

<p>  <img src="http://i3.tietuku.com/b2ef139ced93771f.png" alt="task" /></p>

<h4>队列组</h4>

<p>  对列组就是将多个队列添加到一个组里。这样的方式使我们可以在队列里所有的任务都完成后收到一个通知方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  objective-c
</span><span class='line'>  
</span><span class='line'>  // 创建队列组
</span><span class='line'>    dispatch_group_t group = dispatch_group_create();
</span><span class='line'>
</span><span class='line'>    dispatch_group_async(group, globalQueue, ^{
</span><span class='line'>      for (NSInteger i = 0; i &lt; 3; i++)
</span><span class='line'>      {
</span><span class='line'>          NSLog(@"group - queue - %@", [NSThread currentThread]);
</span><span class='line'>      }
</span><span class='line'>    });
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<h2>NSOperation 和 NSOperationQueue</h2>

<p>  NSOperation 和 NSOperationQueue是苹果对GCD的基于面向对象的完全封装，使其更容易理解。操作方式也更简单</p>

<ol>
<li>将要执行的任务封装到一个<code>NSOperation</code>对象中</li>
<li>将任务添加到一个<code>NSOperationQueue</code>中</li>
</ol>


<p>  此后系统将自动在执行任务。</p>

<h3>添加任务</h3>

<p> 由于NSOperation是一个抽象类，所以不能直接封装任务。但是有两个子类用于封装任务：<code>NSInvocationOperation</code> 和 <code>NSBlockOperation</code>。创建一个队列后，需要调动<code>start()</code>方法来启动，<em>默认在当前队列同步执行</em>。同时队列提供<code>cancel()</code>方法在中途取消任务。</p>

<ul>
<li>NSInvocationOperation 传入一个方法名。</li>
<li>NSBlockOperation 传入一个代码块。

<ul>
<li>在NSBlockOperation中，有一个方法<code>addExecutionBlock</code>方法。这个方法使我们可以添加多个block到队列中。<em>这些block将会并发执行**，将在</em>主线程和其他的多个线程``执行任务</li>
</ul>
</li>
</ul>


<h3>添加队列</h3>

<p>   多数时候，我们不希望当前线程被占用，因为会影响到UI的流畅性（UI永远在主线程上）。因此我们需要创建新的队列。只要我们添加任务到队列上，就会自动调用任务的<code>start()</code>方法。如果任务在其他队列上，那么他就会在其他线程上并行执行。</p>

<p>   我们发现，<code>NSOperationQueue</code>并没有设置串行和并行队列的问题，那么<code>NSOperationQueue</code>是怎么确定队列的类型的呢。苹果通过封装巧妙的使调用者不需要特意的去注意队列的性质，只需要设置<code>NSOperationQueue</code>中的<code>maxConcurrentOperationCount</code> &ndash; 最大并发数就可以了。</p>

<h2>总结</h2>

<p>   在上篇block的文章中也谈到了block在gcd的中的应用。通过gcd，我们可以最大化的去使用硬件的性能，避免出现卡顿的现象。多线程用的好不好，也基本上代表了一个开发者的能力水平。虽然多线程编程有许多坑，但只有跨过一个个坑，才能变成大牛，不是吗？</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-09-12T21:16:43+08:00" pubdate data-updated="true"></time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/objective-c/'>objective-c</a>

</div>


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/09/10/http/">
		
			HTTP学习</a>
	</h2>
	<div class="entry-content">
		<h1>HTTP学习</h1>

<p>HTTP协议是网络中最广泛的协议之一，对HTTP协议的了解应该是每一个和网络打交道的程序员必须具备的技能。很多公司面试都要求对网络知识有一定的了解，一个是TCP/IP协议，一个就是HTTP协议，HTTP协议应用层的协议，内容比较少，这周花时间去总结了一下，做一个备忘。</p>

<h2>HTTP简单分析</h2>

<p>HTTP是一个基于请求/响应模式的、无状态的协议。即，浏览器与服务端连接之后，浏览器向服务器发送一个请求，服务器返回响应信息之后，双方的链接就被关闭。</p>

<p>HTTP1.0是典型的请求/响应模式。</p>

<p>HTTP1.1在1.0的基础上进行了改进，加入了“持续连接”的机制。通过这种机制，客户端发送请求得到响应后，连接不会马上关闭，可以继续发送请求，还可以流水线发送多个请求、而不用等待每一个响应的到来。</p>

<ul>
<li><p>URI和URL + URL我们应该是很熟悉的了，全名是统一资源定位符，包含了需要查找的信息的资源。 + 而URI是URL的父集，纯粹是一个WEB的资源符号</p>

<h2>HTTP请求</h2></li>
</ul>


<p><img src="http://i3.tietuku.com/2c834f74cd465d7e.png" alt="HTTP Request" /></p>

<p>简单的来说 HTTP请求可以分为三部分</p>

<ol>
<li><p>请求行</p></li>
<li><p>消息报头</p></li>
<li><p>请求正文</p></li>
</ol>


<h3>请求行</h3>

<hr />

<p>请求行主要的内容是是请求方法和请求的位置（URL）</p>

<p>请求方法主要有以下几种方法（注意方法都是全部字母大写）</p>

<p><img src="http://i3.tietuku.com/05fa7108f6959f91.png" alt="HTTP Request method" /></p>

<p>在APP中，最多用的到的就是POST 和 GET 两种方法。许多地方都要求区别两者的区别，所以在这里做一下重点笔记对比两者方法的不同</p>

<p>（在这里小小的吐槽，在学校计算机网络的学习中，POST和GET的区别基本就是一句话：POST比GET更好更安全。其实在查阅了许多资料后，发现并没有那么简单）</p>

<hr />

<h4>POST</h4>

<ul>
<li><p>根据HTTP规范，POST表示可能修改服务器上的资源的请求，比如提交表格，注册等等都是常用POST</p></li>
<li><p>POST将请求的正文包在HTTP包体中</p></li>
<li><p>POST没有大小限制</p></li>
</ul>


<hr />

<h4>GET</h4>

<ul>
<li>GET操作，根据HTTP规范，仅仅用于信息获取，而且是应该是安全的幂等。</li>
<li><p>GET操作会将请求的数据附在URL后面，参数之间以&amp;相连（这就是为什么很多人认为GET不安全了）</p></li>
<li><p>GET的数据限制，由于浏览器或者服务器可能会对URL存在长度限制，所以有可能会产生影响</p></li>
</ul>


<p> 通过对比，我们发现常见的误区有两个</p>

<ol>
<li><p>POST比GET更安全。通过上面对比，我们发现，虽然POST没有将参数直接放在URL中，但是通过抓包的手段，我们依然可以获得HTTP包体中的参数。由此看来，想依靠POST就简单保证安全是不可能的。</p></li>
<li><p>POST能比GET传输更多。通过上面的叙述也可以得知，其实HTTP协议本身没有进行限制，POST和GET都没有大小限制，而是第三方的浏览器和服务器造成了差别</p></li>
</ol>


<p>什么时候用POST，什么时候用GET，我们要依据不同的使用场景来区分。如果有缓存的需求，那自然就不能用POST方法。如果必须要用表格，GET也不行了。</p>

<h2>HTTP响应</h2>

<p>请求响应类似与请求。如图所示</p>

<p>可以看到，HTTP响应的第一行叫状态行，包含了HTTP版本，状态码，状态描述信息。</p>

<p>状态码是判断请求状态的重要标志，由三位数字组成，有五种定义：</p>

<ol>
<li>1XX &mdash;- 请示信息，表示请求已经接受，可以继续处理</li>
<li>2XX &mdash;- 成功状态，表示请求被服务器接受</li>
<li>3XX &mdash;- 重定向，要完成请求的话需要更进一步的操作</li>
<li>4XX &mdash;- 客户端错误，请求错误或者请求无法被实现</li>
<li>5XX &mdash;- 服务器端错误，服务器未能完成合法的请求</li>
</ol>


<p>全部取值如下：</p>

<blockquote><pre><code>   100——客户必须继续发出请求
   101——客户要求服务器根据请求转换HTTP协议版本


    200——交易成功
    201——提示知道新文件的URL
    202——接受和处理、但处理未完成
    203——返回信息不确定或不完整
    204——请求收到，但返回信息为空
    205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
    206——服务器已经完成了部分用户的GET请求

    300——请求的资源可在多处得到
    301——删除请求数据
    302——在其他地址发现了请求数据
    303——建议客户访问其他URL或访问方式
    304——客户端已经执行了GET，但文件未变化
    305——请求的资源必须从服务器指定的地址得到
    306——前一版本HTTP中使用的代码，现行版本中不再使用
    307——申明请求的资源临时性删除

    400——错误请求，如语法错误
    401——请求授权失败
    402——保留有效ChargeTo头响应
    403——请求不允许
    404——没有发现文件、查询或URl
    405——用户在Request-Line字段定义的方法不允许
    406——根据用户发送的Accept拖，请求资源不可访问
    407——类似401，用户必须首先在代理服务器上得到授权
    408——客户端没有在用户指定的饿时间内完成请求
    409——对当前资源状态，请求不能完成
    410——服务器上不再有此资源且无进一步的参考地址
    411——服务器拒绝用户定义的Content-Length属性请求
    412——一个或多个请求头字段在当前请求中错误
    413——请求的资源大于服务器允许的大小
    414——请求的资源URL长于服务器允许的长度
    415——请求资源不支持请求项目格式
    416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段
    417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求

    500——服务器产生内部错误
    501——服务器不支持请求的函数
    502——服务器暂时不可用，有时是为了防止发生系统过载
    503——服务器过载或暂停维修
    504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长
    505——服务器不支持或拒绝支请求头中指定的HTTP版本
</code></pre></blockquote>

<p> 常见的错误主要有400 404 403 500 503等等</p>

<p>相应正文，包含了请求获得的资源，有HTML文件，JSON格式数据，文件的URL等等</p>

<h3>消息报头</h3>

<hr />

<p>HTTP请求和HTTP响应都有消息报头。而消息报头是由众多报头域组成。每一个报头域都由名字＋“：”＋空格组成，消息报头域的名字是大小写无关的。</p>

<p>HTTP消息报头包括普通报头、请求报头、响应报头和实体报头。</p>

<hr />

<h4>普通报头：</h4>

<p>在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。</p>

<p>常见的普通报头：</p>

<p>1）Cache-Control</p>

<pre><code>Cache-Control用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。

请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;
响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.
</code></pre>

<p>2）Date</p>

<pre><code>Date普通报头域表示消息产生的日期和时间
</code></pre>

<p>3）Connection</p>

<pre><code>Connection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接
</code></pre>

<hr />

<h4>请求报头</h4>

<p>请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。
（在APP中，一些身份验证的信息可能需要在header中添加）</p>

<p>常见的请求报头：</p>

<p>1)Accept</p>

<pre><code>Accept请求报头域用于指定客户端接受哪些类型的信息。
</code></pre>

<p>2)Accept-Charset</p>

<pre><code>Accept-Charset请求报头域用于指定客户端接受的字符集。如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。
</code></pre>

<p>3）Accept-Encoding</p>

<pre><code>Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。
</code></pre>

<p>4）Accept-Language</p>

<pre><code>Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。
</code></pre>

<p>5）Authorization</p>

<pre><code>Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。
</code></pre>

<p>6）Host</p>

<pre><code>发送请求时，该报头域是必需的。Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。
</code></pre>

<p>7）User-Agent</p>

<pre><code>User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。
</code></pre>

<hr />

<h4>响应报头</h4>

<p>响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。</p>

<p>常见的实体报头：</p>

<p>1）Location</p>

<pre><code>Location响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。
</code></pre>

<p>2）Server</p>

<pre><code>Server响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。
</code></pre>

<p>3）WWW-Authenticate</p>

<pre><code>WWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。
</code></pre>

<hr />

<h4>实体报头</h4>

<p>请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。</p>

<p>实体报头包括：</p>

<p>常见的实体报头：</p>

<p>1）Content-Encoding</p>

<pre><code>Content-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding主要用于记录文档的压缩方法。
</code></pre>

<p>2）Content-Language</p>

<pre><code>Content-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言
</code></pre>

<p>阅读者。</p>

<p>3）Content-Length</p>

<pre><code>Content-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。即一个数字字符占一个字节，用其对应的ASCII码来存储传输。
</code></pre>

<p>4）Content-Type</p>

<pre><code>Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。
</code></pre>

<p>5）Expires</p>

<pre><code>Expires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。
</code></pre>

<p>6）Last-Modified</p>

<pre><code>Last-Modified实体报头域用于指示资源的最后修改日期和时间。
</code></pre>

<h2>总结</h2>

<p>HTTP协议的内容不是多，常用的内容就几个，但是需要非常熟悉，因为HTTP协议是网络交互重要的协议之一。</p>

<p>接下来花一些时间去回顾TCP/IP协议，内容多就会有几篇文章来记录学习的一些笔记心得。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-09-10T23:46:08+08:00" pubdate data-updated="true"></time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/network/'>network</a>

</div>


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/09/07/block/">
		
			Block</a>
	</h2>
	<div class="entry-content">
		<h2>Block是个什么</h2>

<p>和kvo/kvc一样，block的使用也是我在学习Objective-C的过程中碰到的一个大拦路虎。第一遍过语法的时候并没有太注意这部分的内容。而到了后面阅读各类大神的源码的时候，发现block的应用非常多。而对这块内容的疏忽导致自己一直不能很顺利的阅读各类代码，在项目中也是一知半解的应用，所以在这里想总结下。</p>

<h3>Blcok 是什么</h3>

<p>block是在iOS SDK 4.0引入的黑魔法。从他诞生的时候，Apple就倾注了大量的心血。字面上看，block就是一个代码块。在许多语言中都可以看到相似的语法设计。但是block自身由于可以在内联执行的时候还可以传递参数，同时自身可以作为参数在函数之间来传递，所有有了许多神奇的用法（好吧是我觉得很神奇）</p>

<p>一个典型的block的应用如下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> BOOL (^isName)(NSString *) = ^(NSString *name) {
</span><span class='line'>      if ([name isEqualToString:@"csb"])
</span><span class='line'>      {
</span><span class='line'>          return YES;
</span><span class='line'>      }
</span><span class='line'>      else
</span><span class='line'>      {
</span><span class='line'>          return NO;
</span><span class='line'>      }
</span><span class='line'>    };</span></code></pre></td></tr></table></div></figure>


<p>定义一个block开头是和函数一样是返回类型，（^）跟着是block的名字，后面跟着是传入的数据类型。括号里面是代码块。</p>

<p>一个完整的例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>- (void)blockTest
</span><span class='line'>{
</span><span class='line'>    BOOL (^isName)(NSString *) = ^(NSString *name) {
</span><span class='line'>      if ([name isEqualToString:@"csb"])
</span><span class='line'>      {
</span><span class='line'>          return YES;
</span><span class='line'>      }
</span><span class='line'>      else
</span><span class='line'>      {
</span><span class='line'>          return NO;
</span><span class='line'>      }
</span><span class='line'>    };
</span><span class='line'>
</span><span class='line'>    self.sark.name = @"csb";
</span><span class='line'>    NSLog(@"is csb ? %@", isName(self.sark.name) ? @"yes" : @"no");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>那么block有什么特别之处？前面提到了，block能够使用block外的参数，我们来实验下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)blockTest
</span><span class='line'>{
</span><span class='line'>    NSString *csbName = @"csbzhixing";
</span><span class='line'>    BOOL (^isName)(NSString *) = ^(NSString *name) {
</span><span class='line'>      if ([name isEqualToString:csbName])
</span><span class='line'>      {
</span><span class='line'>          return YES;
</span><span class='line'>      }
</span><span class='line'>      else
</span><span class='line'>      {
</span><span class='line'>          return NO;
</span><span class='line'>      }
</span><span class='line'>    };
</span><span class='line'>
</span><span class='line'>    self.sark.name = @"csbzhixing";
</span><span class='line'>    NSLog(@"is csb ? %@", isName(self.sark.name) ? @"yes" : @"no");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>输出
<code>
2015-09-07 16:48:25.452 CSBRepository[83032:1549339] is csb ? yes
</code></p>

<p>注意到，定义了block后，修改了block中引用的局部变量，那么block中的局部变量仍然会保持不变。</p>

<p><img src="http://i3.tietuku.com/a60eb087f6bfd358.png" alt="pic1" /></p>

<p>好吧，如果我们的确有这个需求怎么弄呢？使用<code>_block</code>修饰符来修饰局部变量可以解决这个问题</p>

<p><img src="http://i3.tietuku.com/ba1814837f233066.png" alt="pic2" /></p>

<p>block调用实例变量，这个没有好说的。。直接用就是了。</p>

<h2>小小的问题，循环引用</h2>

<p>需要注意的一个问题是block的retain cycle问题，即循环引用。</p>

<p>如果要细究这个问题，要回到老生常谈的引用计数的问题上。有许多很详细的文章解释了为何存在这种问题，在这里我只简单的谈下我的理解。</p>

<p>retain cycle的问题根源在于block和object可能会互相强引用，互相retain了对方，这样就导致了retain cycle的问题。到了最后就发现两者谁也释放不了谁，导致了崩溃。（你不让我，我不让你怎么行）。</p>

<p>解决的方法就是打破这种循环，使用弱引用。这点可以参考最有名的第三方库AFNetworking的源码，在block上afn的写法最值得参考学习。</p>

<h2>Block该用在什么地方</h2>

<p>在项目中，主要应用block的地方有场景之间的数据传输，UI刷新，网络请求等等。在参考官方的建议和大神的博客后，总结了一下几个方面</p>

<ol>
<li>枚举 &ndash; 通过block获取对象和控制枚举进程</li>
<li>View动画 &ndash; 规定动画，参考官方的demo可以很快的了解</li>
<li>通知 &ndash; 事件完成后执行block内的代码，比如网络请求成功后</li>
<li>完成 &ndash; 同上</li>
<li>GCD多线程 &ndash; 这个是下一篇想要去了解学习的内容</li>
<li>错误处理 &ndash; 错误发生的时候执行</li>
<li>排序</li>
</ol>


<p>深入学习block还有很多的内容，比如block是怎么实现，block的类型等等。这里只是我目前学习的一个小结，有机会还要再深入的学习。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-09-07T17:25:40+08:00" pubdate data-updated="true"></time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/objective-c/'>objective-c</a>

</div>


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/09/07/kvo-kvc/">
		
			Kvo/kvc小结</a>
	</h2>
	<div class="entry-content">
		<p>从学习Objective-C以来，有两个地方一直搞不明白。一个是KVO和KVC的应用和与Delegate的应用场景的区别，一个是Block的应用场景。总结起来就死对Objective-C的数据传送的应用不理解。乘着放假几天对这个知识点进行了一些学习和总结，学习了一个小demo，在这里记录一下自己的学习情况。</p>

<p>参考</p>

<ol>
<li>&ndash; <a href="http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/">http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/</a></li>
<li>&ndash; <a href="http://objccn.io/issue-7-3/">http://objccn.io/issue-7-3/</a></li>
</ol>


<h1>KVO</h1>

<h2>KVO简单使用</h2>

<h4>KVO(Key Value Observing)，是观察者模式在Foundation中的实现</h4>

<p>观察者模式，比较容易理解，就是一方对另一方观察，如果进行了改变，那么就要观察者接收到了消息就用进行相应的操作。在KVO中，总结起来就死以下几个操作。</p>

<ol>
<li>当一个object有观察者的时候，动态创建这个object的子类。</li>
<li>对于每一个被观察的属性Property,重写他的set方法</li>
<li>在重写的set方法中，调用 <code>- willChangeValueForKey</code> 和 <code>- didChangeValueForKey</code> 方法</li>
<li>当一个属性Property没有被观察的时候，删除重写的方法</li>
<li>当没有observer观察任何一个property的时候，删除动态创建的子类</li>
</ol>


<p>使用的时候，主要通过以下几个方法来使用</p>

<p><code>addObserver:&lt;#(NSObject *)#&gt; forKeyPath:&lt;#(NSString *)#&gt; options:&lt;#(NSKeyValueObservingOptions)#&gt; context:&lt;#(void *)#&gt;</code></p>

<p>通过这个方法来为一个对象添加观察者，观察减值“key”,option是观察返回的类型字典，总共有以下几种</p>

<ol>
<li>NSKeyValueObservingOptionOld &ndash; 变化前的值</li>
<li>NSKeyValueObservingOptionNew &ndash; 变化后的值</li>
<li>NSKeyValueObservingOptionPrior &ndash; 值变化前进行通知</li>
<li>NSKeyValueObservingOptionInitial &ndash; 在添加观察者的时候出发相关方法</li>
</ol>


<p>context 是一个指针当<code>observeValueForKeyPath:ofObject:change:context:</code>方法执行时context会提供给观察者。context可以是C指针或者一个对象引用，既可以当作一个唯一的标识来分辨被观察的变更，也可以向观察者提供数据。</p>

<h4>当观察者接受到消息的时</h4>

<p>当被观察的属性变更时，观察者会接到<code>observeValueForKeyPath:ofObject:change:context:</code>消息，所有的观察者都必须实现这个方法。
观察者会被提供触发通知的对象和keyPath，一个包含变更详细信息的字典，还有一个注册观察者时提供的context指针。</p>

<p>关于change字典，总共包含以下五个键值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString *const NSKeyValueChangeKindKey;  
</span><span class='line'>NSString *const NSKeyValueChangeNewKey;  
</span><span class='line'>NSString *const NSKeyValueChangeOldKey;  
</span><span class='line'>NSString *const NSKeyValueChangeIndexesKey;  
</span><span class='line'>NSString *const NSKeyValueChangeNotificationIsPriorKey;</span></code></pre></td></tr></table></div></figure>


<ol>
<li>NSKeyValueChangeKindKey</li>
</ol>


<p>指明了变更的类型，值为“NSKeyValueChange”枚举中的某一个，类型为NSNumber。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum {
</span><span class='line'>   NSKeyValueChangeSetting = 1,
</span><span class='line'>   NSKeyValueChangeInsertion = 2,
</span><span class='line'>   NSKeyValueChangeRemoval = 3,
</span><span class='line'>   NSKeyValueChangeReplacement = 4
</span><span class='line'>};
</span><span class='line'>typedef NSUInteger NSKeyValueChange;</span></code></pre></td></tr></table></div></figure>


<ol>
<li>NSKeyValueChangeNewKey</li>
</ol>


<p>如果 <code>NSKeyValueChangeKindKey</code>的值为 <code>NSKeyValueChangeSetting</code>，并且 <code>NSKeyValueObservingOptionNew</code>选项在注册观察者时也指定了，那么这个键的值就是属性变更后的新值。
对于 <code>NSKeyValueChangeInsertion</code>或者<code>NSKeyValueChangeReplacement</code>，如果 <code>NSKeyValueObservingOptionNew</code>选项在注册观察者时也指定了，这个键的值是一个数组，其包含了插入或替换的对象</p>

<ol>
<li>NSKeyValueChangeOldKey</li>
</ol>


<h2>移除观察者</h2>

<p>你可以通过发送removeObserver:forKeyPath:消息来移除观察者，你需要指明观察对象和路径</p>

<p>注意，在移除观察者之前，如果context是一个对象的引用，那么必须保持对它的强引用直到观察者被移除。</p>

<h2>注册依赖键</h2>

<p>有时候，有些属性的值取决于一个或者多个属性的值，一旦某个依赖的属性的值改变了，依赖它的属性的值需要被通知进行改变。</p>

<h3>To - One</h3>

<p>要触发to - one 关系，有两种方法
1. 定义名称为 <code>keyPathForValueAffecting&lt;key&gt;</code>方法
2. 重写 <code>keyPathForValueAffectingForKey:</code> 方法</p>

<h3>To - Many</h3>

<p>由于<code>keyPathForValueAffectingForKey</code>不支持包含to-many关系的keypath。如果一个类的属性对另一个类的多个属性有依赖关系的时候，必须通过其他方法来实现KVO。</p>

<ol>
<li><p>将parent类作为所有children类的相关属性的观察者。此时必须注意如果将将child类添加或者删除的时候必须对parent类对child类的观察者添加或者删除。此时通过<code>observeValueForKeyPath:ofObject:change:context:</code>可以通过对被依赖属性的变化来更新依赖属性的值。</p></li>
<li><p>Core Data中有另外一种实现观察者模式的方法，由于我还没有使用过Core Data,暂且不谈</p></li>
</ol>


<h2>调试KVO</h2>

<p>在LLDB中，我们可以通过<code>po [object observationInfo]</code>来获取观察者信息</p>

<h1>KVC</h1>

<h2>KVC简单使用</h2>

<p>KVC即是键值编码。以字符串的形式向对象发送消息，这个字符串是我们关注的焦点。</p>

<p>基本调用是<code>-valueForKey</code> 和 <code>-setValue:forKey</code></p>

<p>对于KVC，Cocoa自动放入和取出标量值（int，float和struct）放入NSNumber和NSValue中，当使用<code>-setValue:forKey</code>的使用，他自动将标量值从这些对象中取出。</p>

<p>使用KVC访问属性的代价比直接使用存取方法要大，所以只有在需要的时候才使用。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-09-07T11:50:52+08:00" pubdate data-updated="true"></time></div>
	


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/09/05/markdown/">
		
			用markdown来写博客</a>
	</h2>
	<div class="entry-content">
		<h2>用Markdown来写作</h2>

<p>在实习的时候第一次接触了这种语法，在CSDN中也用过一些。感觉用这种语法来写作更有利自己的编写格式，能够根据不同的场景进行一定的标记。在这里借用 <em>markdown.tw</em>的语法说明，为自己以后更好的写作作一个小小的开始</p>

<h4>Markdown: 语法</h4>

<hr />

<ul>
<li><a href="#overview">概述</a>

<ul>
<li><a href="#philosophy">哲學</a></li>
<li><a href="#html">行內 HTML</a></li>
<li><a href="#autoescape">特殊字元自動轉換</a></li>
</ul>
</li>
<li><a href="#block">區塊元素</a>

<ul>
<li><a href="#p">段落和換行</a></li>
<li><a href="#header">標題</a></li>
<li><a href="#blockquote">區塊引言</a></li>
<li><a href="#list">清單</a></li>
<li><a href="#precode">程式碼區塊</a></li>
<li><a href="#hr">分隔線</a></li>
</ul>
</li>
<li><a href="#span">區段元素</a>

<ul>
<li><a href="#link">連結</a></li>
<li><a href="#em">強調</a></li>
<li><a href="#code">程式碼</a></li>
<li><a href="#img">圖片</a></li>
</ul>
</li>
<li><a href="#misc">其它</a>

<ul>
<li><a href="#backslash">跳脫字元</a></li>
<li><a href="#autolink">自動連結</a></li>
</ul>
</li>
<li><a href="#acknowledgement">感謝</a></li>
</ul>


<p><strong>注意：</strong>這份文件是用 Markdown 寫的，你可以<a href="https://github.com/othree/markdown-syntax-zhtw/blob/master/syntax.md">看看它的原始檔</a> 。</p>

<hr />

<h2 id="overview">概述</h2>




<h3 id="philosophy">哲學</h3>


<p>Markdown 的目標是實現「易讀易寫」。</p>

<p>不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。Markdown 語法受到一些既有 text-to-HTML 格式的影響，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/">atx</a>、<a href="http://textism.com/tools/textile/">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/">EtText</a>，然而最大靈感來源其實是純文字的電子郵件格式。</p>

<p>因此 Markdown 的語法全由標點符號所組成，並經過嚴謹慎選，是為了讓它們看起來就像所要表達的意思。像是在文字兩旁加上星號，看起來就像*強調*。Markdown 的清單看起來，嗯，就是清單。假如你有使用過電子郵件，區塊引言看起來就真的像是引用一段文字。</p>

<h3 id="html">行內 HTML</h3>


<p>Markdown 的語法有個主要的目的：用來作為一種網路內容的<em>寫作</em>用語言。</p>

<p>Markdown 不是要來取代 HTML，甚至也沒有要和它相似，它的語法種類不多，只和 HTML 的一部分有關係，重點<em>不是</em>要創造一種更容易寫作 HTML 文件的語法，我認為 HTML 已經很容易寫了，Markdown 的重點在於，它能讓文件更容易閱讀、編寫。HTML 是一種<em>發佈</em>的格式，Markdown 是一種<em>編寫</em>的格式，因此，Markdown 的格式語法只涵蓋純文字可以涵蓋的範圍。</p>

<p>不在 Markdown 涵蓋範圍之外的標籤，都可以直接在文件裡面用 HTML 撰寫。不需要額外標註這是 HTML 或是 Markdown；只要直接加標籤就可以了。</p>

<p>只有區塊元素──比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等標籤，必須在前後加上空行，以利與內容區隔。而且這些（元素）的開始與結尾標籤，不可以用 tab 或是空白來縮排。Markdown 的產生器有智慧型判斷，可以避免在區塊標籤前後加上沒有必要的 <code>&lt;p&gt;</code> 標籤。</p>

<p>舉例來說，在 Markdown 文件裡加上一段 HTML 表格：</p>

<pre><code>This is a regular paragraph.

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;Foo&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

This is another regular paragraph.
</code></pre>

<p>請注意，Markdown 語法在 HTML 區塊標籤中將不會被進行處理。例如，你無法在 HTML 區塊內使用 Markdown 形式的<code>*強調*</code>。</p>

<p>HTML 的區段標籤如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 則不受限制，可以在 Markdown 的段落、清單或是標題裡任意使用。依照個人習慣，甚至可以不用Markdown 格式，而採用 HTML 標籤來格式化。舉例說明：如果比較喜歡 HTML 的  <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 標籤，可以直接使用這些標籤，而不用 Markdown 提供的連結或是影像標示語法。</p>

<p>HTML 區段標籤和區塊標籤不同，在區段標籤的範圍內， Markdown 的語法是有效的。</p>

<h3 id="autoescape">特殊字元自動轉換</h3>


<p>在 HTML 文件中，有兩個字元需要特殊處理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符號用於起始標籤，<code>&amp;</code> 符號則用於標記 HTML 實體，如果你只是想要使用這些符號，你必須要使用實體的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p>

<p><code>&amp;</code> 符號其實很容易讓寫作網路文件的人感到困擾，如果你要打「AT&amp;T」 ，你必須要寫成「<code>AT&amp;amp;T</code>」 ，還得轉換網址內的 <code>&amp;</code> 符號，如果你要連結到：</p>

<pre><code>http://images.google.com/images?num=30&amp;q=larry+bird
</code></pre>

<p>你必須要把網址轉成：</p>

<pre><code>http://images.google.com/images?num=30&amp;amp;q=larry+bird
</code></pre>

<p>才能放到連結標籤的 <code>href</code> 屬性裡。不用說也知道這很容易忘記，這也可能是 HTML 標準檢查所檢查到的錯誤中，數量最多的。</p>

<p>Markdown 允許你直接使用這些符號，但是你要小心跳脫字元的使用，如果你是在HTML 實體中使用 <code>&amp;</code> 符號的話，它不會被轉換，而在其它情形下，它則會被轉換成 <code>&amp;amp;</code>。所以你如果要在文件中插入一個著作權的符號，你可以這樣寫：</p>

<pre><code>&amp;copy;
</code></pre>

<p>Markdown 將不會對這段文字做修改，但是如果你這樣寫：</p>

<pre><code>AT&amp;T
</code></pre>

<p>Markdown 就會將它轉為：</p>

<pre><code>AT&amp;amp;T
</code></pre>

<p>類似的狀況也會發生在 <code>&lt;</code> 符號上，因為 Markdown 支援 <a href="#html">行內 HTML</a> ，如果你是使用 <code>&lt;</code> 符號作為 HTML 標籤使用，那 Markdown 也不會對它做任何轉換，但是如果你是寫：</p>

<pre><code>4 &lt; 5
</code></pre>

<p>Markdown 將會把它轉換為：</p>

<pre><code>4 &amp;lt; 5
</code></pre>

<p>不過需要注意的是，code 範圍內，不論是行內還是區塊， <code>&lt;</code> 和 <code>&amp;</code> 兩個符號都<em>一定</em>會被轉換成 HTML 實體，這項特性讓你可以很容易地用 Markdown 寫 HTML code （和 HTML 相對而言， HTML 語法中，你要把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都轉換為 HTML 實體，才能在 HTML 文件裡面寫出 HTML code。）</p>

<hr />

<h2 id="block">區塊元素</h2>




<h3 id="p">段落和換行</h3>


<p>一個段落是由一個以上相連接的行句組成，而一個以上的空行則會切分出不同的段落（空行的定義是顯示上看起來像是空行，便會被視為空行。比方說，若某一行只包含空白和 tab，則該行也會被視為空行），一般的段落不需要用空白或斷行縮排。</p>

<p>「一個以上相連接的行句組成」這句話其實暗示了 Markdown 允許段落內的強迫斷行，這個特性和其他大部分的 text-to-HTML 格式不一樣（包括 MovableType 的「Convert Line Breaks」選項），其它的格式會把每個斷行都轉成 <code>&lt;br /&gt;</code> 標籤。</p>

<p>如果你<em>真的</em>想要插入 <code>&lt;br /&gt;</code> 標籤的話，在行尾加上兩個以上的空白，然後按 enter。</p>

<p>是的，這確實需要花比較多功夫來插入 <code>&lt;br /&gt;</code> ，但是「每個換行都轉換為 <code>&lt;br /&gt;</code>」的方法在 Markdown 中並不適合， Markdown 中 email 式的 <a href="#blockquote">區塊引言</a> 和多段落的 <a href="#list">清單</a> 在使用換行來排版的時候，不但更好用，還更好閱讀。</p>

<h3 id="header">標題</h3>


<p>Markdown 支援兩種標題的語法，<a href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a> 和 <a href="http://www.aaronsw.com/2002/atx/">atx</a> 形式。</p>

<p>Setext 形式是用底線的形式，利用 <code>=</code> （最高階標題）和 <code>-</code> （第二階標題），例如：</p>

<pre><code>This is an H1
=============

This is an H2
-------------
</code></pre>

<p>任何數量的 <code>=</code> 和 <code>-</code> 都可以有效果。</p>

<p>Atx 形式則是在行首插入 1 到 6 個 <code>#</code> ，對應到標題 1 到 6 階，例如：</p>

<pre><code># This is an H1

## This is an H2

###### This is an H6
</code></pre>

<p>你可以選擇性地「關閉」atx 樣式的標題，這純粹只是美觀用的，若是覺得這樣看起來比較舒適，你就可以在行尾加上 <code>#</code>，而行尾的 <code>#</code> 數量也不用和開頭一樣（行首的井字數量決定標題的階數）：</p>

<pre><code># This is an H1 #

## This is an H2 ##

### This is an H3 ######
</code></pre>

<h3 id="blockquote">Blockquotes</h3>


<p>Markdown 使用 email 形式的區塊引言，如果你很熟悉如何在 email 信件中引言，你就知道怎麼在 Markdown 文件中建立一個區塊引言，那會看起來像是你強迫斷行，然後在每行的最前面加上 <code>&gt;</code> ：</p>

<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&gt; 
&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&gt; id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>Markdown 也允許你只在整個段落的第一行最前面加上 <code>&gt;</code> ：</p>

<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>區塊引言可以有階層（例如：引言內的引言），只要根據層數加上不同數量的 <code>&gt;</code> ：</p>

<pre><code>&gt; This is the first level of quoting.
&gt;
&gt; &gt; This is nested blockquote.
&gt;
&gt; Back to the first level.
</code></pre>

<p>引言的區塊內也可以使用其他的 Markdown 語法，包括標題、清單、程式碼區塊等：</p>

<pre><code>&gt; ## This is a header.
&gt; 
&gt; 1.   This is the first list item.
&gt; 2.   This is the second list item.
&gt; 
&gt; Here's some example code:
&gt; 
&gt;     return shell_exec("echo $input | $markdown_script");
</code></pre>

<p>任何標準的文字編輯器都能簡單地建立 email 樣式的引言，例如 BBEdit ，你可以選取文字後然後從選單中選擇<em>增加引言階層</em>。</p>

<h3 id="list">清單</h3>


<p>Markdown 支援有序清單和無序清單。</p>

<p>無序清單使用星號、加號或是減號作為清單標記：</p>

<pre><code>*   Red
*   Green
*   Blue
</code></pre>

<p>等同於：</p>

<pre><code>+   Red
+   Green
+   Blue
</code></pre>

<p>也等同於：</p>

<pre><code>-   Red
-   Green
-   Blue
</code></pre>

<p>有序清單則使用數字接著一個英文句點：</p>

<pre><code>1.  Bird
2.  McHale
3.  Parish
</code></pre>

<p>很重要的一點是，你在清單標記上使用的數字並不會影響輸出的 HTML 結果，上面的清單所產生的 HTML 標記為：</p>

<pre><code>&lt;ol&gt;
&lt;li&gt;Bird&lt;/li&gt;
&lt;li&gt;McHale&lt;/li&gt;
&lt;li&gt;Parish&lt;/li&gt;
&lt;/ol&gt;
</code></pre>

<p>如果你的清單標記寫成：</p>

<pre><code>1.  Bird
1.  McHale
1.  Parish
</code></pre>

<p>或甚至是：</p>

<pre><code>3. Bird
1. McHale
8. Parish
</code></pre>

<p>你都會得到完全相同的 HTML 輸出。重點在於，你可以讓 Markdown 文件的清單數字和輸出的結果相同，或是你懶一點，你可以完全不用在意數字的正確性。</p>

<p>如果你使用懶惰的寫法，建議第一個項目最好還是從 1. 開始，因為 Markdown 未來可能會支援有序清單的 start 屬性。</p>

<p>清單項目標記通常是放在最左邊，但是其實也可以縮排，最多三個空白，項目標記後面則一定要接著至少一個空白或 tab。</p>

<p>要讓清單看起來更漂亮，你可以把內容用固定的縮排整理好：</p>

<pre><code>*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
    viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
    Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>但是如果你很懶，那也不一定需要：</p>

<pre><code>*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>如果清單項目間用空行分開， Markdown 會把項目的內容在輸出時用 <code>&lt;p&gt;</code>
標籤包起來，舉例來說：</p>

<pre><code>*   Bird
*   Magic
</code></pre>

<p>會被轉換為：</p>

<pre><code>&lt;ul&gt;
&lt;li&gt;Bird&lt;/li&gt;
&lt;li&gt;Magic&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>但是這個：</p>

<pre><code>*   Bird

*   Magic
</code></pre>

<p>會被轉換為：</p>

<pre><code>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>清單項目可以包含多個段落，每個項目下的段落都必須縮排 4 個空白或是一個 tab ：</p>

<pre><code>1.  This is a list item with two paragraphs. Lorem ipsum dolor
    sit amet, consectetuer adipiscing elit. Aliquam hendrerit
    mi posuere lectus.

    Vestibulum enim wisi, viverra nec, fringilla in, laoreet
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
    sit amet velit.

2.  Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>如果你每行都有縮排，看起來會看好很多，當然，再次地，如果你很懶惰，Markdown 也允許：</p>

<pre><code>*   This is a list item with two paragraphs.

    This is the second paragraph in the list item. You're
only required to indent the first line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.

*   Another item in the same list.
</code></pre>

<p>如果要在清單項目內放進引言，那 <code>&gt;</code> 就需要縮排：</p>

<pre><code>*   A list item with a blockquote:

    &gt; This is a blockquote
    &gt; inside a list item.
</code></pre>

<p>如果要放程式碼區塊的話，該區塊就需要縮排<em>兩次</em>，也就是 8 個空白或是兩個 tab：</p>

<pre><code>*   A list item with a code block:

        &lt;code goes here&gt;
</code></pre>

<p>當然，項目清單很可能會不小心產生，像是下面這樣的寫法：</p>

<pre><code>1986. What a great season.
</code></pre>

<p>換句話說，也就是在行首出現<em>數字-句點-空白</em>，要避免這樣的狀況，你可以在句點前面加上反斜線。</p>

<pre><code>1986\. What a great season.
</code></pre>

<h3 id="precode">程式碼區塊</h3>


<p>和程式相關的寫作或是標籤語言原始碼通常會有已經排版好的程式碼區塊，通常這些區塊我們並不希望它以一般段落文件的方式去排版，而是照原來的樣子顯示，Markdown 會用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 標籤來把程式碼區塊包起來。</p>

<p>要在 Markdown 中建立程式碼區塊很簡單，只要簡單地縮排 4 個空白或是 1 個 tab 就可以，例如，下面的輸入：</p>

<pre><code>This is a normal paragraph:

    This is a code block.
</code></pre>

<p>Markdown 會轉換成：</p>

<pre><code>&lt;p&gt;This is a normal paragraph:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This is a code block.
&lt;/code&gt;&lt;/pre&gt;
</code></pre>

<p>這個每行一階的縮排（4 個空白或是 1 個 tab），都會被移除，例如：</p>

<pre><code>Here is an example of AppleScript:

    tell application "Foo"
        beep
    end tell
</code></pre>

<p>會被轉換為：</p>

<pre><code>&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tell application "Foo"
    beep
end tell
&lt;/code&gt;&lt;/pre&gt;
</code></pre>

<p>一個程式碼區塊會一直持續到沒有縮排的那一行（或是文件結尾）。</p>

<p>在程式碼區塊裡面， <code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 會自動轉成 HTML 實體，這樣的方式讓你非常容易使用 Markdown 插入範例用的 HTML 原始碼，只需要複製貼上，再加上縮排就可以了，剩下的 Markdown 都會幫你處理，例如：</p>

<pre><code>    &lt;div class="footer"&gt;
        &amp;copy; 2004 Foo Corporation
    &lt;/div&gt;
</code></pre>

<p>會被轉換為：</p>

<pre><code>&lt;pre&gt;&lt;code&gt;&amp;lt;div class="footer"&amp;gt;
    &amp;amp;copy; 2004 Foo Corporation
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</code></pre>

<p>程式碼區塊中，一般的 Markdown 語法不會被轉換，像是星號便只是星號，這表示你可以很容易地以 Markdown 語法撰寫 Markdown 語法相關的文件。</p>

<h3 id="hr">分隔線</h3>


<p>你可以在一行中用三個或以上的星號、減號、底線來建立一個分隔線，行內不能有其他東西。你也可以在星號中間插入空白。下面每種寫法都可以建立分隔線：</p>

<pre><code>* * *

***

*****

- - -

---------------------------------------
</code></pre>

<hr />

<h2 id="span">區段元素</h2>




<h3 id="link">連結</h3>


<p>Markdown 支援兩種形式的連結語法： <em>行內</em>和<em>參考</em>兩種形式。</p>

<p>不管是哪一種，連結的文字都是用 [方括號] 來標記。</p>

<p>要建立一個行內形式的連結，只要在方塊括號後面馬上接著括號並插入網址連結即可，如果你還想要加上連結的 title 文字，只要在網址後面，用雙引號把 title 文字包起來即可，例如：</p>

<pre><code>This is [an example](http://example.com/ "Title") inline link.

[This link](http://example.net/) has no title attribute.
</code></pre>

<p>會產生：</p>

<pre><code>&lt;p&gt;This is &lt;a href="http://example.com/" title="Title"&gt;
an example&lt;/a&gt; inline link.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://example.net/"&gt;This link&lt;/a&gt; has no
title attribute.&lt;/p&gt;
</code></pre>

<p>如果你是要連結到同樣主機的資源，你可以使用相對路徑：</p>

<pre><code>See my [About](/about/) page for details.   
</code></pre>

<p>參考形式的連結使用另外一個方括號接在連結文字的括號後面，而在第二個方括號裡面要填入用以辨識連結的標籤：</p>

<pre><code>This is [an example][id] reference-style link.
</code></pre>

<p>你也可以選擇性地在兩個方括號中間加上空白：</p>

<pre><code>This is [an example] [id] reference-style link.
</code></pre>

<p>接著，在文件的任意處，你可以把這個標籤的連結內容定義出來：</p>

<pre><code>[id]: http://example.com/  "Optional Title Here"
</code></pre>

<p>連結定義的形式為：</p>

<ul>
<li>方括號，裡面輸入連結的辨識用標籤</li>
<li>接著一個冒號</li>
<li>接著一個以上的空白或 tab</li>
<li>接著連結的網址</li>
<li>選擇性地接著 title 內容，可以用單引號、雙引號或是括弧包著</li>
</ul>


<p>下面這三種連結的定義都是相同：</p>

<pre><code>[foo]: http://example.com/  "Optional Title Here"
[foo]: http://example.com/  'Optional Title Here'
[foo]: http://example.com/  (Optional Title Here)
</code></pre>

<p><strong>請注意：</strong>有一個已知的問題是 Markdown.pl 1.0.1 會忽略單引號包起來的連結 title。</p>

<p>連結網址也可以用方括號包起來：</p>

<pre><code>[id]: &lt;http://example.com/&gt;  "Optional Title Here"
</code></pre>

<p>你也可以把 title 屬性放到下一行，也可以加一些縮排，網址太長的話，這樣會比較好看：</p>

<pre><code>[id]: http://example.com/longish/path/to/resource/here
    "Optional Title Here"
</code></pre>

<p>網址定義只有在產生連結的時候用到，並不會直接出現在文件之中。</p>

<p>連結辨識標籤可以有字母、數字、空白和標點符號，但是並<em>不</em>區分大小寫，因此下面兩個連結是一樣的：</p>

<pre><code>[link text][a]
[link text][A]
</code></pre>

<p><em>預設的連結標籤</em>功能讓你可以省略指定連結標籤，這種情形下，連結標籤和連結文字會視為相同，要用預設連結標籤只要在連結文字後面加上一個空的方括號，如果你要讓 &ldquo;Google&rdquo; 連結到 google.com，你可以簡化成：</p>

<pre><code>[Google][]
</code></pre>

<p>然後定義連結內容：</p>

<pre><code>[Google]: http://google.com/
</code></pre>

<p>由於連結文字可能包含空白，所以這種簡化的標籤內也可以包含多個文字：</p>

<pre><code>Visit [Daring Fireball][] for more information.
</code></pre>

<p>然後接著定義連結：</p>

<pre><code>[Daring Fireball]: http://daringfireball.net/
</code></pre>

<p>連結的定義可以放在文件中的任何一個地方，我比較偏好直接放在連結出現段落的後面，你也可以把它放在文件最後面，就像是註解一樣。</p>

<p>下面是一個參考式連結的範例：</p>

<pre><code>I get 10 times more traffic from [Google] [1] than from
[Yahoo] [2] or [MSN] [3].

  [1]: http://google.com/        "Google"
  [2]: http://search.yahoo.com/  "Yahoo Search"
  [3]: http://search.msn.com/    "MSN Search"
</code></pre>

<p>如果改成用連結名稱的方式寫：</p>

<pre><code>I get 10 times more traffic from [Google][] than from
[Yahoo][] or [MSN][].

  [google]: http://google.com/        "Google"
  [yahoo]:  http://search.yahoo.com/  "Yahoo Search"
  [msn]:    http://search.msn.com/    "MSN Search"
</code></pre>

<p>上面兩種寫法都會產生下面的 HTML。</p>

<pre><code>&lt;p&gt;I get 10 times more traffic from &lt;a href="http://google.com/"
title="Google"&gt;Google&lt;/a&gt; than from
&lt;a href="http://search.yahoo.com/" title="Yahoo Search"&gt;Yahoo&lt;/a&gt;
or &lt;a href="http://search.msn.com/" title="MSN Search"&gt;MSN&lt;/a&gt;.&lt;/p&gt;
</code></pre>

<p>下面是用行內形式寫的同樣一段內容的 Markdown 文件，提供作為比較之用：</p>

<pre><code>I get 10 times more traffic from [Google](http://google.com/ "Google")
than from [Yahoo](http://search.yahoo.com/ "Yahoo Search") or
[MSN](http://search.msn.com/ "MSN Search").
</code></pre>

<p>參考式的連結其實重點不在於它比較好寫，而是它比較好讀，比較一下上面的範例，使用參考式的文章本身只有 81 個字元，但是用行內形式的連結卻會增加到 176 個字元，如果是用純 HTML 格式來寫，會有 234 個字元，在 HTML 格式中，標籤比文字還要多。</p>

<p>使用 Markdown 的參考式連結，可以讓文件更像是瀏覽器最後產生的結果，讓你可以把一些標記相關的資訊移到段落文字之外，你就可以增加連結而不讓文章的閱讀感覺被打斷。</p>

<h3 id="em">強調</h3>


<p>Markdown 使用星號（<code>*</code>）和底線（<code>_</code>）作為標記強調字詞的符號，被 <code>*</code> 或 <code>_</code> 包圍的字詞會被轉成用 <code>&lt;em&gt;</code> 標籤包圍，用兩個 <code>*</code> 或 <code>_</code> 包起來的話，則會被轉成 <code>&lt;strong&gt;</code>，例如：</p>

<pre><code>*single asterisks*

_single underscores_

**double asterisks**

__double underscores__
</code></pre>

<p>會轉成：</p>

<pre><code>&lt;em&gt;single asterisks&lt;/em&gt;

&lt;em&gt;single underscores&lt;/em&gt;

&lt;strong&gt;double asterisks&lt;/strong&gt;

&lt;strong&gt;double underscores&lt;/strong&gt;
</code></pre>

<p>你可以隨便用你喜歡的樣式，唯一的限制是，你用什麼符號開啟標籤，就要用什麼符號結束。</p>

<p>強調也可以直接插在文字中間：</p>

<pre><code>un*frigging*believable
</code></pre>

<p>但是如果你的 <code>*</code> 和 <code>_</code> 兩邊都有空白的話，它們就只會被當成普通的符號。</p>

<p>如果要在文字前後直接插入普通的星號或底線，你可以用反斜線：</p>

<pre><code>\*this text is surrounded by literal asterisks\*
</code></pre>

<h3 id="code">程式碼</h3>


<p>如果要標記一小段行內程式碼，你可以用反引號把它包起來（<code>`</code>），例如：</p>

<pre><code>Use the `printf()` function.
</code></pre>

<p>會產生：</p>

<pre><code>&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt;
</code></pre>

<p>如果要在程式碼區段內插入反引號，你可以用多個反引號來開啟和結束程式碼區段：</p>

<pre><code>``There is a literal backtick (`) here.``
</code></pre>

<p>這段語法會產生：</p>

<pre><code>&lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt;
</code></pre>

<p>程式碼區段的起始和結束端都可以放入一個空白，起始端後面一個，結束端前面一個，這樣你就可以在區段的一開始就插入反引號：</p>

<pre><code>A single backtick in a code span: `` ` ``

A backtick-delimited string in a code span: `` `foo` ``
</code></pre>

<p>會產生：</p>

<pre><code>&lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;
</code></pre>

<p>在程式碼區段內，<code>&amp;</code> 和方括號都會被轉成 HTML 實體，這樣會比較容易插入 HTML 原始碼，Markdown 會把下面這段：</p>

<pre><code>Please don't use any `&lt;blink&gt;` tags.
</code></pre>

<p>轉為：</p>

<pre><code>&lt;p&gt;Please don't use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;
</code></pre>

<p>你也可以這樣寫：</p>

<pre><code>`&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`.
</code></pre>

<p>以產生：</p>

<pre><code>&lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encoded
equivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt;
</code></pre>

<h3 id="img">圖片</h3>


<p>很明顯地，要在純文字應用中設計一個 「自然」的語法來插入圖片是有一定難度的。</p>

<p>Markdown 使用一種和連結很相似的語法來標記圖片，同樣也允許兩種樣式： <em>行內</em>和<em>參考</em>。</p>

<p>行內圖片的語法看起來像是：</p>

<pre><code>![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg "Optional title")
</code></pre>

<p>詳細敘述如下：</p>

<ul>
<li>一個驚嘆號 <code>!</code></li>
<li>接著一對方括號，裡面放上圖片的替代文字</li>
<li>接著一對普通括號，裡面放上圖片的網址，最後還可以用引號包住並加上
選擇性的 &lsquo;title&rsquo; 文字。</li>
</ul>


<p>參考式的圖片語法則長得像這樣：</p>

<pre><code>![Alt text][id]
</code></pre>

<p>「id」是圖片參考的名稱，圖片參考的定義方式則和連結參考一樣：</p>

<pre><code>[id]: url/to/image  "Optional title attribute"
</code></pre>

<p>到目前為止， Markdown 還沒有辦法指定圖片的寬高，如果你需要的話，你可以使用普通的 <code>&lt;img&gt;</code> 標籤。</p>

<hr />

<h2 id="misc">其它</h2>




<h3 id="autolink">自動連結</h3>


<p>Markdown 支援比較簡短的自動連結形式來處理網址和電子郵件信箱，只要是用方括號包起來， Markdown 就會自動把它轉成連結，連結的文字就和連結位置一樣，例如：</p>

<pre><code>&lt;http://example.com/&gt;
</code></pre>

<p>Markdown 會轉為：</p>

<pre><code>&lt;a href="http://example.com/"&gt;http://example.com/&lt;/a&gt;
</code></pre>

<p>自動的郵件連結也很類似，只是 Markdown 會先做一個編碼轉換的過程，把文字字元轉成 16 進位碼的 HTML 實體，這樣的格式可以混淆一些不好的信箱地址收集機器人，例如：</p>

<pre><code>&lt;address@example.com&gt;
</code></pre>

<p>Markdown 會轉成：</p>

<pre><code>&lt;a href="&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;
&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;
&amp;#109;"&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;
&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;
</code></pre>

<p>在瀏覽器裡面，這段字串會變成一個可以點擊的「address@example.com」連結。</p>

<p>（這種作法雖然可以混淆不少的機器人，但並無法全部擋下來，不過這樣也比什麼都不做好些。無論如何，公開你的信箱終究會引來廣告信件的。）</p>

<h3 id="backslash">跳脫字元</h3>


<p>Markdown 可以利用反斜線來插入一些在語法中有其它意義的符號，例如：如果你想要用星號加在文字旁邊的方式來做出強調效果（但不用 <code>&lt;em&gt;</code> 標籤），你可以在星號的前面加上反斜線：</p>

<pre><code>\*literal asterisks\*
</code></pre>

<p>Markdown 支援在下面這些符號前面加上反斜線來幫助插入普通的符號：</p>

<pre><code>\   反斜線
`   反引號
*   星號
_   底線
{}  大括號
[]  方括號
()  括號
#   井字號
+   加號
-   減號
.   英文句點
!   驚嘆號
</code></pre>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-09-05T22:05:38+08:00" pubdate data-updated="true"></time></div>
	


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/09/05/%E5%BC%80%E5%A7%8B/">
		
			新的开始</a>
	</h2>
	<div class="entry-content">
		<p>这是我的新的github的博客，挖坑，看自己能保持更新多久</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-09-05T16:32:12+08:00" pubdate data-updated="true"></time></div>
	


	
</div></article>

<nav id="pagenavi">
    
    
    <div class="center"><a href="/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2015

    之行

<br>
Powered by Octopress.
</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->






</body>
</html>
