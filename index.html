<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="hello world" />





  <link rel="alternate" href="/atom.xml" title="学海无涯" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="之行的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="学海无涯">
<meta property="og:url" content="http://csbzhixing.github.io/index.html">
<meta property="og:site_name" content="学海无涯">
<meta property="og:description" content="之行的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学海无涯">
<meta name="twitter:description" content="之行的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://csbzhixing.github.io/"/>





  <title> 学海无涯 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">学海无涯</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2017/01/08/持久化学习系列1/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/08/持久化学习系列1/" itemprop="url">
                  持久化学习系列1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-08T16:16:57+08:00">
                2017-01-08
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>SPTPersistentCache</code>是<strong>spotify</strong>开源的一套持久化框架。<code>SPTPersistentCache</code>主要解决<code>NSData</code>存储到文件系统的过程。</p>
<h2 id="亮点"><a href="#亮点" class="headerlink" title="亮点"></a>亮点</h2><ul>
<li>基于LRU</li>
<li>线程安全</li>
<li>可视化工具</li>
<li>类HTTP设计</li>
</ul>
<h2 id="成员分析"><a href="#成员分析" class="headerlink" title="成员分析"></a>成员分析</h2><p>先从Public Api来进行分析</p>
<p><img src="../media/14824843501540.jpg" alt=""></p>
<p><code>SPTPersistentCache</code>是核心，同比为manager的角色。<br><code>SPTPersistentCacheOptions</code>是配置选项，<br><code>SPTPersistentCacheHeader</code>是<code>SPTPersistentCache</code>的一大设计的特色，数据表头<br><code>SPTPersistentCacheRecord</code>为数据单元。<br><code>SPTPersistentCacheResponse</code>为操纵数据的基本单位。</p>
<p>这次分析打算从下往上，先从基本的数据单元开始</p>
<h3 id="SPTPersistentCacheRecord"><a href="#SPTPersistentCacheRecord" class="headerlink" title="SPTPersistentCacheRecord"></a>SPTPersistentCacheRecord</h3><p><code>SPTPersistentCacheRecord</code>中除了data之外还定义三个辅助数据</p>
<ul>
<li>refCount 引用计数</li>
<li>ttl 生存时间</li>
<li>key </li>
</ul>
<p>可以从<code>SPTPersistentCacheRecord</code>看出<code>SPTPersistent</code>依照引用次数和时间来管理缓存对象</p>
<h3 id="SPTPersistentCacheResponse"><a href="#SPTPersistentCacheResponse" class="headerlink" title="SPTPersistentCacheResponse"></a>SPTPersistentCacheResponse</h3><p><code>SPTPersistentCacheResponse</code>是对<code>SPTPersistentCacheRecord</code>的再一层包装。新增了对外属性</p>
<ul>
<li>SPTPersistentCacheResponseCode</li>
<li>NSError</li>
</ul>
<p>从<code>SPTPersistentCacheResponseCode</code>可以看出这一层与读写操作相关了。</p>
<h3 id="SPTPersistentCacheRecord-1"><a href="#SPTPersistentCacheRecord-1" class="headerlink" title="SPTPersistentCacheRecord"></a>SPTPersistentCacheRecord</h3><p><code>SPTPersistentCacheRecord</code>并不是一个类，而是一个结构体。在这里，可以将<code>SPTPersistentCacheRecord</code>与HTTP中的<code>header</code>进行类比。</p>
<p>关键点：crc，flags</p>
<p>crc：<strong>循环冗余校验</strong> 在数据写入前通过计算生成32位整数，拼接在数据后面。在读取的时候进行校验，确认数据是否完整。<code>SPTPersistentCache</code>使用的是<code>CRC-64-ISO</code></p>
<p>flags: 判断数据是否在上次写入的时候没能完成。这个更多是逻辑而不是一个错误。</p>
<h3 id="SPTPersistentCacheOptions"><a href="#SPTPersistentCacheOptions" class="headerlink" title="SPTPersistentCacheOptions"></a>SPTPersistentCacheOptions</h3><p><code>SPTPersistentCacheOptions</code>是cache的配置相关的内容。从配置中够可以看出<code>SPTPersistentCache</code>的一些特性</p>
<p><code>identifierForQueue</code>作为唯一队列标识，可以预知每一个cache拥有唯一的队列</p>
<p><code>cacheIdentifier</code>作为配置对应的cache唯一标识</p>
<p>优先级设定中分别定义了并发操作数，读写删的优先级</p>
<pre><code class="objc">@property (nonatomic) NSInteger maxConcurrentOperations;
@property (nonatomic) NSOperationQueuePriority writePriority;
@property (nonatomic) NSOperationQueuePriority readPriority;
@property (nonatomic) NSOperationQueuePriority deletePriority;
@property (nonatomic) NSQualityOfService writeQualityOfService;
@property (nonatomic) NSQualityOfService readQualityOfService;
@property (nonatomic) NSQualityOfService deleteQualityOfService;
</code></pre>
<p>GC设定中对GC的配置进行设定</p>
<p><code>garbageCollectionInterval</code>决定了GC的间隔</p>
<p><code>defaultExpirationPeriod</code> 决定默认过期时间</p>
<p><code>sizeConstraintBytes</code> 设定了缓存空间的限制</p>
<p><code>garbageCollectionPriority</code>设定GC操作的优先级</p>
<p><code>garbageCollectionQualityOfService</code>设定GC服务的QOS</p>
<p>从option中可以窥探出，在开发过程中可能会有多个cache，每个cache之间的配置独立，拥有独立的优先级和GC管理</p>
<h3 id="SPTPersistentCache"><a href="#SPTPersistentCache" class="headerlink" title="SPTPersistentCache"></a>SPTPersistentCache</h3><p><code>SPTPersistentCache</code>是整个持久化库的核心类，包含了读，写，查，删，锁等操作</p>
<p>读操作中，对外公开的两个API最后会归集到下面这个方法中</p>
<pre><code class="objc">- (void)loadDataForKeySync:(NSString *)key
              withCallback:(SPTPersistentCacheResponseCallback)callback
                   onQueue:(dispatch_queue_t)queue
</code></pre>
<p>方法并不是很复杂，具体的流程简单描述如下</p>
<pre><code>首先，根据key去查找是否有对应的文件，木有的话就抛错 (1)

如果找到了文件，读取data，如果读取失败，认为文件损坏了，抛错(2)

从文件中读出了数据，根据headerSize取出head。如果不能正确的拼装出header，即认为此文件无法继续操作，抛错(3)

拼装了header后，进行校验，校验不通过，抛错(4)

与本地header做比较，如果不一致，抛错(5)

将读出的payload(负载数据)组装成`SPTPersistentCacheRecord`，再将`SPTPersistentCacheRecord`组装成`SPTPersistentCacheResponse`

将访问数据相关写回磁盘

将response通过block回调给开发者。
</code></pre><p>可以看到，总共有5步抛错的地方，都是对数据完整性的校验。</p>
<p>相对于读，写的难度就小了很多，不太复杂。写方法主要是在</p>
<pre><code class="objc">- (NSError *)storeDataSync:(NSData *)data
                    forKey:(NSString *)key
                       ttl:(NSUInteger)ttl
                    locked:(BOOL)isLocked
              withCallback:(SPTPersistentCacheResponseCallback)callback
                   onQueue:(dispatch_queue_t)queue
</code></pre>
<p>将Header与data拼装后组成rowData，然后写入磁盘，注意判断是否写入成功。之后通过block将response回调给开发者</p>
<h2 id="GC和LRU实现"><a href="#GC和LRU实现" class="headerlink" title="GC和LRU实现"></a>GC和LRU实现</h2><p><strong>LRU是Least Recently Used 近期最少使用算法。</strong></p>
<p>在最近的面试中，经常会谈到一些缓存库的实现，比如最常见的<code>SDWebImageCache</code>。对此我常会提出一个疑问，如何设计高效的缓存。几乎没人能够谈谈缓存调度算法。LRU其实就是最常用的一种缓存调度算法，目的就是尽力保证缓存中的数据是常用的。</p>
<p>这里谈谈<code>SPTPersistentCache</code>中是如何实现GC和LRU算法的。</p>
<p>在上文<code>SPTPersistentCacheRecord</code>的简介中，我们看到了两个关键的属性：TTL &amp;&amp; refcount。我们可以猜测到，<code>SPTPersistentCache</code>是通过实践和引用值来判断是数据的有效性的。</p>
<p>GC的核心是👇这个方法</p>
<pre><code class="objc">- (void)collectGarbageForceExpire:(BOOL)forceExpire forceLocked:(BOOL)forceLocked
</code></pre>
<p>传参分别是强制过期和强制加锁。</p>
<p>过程不复杂，通过<code>NSDirectoryEnumerator</code>迭代器从<code>self.fileManager</code>中取出所有文件。</p>
<p>判断是否过期是通过下面这个方法</p>
<pre><code class="objc">- (SPTPersistentCacheResponse *)alterHeaderForFileAtPath:(NSString *)filePath
                                               withBlock:(SPTPersistentCacheRecordHeaderGetCallbackType)modifyBlock
                                               writeBack:(BOOL)needWriteBack
                                                complain:(BOOL)needComplains
</code></pre>
<p>这个方法是唯一去访问文件header的方法。</p>
<p>传入<code>modifyBlock</code>将改变header。</p>
<p>回到GC的过程中，可以看到通过传入<code>modifyBlock</code>来获取header。在<code>modifyBlock</code>中，通过header中的refcount来判断是否需要移除。</p>
<p>那么什么情况会触发<code>refcount</code>的变化呢？</p>
<p>在<code>lockDataForKeys</code>方法中，可以看到这样一行代码</p>
<pre><code class="objc"> // Satisfy Req.#1.2
 if ([self isDataExpiredWithHeader:header]) {
 expired = YES;
 return;                                                                        }
++header-&gt;refCount;
// Do not update access time since file is locked
</code></pre>
<p>可知，当执行lock的时候，如果数据本身没过期，会使引用计数+1。</p>
<p>同理，当unlock的时候，会使引用计数-1。</p>
<p>可见，refcount只有1和0两个值。</p>
<p>而<code>TTL（存活时间）</code>则是数据的的生命周期。如果没有<code>forceExpire</code>和<code>forceLocked</code>的话，则当<code>[self isDataExpiredWithHeader:header] &amp;&amp; header-&gt;refCount == 0</code>的时候删除数据。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>github上实现二进制缓存的cache库不多，<code>SPTPersistentCache</code>是其中的佼佼者。原因在于<strong>spotify</strong>本身做在线音乐服务，在二进制缓存上有比较强的需求。</p>
<p><code>SPTPersistentCache</code>的实现我认为参考了HTTP协议，通过一个Header来为数据添加metedata，同时实现了GC。可以<code>SPTPersistentCache</code>的实现方式非常值得学习，在阅读<code>SPTPersistentCache</code>的过程中学习了不少二进制文件操作的方法，收益良多，也为这个系列开了一个好头。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2016/12/31/2016，注定不平凡/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/31/2016，注定不平凡/" itemprop="url">
                  2016，注定不平凡
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-31T09:50:41+08:00">
                2016-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2016年，注定是一个不一样的年份。年头到年尾，世界上发生了太多历史性的进程。一个英国脱欧，一个特朗普当选就足以让世人谈论上许多年。对于我个人，也是一个不同寻常的年份：今年我毕业了。</p>
<h3 id="毕业了，我想谈谈教育"><a href="#毕业了，我想谈谈教育" class="headerlink" title="毕业了，我想谈谈教育"></a>毕业了，我想谈谈教育</h3><p>从上学第一天开始，我就想什么时候会结束这一段历程，想不到到来后却一点感觉没有。结束了学生身份，最大的感触就是：不再会有人照顾你了。</p>
<p>16年的求学经历，改变了一个人多少，每个人都会有自己的看法。在我看来，学生时代养成的习惯是永远改不掉的。很幸运的是，自己能够从小学一路顺利得读完大学。相比较许多无缘能够进入学校学习的人来说，能够接受完整系统的知识教育，是一件太幸福的事情。</p>
<p>在经历了完整的中国教育系统设计的教育体系后，感觉并没有网络以及他人所说的那么不堪。的确，中国某些体系原因造成了教育系统多变的情况，我也是几乎踏准了每次教育改革的门槛。但是我并不认为，这些改革最后改变了什么，甚至我不认为教授的内容会对人有什么影响。到目前为止，我认为，学校教育带给我最大的好处，就是学会系统逻辑的思考以及自学能力。</p>
<p>大多人批判中国教育为填鸭式教育。其实，在我看来，这只是一种迫不得已的手段。只有在严酷的训练下，才有悟的可能。绝不同于网络小说的主人公，我们不会在一天突然灵光一闪然后打通了任督二脉因此学贯中西。我们只能在不停地残酷的训练中总结，直到有一天明白知识的相通性。很遗憾的是，太多人麻木在重复高强度的训练中，只有少数人能够参透。我也是在大学最后，才明白过来，为时已晚。</p>
<p>教育，最大的目的是授人以渔。学会学习才是学习最大的目的。</p>
<h3 id="读书，不是为了考试"><a href="#读书，不是为了考试" class="headerlink" title="读书，不是为了考试"></a>读书，不是为了考试</h3><p>上了大学后，除了少数的专业书籍，几乎怎么看书了。就这样浑浑噩噩过了两年，不仅专业并没有多大的提升，眼界和思维也是停滞不前。所幸的是这两年又捡回了读书的习惯。如果只依靠考试来鞭笞自己读书，恐怕也无法在未来走的更远吧。</p>
<p>在这里简单列下书单，也算推荐一些书籍</p>
<ul>
<li><a href="https://book.douban.com/subject/3369600/" target="_blank" rel="external">当我谈跑步时我谈些什么</a> 春上春树记录自己的跑步中一些随想。看到其中一些想法和自己跑步中想法有相似之处。</li>
<li><a href="https://book.douban.com/subject/26835090/" target="_blank" rel="external">Soft Skills: The software developer’s life manual</a>代码之外的软技能。程序员不能只埋头技术，还应该抬头看看世界。</li>
<li><a href="https://book.douban.com/subject/3432304/" target="_blank" rel="external">大江东去</a>讲改革开放前期的小说。前两部给我的启发很多。</li>
<li><a href="https://book.douban.com/subject/4239246/" target="_blank" rel="external">市场的力量</a>有点浅，实例不错。</li>
<li><a href="https://book.douban.com/subject/7057936/" target="_blank" rel="external">批判性思维：带你走出思维误区</a>中文翻译有些无法表达完善，但内容的确详实，有能力的推荐看原版</li>
<li><a href="https://book.douban.com/subject/5290524/" target="_blank" rel="external">微革命</a>内容偏水，思考的点不错。</li>
</ul>
<p>16年因为毕业，没能完成自己在年初定下的读书计划。17年不该再有借口。读书，应该是一辈子的事情。</p>
<h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>作为程序员，年终总结怎么能不写技术呢？不过，我不打算在这里写很多技术内容，只想谈谈对编程技术的一些思考。</p>
<p>编程技术，总的来说我认为也属于工程技术的一种，而且是属于门槛较低的部分。君不见满街40天培训Android，iOS，web月薪过万。然而，只有潮退了才知道谁在裸泳。16年的资本寒冬也影响到了炙手可热的互联网产业。一批批创业公司倒下使初级开发严重过剩。一个iOS岗位一周几百上千封简历不是夸张。作为一名刚毕业进入工作岗位的开发，说没有担心那是假的。究竟在几年后如何保持一定的竞争力？这些个一直在思考这些问题。</p>
<p>广义上的信息技术发展已经有几十个年头了，而新概念还在层出不穷。机器学习，AR,VR,大数据等等名字容易让新进行业的人头晕眼花。不能不承认，APP时代已经开始拉下帷幕了，未来究竟在哪，谁也给不出一个准确的答案。跟着行业走的技术也只能跟着行业的兴衰。作为技术，不能只着眼一处，保持学习，才能永远不被拉下。</p>
<h3 id="17年，路在哪里"><a href="#17年，路在哪里" class="headerlink" title="17年，路在哪里"></a>17年，路在哪里</h3><p>絮叨半天，发现自己的行文依旧这么烂（逃。年终总结，不就是应该给未来的自己避免踩上同一个坑吗。17年会怎么样，我不知道。但是我想我应该让自己知道17该怎么样。</p>
<p>读书依旧是不可少的，保持一个月一本的节奏。</p>
<p>技术上，本职上的iOS客户端开发要深挖下去，不能停留在表面的应用了。初次之外，学学数据处理分析相关的技术吧。</p>
<p>锻炼，16年的断断续续的，没能保持一定惯性。锻炼是最考验一个人意志力的行为。17年要保持，只有一个好身体才能应付一切。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2016/12/19/浅谈一点面试体验/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/19/浅谈一点面试体验/" itemprop="url">
                  从面试想到的
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-19T09:50:41+08:00">
                2016-12-19
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="浅谈一点面试体验"><a href="#浅谈一点面试体验" class="headerlink" title="浅谈一点面试体验"></a>浅谈一点面试体验</h1><p>最近部门业务扩展，移动端终于迎来了难得招人的机会。在经历半个月的招聘体验后，感触良多，想总结下这半个月的体验以及一点想法</p>
<h2 id="移动端怎么了"><a href="#移动端怎么了" class="headerlink" title="移动端怎么了"></a>移动端怎么了</h2><p> 在挂出简历了不到一天，邮箱就被上百封简历轰炸了。虽然对今天就业形势有一些耳闻，但是碰到如此情形还是有点惊讶。到昨天，整整收到了600多封iOS简历。iOS开发究竟怎么了？是苹果不行了吗？其实并不是iOS开发不行了，而是移动端的风口过了。在简历中，我看到了形形色色色的项目。从2C的教育，医疗，直播等等，到2B的IM，项目管理等等，这些项目都有一个特点 — 开发时间特别短。几乎没有一个项目是在一个人手里开发超过1年的。同时，几乎每个人手里都有四五个项目，甚至一个刚工作一年的人的简历里就写了四个项目。可见，在过去一两年，移动端开发过热导致许多公司盲目的上项目。其中印象深刻的是，光汽车蓝牙相关的APP就有十几个。不过在汽车上驾驶员使用手机的问题，就说有多少人真的需要一个APP来通过蓝牙控制汽车功能？这些项目往往在功能简单的同时，没有太多的技术难度，仅仅是为了完成公司产品而生成的。在面试的过程中，简单问了些蓝牙协议的实现，几乎100%的面试者都说通过三方实现的。随着投资热潮褪去，这些项目的一批批的死去，自然释放出了许多初级移动端开发(尤其iOS)。移动端并没有死去，而是走向理智，只是在风口上的猪掉了下来。</p>
<h2 id="请不要写精通好吗"><a href="#请不要写精通好吗" class="headerlink" title="请不要写精通好吗"></a>请不要写精通好吗</h2><p> 在筛选简历的时候，看到精通和熟练的次数几乎是一样多。参与竞聘的人员几乎都是1-3年经验。怎么样才可以说对某项技能达到了精通的地步？我认为，至少在对于这项技能，无论理论还是应用都达到了烂熟于心的地步。在开始时，对于简历上写着精通的面试者，我无不抱着探讨的心态去讨论。然而，迄今为止，几乎没有精通OC的面试者能够讲清楚<code>atomic</code> 和 <code>nonatomic</code>的区别，为什么常用<code>nonatomic</code>，为什么用<code>atomic</code>也不能保证安全。至于精通TCP/UPD的，甚至不能准确讲出TCP连接断开的过程。正如有句话：懂的越多，越觉得自己不懂。</p>
<h2 id="不好意思，我没想过"><a href="#不好意思，我没想过" class="headerlink" title="不好意思，我没想过"></a>不好意思，我没想过</h2><p>这恐怕是我听过最多的一句话，也是我听不愿听到一句话。作为一个开发，每天我们都能遇到各种各样的问题。然而遇到了问题，我们是简单的百度一下，还是停下来想想后面的原因？每逢谈到循环引用，几乎都谈到block中的情况。然而如果我直接问道除了block中的情况呢，几乎80%的面试者都懵逼了。我想，如果真正理解了循环引用，不可能只能想到block中这么一种情况。谈到<code>autoreleasepool</code>的理解和用法。除了简单和<code>ARC</code>关联在一起(其实这里不该混淆在一起)，就只会简单的说不知道了。然而，在<code>main.m</code>文件中其实就用了<code>autorealesepool</code></p>
<pre><code>    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
</code></pre><h2 id="请写上你熟悉的，而不是仅仅用过的"><a href="#请写上你熟悉的，而不是仅仅用过的" class="headerlink" title="请写上你熟悉的，而不是仅仅用过的"></a>请写上你熟悉的，而不是仅仅用过的</h2><p>在筛选简历的时候，简历上有一些新意的字眼的确有加分项。比如<code>swift3</code>的开发经历，网络和渲染的优化，熟悉第三方库的实现(<code>YYKit</code>,<code>SDWebImage</code>等等)。然而，当你在简历上体现出来这些东西时候，起码自己要熟悉。仅仅使用swift写了一个demo可不能熟悉swift。swift的特性，比如柯里化，比如enum,structs,class的区别和选型考虑，这些问题如果都没有考虑，仅仅把一个demo从oc转成swift也仅仅在语言层面的转化而已。而优化的部分，起码要搞清楚优化的意义在哪里，为何需要优化，仅仅封装业务相关内容可不是优化。而第三方库理解，不该只是在调调API这样。无论多么优秀的第三方实现都有自己的不足和可以改进的地方。只有自己读了源码，认真去思考，分辨优劣，才能谈得上理解。</p>
<h2 id="请不要说用不到"><a href="#请不要说用不到" class="headerlink" title="请不要说用不到"></a>请不要说用不到</h2><p>这句话最多听到的是在问算法的时候。失望的是，到目前为止，还没有人能答出几道简单的算法和数据结构相关的题目。一个简单的求两个数的最大公约数几乎没有人能给出想法(没错，就是直接说不会)。而归并排序，快排，二分查找更是无人能说出一二。iOS开发真的不需要用到算法和数据结构吗？我想不是的。其实很多劣质的代码往往是对数据结构和算法的不熟悉导致的。记得一个非常常见的例子：新增数据的比对。比如增量上报通讯录，很多人旺旺是做for循环嵌套。然而如果能用到hash表，效率能有量级的提高。虽然如今iOS开发能真的需要自己去手写算法的地方很少，但如果就此不去学习，不说不能更进一步，可能还会产出许多劣质的代码。</p>
<h2 id="基础，离不开的基础"><a href="#基础，离不开的基础" class="headerlink" title="基础，离不开的基础"></a>基础，离不开的基础</h2><p>经过多次面试后，HR反馈给我，说面试者认为我考的内容偏向于“死”的内容，而开放性关于项目的内容很少。笔者在这里阐述下自己的观点。万丈高楼平地起，再牛的人，再好的项目，无不是从一点点基础开始的。离开了扎实的基础，我不认为讲开放性的内容能够说出独特的见解。事实上，我也问过一些开放性的内容，比如渲染的优化，网络优化的点。然而，对view渲染的机制深入的不够以及对网络协议的浅薄见解，影响到了许多人能谈的很少。所以，我在后面的面试，依然会坚持对基础的考核，毕竟，基础扎实了，再去做深入的探索也不会有太大的困难。</p>
<h2 id="三年，还是一"><a href="#三年，还是一" class="headerlink" title="三年，还是一"></a>三年，还是一</h2><p>在前文说到，参与面试的人都是有两三年开发经验，有数个项目经验在身的。然而在我看来，他们仅仅是把一年经验，反复用了三年而已，甚至，我认为其中有些人甚至不如优秀的应届。为何会出现这样的问题，在我看来多数原因在于把自己的眼界困死了。几乎所有人的简历上都写着能够完成一个完整的app。但是在我看来，完成一个完整APP是一个有一年开发经验合格的iOS开发就能做到的。而两三年经验的开发，应该更多去深入细节，串联自己的知识。记得我常问一个问题：iOS中有哪些锁的实现方法？少数人能谈到<code>NSLock</code>，多数人只知道<code>synchronized</code>。我不是很理解三年的开发经历就没想了解过其他的实现吗？况且网上讲解的文章也不少。</p>
<p>吐槽了那么多，实际上也是想鞭笞自己。学无止境，有太多的点需要自己去研究，永远不能满足现有的状况，永远不要让自己待在舒适区，切记切记。</p>
<p>后面可能会总结下在面试中问道的问题。实际上有些问题也是最近在准备的时候学习到了更多的内容，也算为自己的知识体系做了补充。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2016/08/23/ RN--WEEX--JSPATCH/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/23/ RN--WEEX--JSPATCH/" itemprop="url">
                  Weex, React Native, JSPatch
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-23T23:16:32+08:00">
                2016-08-23
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文是做内部分享的时候整理的知识内容，整理了出来。</p>
<h2 id="技术介绍"><a href="#技术介绍" class="headerlink" title="技术介绍"></a>技术介绍</h2><h3 id="Weex"><a href="#Weex" class="headerlink" title="Weex"></a>Weex</h3><p>Weex是阿里手淘开源的一套跨平台开发。核心语法借鉴了vue.js。</p>
<p>Weex是跨平台，可扩展的动态化技术. 你能通过在Weex源码中写<code>&lt;template&gt;</code>, <code>&lt;style&gt;</code> 和 <code>&lt;script&gt;</code>标签，然后把这些标签转换为JS Bundle用于部署, 在服务端以这些JS Bundle响应请求. 当客户端接收到JS Bundle时，它能用被客户端中的JS引擎用于管理Native渲染;API调用和用户交互.</p>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p> <code>&lt;template&gt;</code>是必须的，使用类HTML的形式，内容由多个标签组成，不同标签代表不同的组件。</p>
<p><code>&lt;style&gt;</code>，可选，使用类CSS语法。</p>
<p><code>&lt;script&gt;</code> 可选，使用js描述页面中逻辑和数据，数据定义也在这个部分</p>
<p><code>&lt;template&gt;</code> 中有三种不同的根节点形式</p>
<ol>
<li><code>&lt;container&gt;</code>，普通根节点</li>
<li><code>&lt;scroller&gt;</code>，滚动根节点，适用于全页面滚动</li>
<li><code>&lt;list&gt;</code>，列表根节点，适用于复用元素的列表场景。</li>
</ol>
<p><code>&lt;style&gt;</code> </p>
<p>类似CSS的形式，和标准CSS有一些细微的差别</p>
<p>第一种使用内联的方式，通过style属性直接添加样式。第二种通过<code>class</code>属性与<code>style</code>属性建立对应关系</p>
<pre><code>&lt;template&gt;
  &lt;container&gt;
    &lt;text style=&quot;font-size: 64;&quot;&gt;Alibaba&lt;/text&gt;
    &lt;text class=&quot;large&quot;&gt;Weex Team&lt;/text&gt;
  &lt;/container&gt;
&lt;/template&gt;

&lt;style&gt;
  .large {font-size: 64;}
&lt;/style&gt;``
</code></pre><p><code>&lt;script&gt;</code></p>
<p><code>&lt;script&gt;</code>中代码遵循<code>ES5</code>语法标准</p>
<pre><code>&lt;template&gt;
  &lt;image onclick=&quot;handler&quot; ...&gt;&lt;/image&gt;
&lt;/template&gt;

&lt;script&gt;
  module.exports = {
    methods: {
      handler: function (e) {
        // TODO
      }
    }
  }
&lt;/script&gt;
</code></pre><p>当一个事件函数被调用，它会收到的第一个参数就是事件对象。每个事件对象包含一下属性。</p>
<ol>
<li><code>type</code>,事件名称，如<code>click</code>。</li>
<li><code>target</code>，目标元素</li>
<li><code>timestamp</code>,事件触发的时间戳。</li>
</ol>
<h4 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h4><pre><code>
Weex we 文件 ---------------前端(we源码)
↓ (转换) -------------------前端(构建过程)
JS Bundle -----------------前端(JS Bundle代码)
↓ (部署) -------------------服务器
在服务器上的JS bundle  ------服务器
↓ (编译) ------------------ 客户端(JS引擎)
虚拟 DOM 树 --------------- 客户端(Weex JS Framework)
↓ (渲染) ------------------ 客户端(渲染引擎)
Native视图 ---------------  客户端(渲染引擎)
</code></pre><p>渲染流程</p>
<ol>
<li>虚拟DOM.</li>
<li>构造树结构. 分析虚拟DOM JSON数据以构造渲染树(RT).</li>
<li>添加样式. 为渲染树的各个节点添加样式.</li>
<li>创建视图. 为渲染树各个节点创建Native视图.</li>
<li>绑定事件. 为Native视图绑定事件.</li>
<li>CSS布局. 使用 css-layout 来计算各个视图的布局.</li>
<li>更新视窗(Frame). 采用上一步的计算结果来更新视窗中各个视图的最终布局位置.</li>
<li>最终页面呈现.</li>
</ol>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ol>
<li>刚刚开源，社区活跃度不高，以阿里团队为主</li>
<li>支持的控件比较少（比如button就没有），checkbox，radio也没有</li>
<li>焦点问题</li>
<li>CSS不支持父级继承</li>
<li>文档不完善</li>
</ol>
<h4 id="和React-Native-对比"><a href="#和React-Native-对比" class="headerlink" title="和React Native 对比"></a>和React Native 对比</h4><h5 id="JS引擎："><a href="#JS引擎：" class="headerlink" title="JS引擎："></a>JS引擎：</h5><p>安卓上 weex使用V8， ReactNative使用JSCore</p>
<p>iOS上，都使用了JSCore</p>
<p>原因是，RN为了使用JSCore，将整个JSCore打包进了app的webkit库，所以安卓的包体容量有比较明显的增大。而iOS则自带</p>
<p>weex考虑到在安卓上都需要自己打包，那么就选择了更新的V8引擎，而iOS则继续使用系统自带的JSCore</p>
<h5 id="JS开发框架："><a href="#JS开发框架：" class="headerlink" title="JS开发框架："></a>JS开发框架：</h5><p>weex基于vue.js(2W+ star)。小巧轻量的前端开发框架，组件化，数据绑定，2.0引入virtual dom。</p>
<p>ReactNative使用React(4W+ star)。革命性的前端开发框架，组件化，数据绑定，virtual dom。</p>
<p>这两者，vue更符合web开发的习惯，JSX改变比较大，但是总体而言，熟悉web开发都不是大问题，对于只有移动端开发经验的人可能RN的学习成本稍高。</p>
<h5 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h5><p>布局两者都是基于facebook的代码解析，实现了flexBox的子集</p>
<p>这个代码解析，写起来是爽，但是，对于复杂的页面，会产生比较严重的性能问题.</p>
<p>这里本来分享用了内部项目的图，这里没有放出来。大家可以自己用三套框架去实现同一个页面，用reveal去看下就明白了。</p>
<p>能不能解决这个问题，网上有人提出了改变思路的方式，即不适用前端布局的思维用js去驱动Native绘图，而是用native的思路去用js驱动。不过这样的话，就加大了前端人员的学习成本</p>
<h5 id="Moudle方法调用线程："><a href="#Moudle方法调用线程：" class="headerlink" title="Moudle方法调用线程："></a>Moudle方法调用线程：</h5><p>weex 可以通过注解标注是否在UI线程执行</p>
<p>ReactNative在安卓上是在<code>native_modules</code>线程执行。iOS里面，每一个<code>native_modules</code>可以支持标记，需要重写module的<code>methodQueue</code>方法，就可以获得在<code>main_queue</code>中执行。</p>
<pre><code>//RCTClipboard类的源码
- (dispatch_queue_t)methodQueue
{
  return dispatch_get_main_queue();
}
</code></pre><h5 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h5><p>组件的扩展上，weex和ReactNative具有一样的能力</p>
<p>三方库的接入上，weex对网络，图片，统计等常见的用户可能想自己定制的功能，提供了相应的适配接口，可以由用户方便的定制，ReactNative需要自己修改源码</p>
<p>两者在功能上并无绝对的优劣。在开发催收的过程中，我们发现很多常见的功能RN没有支持，但是我们通过一点点摸索都能自己扩展出来。RN在底层的native代码都是一个个module，可以根据开发需要灵活扩展插拔。基本上能想的出来的都可以自己实现，当然，有些实现起来比较麻烦，因此，对于RN，目前还不太适合做重量级的产品。</p>
<h4 id="weex-or-ReactNative"><a href="#weex-or-ReactNative" class="headerlink" title="weex or ReactNative"></a>weex or ReactNative</h4><p>weex的诞生据说是为了解决ReactNative的一些问题。目前阿里在推动<code>write once run anywhere</code>的方面上是走的最前的。两者对<code>write once run anywhere</code>思考，我认为，是出发重点，终点不同。RN的目的是革命Native端，而weex则是想改变H5在移动端的效果，因此做到了web,iOS,android三平台统一（RN做不到web端）。因此，在开发商，weex甚至可以抛开native的palyground，直接在web上做开发，等到调试差不多了，再到native上做细致的检查。</p>
<p>weex的出生决定了他站在了巨人的肩膀上。一个<code>devTools</code>就足以看到weex团队想做出的改变。</p>
<p>网上有人类比两者是windows和Linux的关系，而我认为应该是mac OS和Linux的关系。</p>
<h2 id="JSPatch"><a href="#JSPatch" class="headerlink" title="JSPatch"></a>JSPatch</h2><h3 id="平台介绍"><a href="#平台介绍" class="headerlink" title="平台介绍"></a>平台介绍</h3><p>基于OC的runtime机制，使用iOS内置的JavaScriptCore.framework作为JS引擎，从JS传递要调用的类名函数名到Objective-C，再使用NSInvocation动态调用对应的OC方法。</p>
<p>优势：</p>
<p>使用JS语言，比之前的使用Lua的<code>WXPatch</code>适用更广泛。</p>
<p>符合Apple规则</p>
<p>引擎小，除去扩展内容，核心只有三个文件</p>
<p>支持block。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>JSPatch之所以能够做到通过JS来调用和修改OC方法的根本原因是OC是动态语言，OC所有的类和方法都的生成和调用都可以通过runtime在运行时进行，因此可以通过类名/方法名反射得到相应的类和方法。</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>调用<code>requir</code>后，就可以直接使用类了，过程就是在JS全局作用域上创建一个同名变量，变量指向一个对象，</p>
<pre><code>var _require = function(clsName) {
  if (!global[clsName]) {
    global[clsName] = {
      __clsName: clsName
    }
  }
  return global[clsName]
}
</code></pre><h4 id="封装JS对象"><a href="#封装JS对象" class="headerlink" title="封装JS对象"></a>封装JS对象</h4><p>由于JS调用没定义的属性或者放发的时候不会转发，而是直接抛出异常。作者最先开始考虑的是在<code>require</code>的时候将类名传入OC，通过runtime将整个类的方法和属性返回给JS，JS对每个方法名都生成一个函数，这个函数的内容就是将通过方法名去调用OC的方法实现。</p>
<p>然而这种方法实现会造成巨大性能问题，因为除了要遍历当前类的方法，还要遍历父类一直到根类所有继承链上的方法，所以在引入几个类以后就造成内存暴涨。作者为了解决这个问题，想出在 OC 执行 JS 脚本前，通过正则把所有方法调用都改成调用 __c() 函数，再执行这个 JS 脚本，做到了类似 OC/Lua/Ruby 等的消息转发机制：</p>
<pre><code>UIView.alloc().init()
-&gt;
UIView.__c(&#39;alloc&#39;)().__c(&#39;init&#39;)()
</code></pre><p>给 JS 对象基类 Object 加上 <strong>c 成员，这样所有对象都可以调用到 </strong>c，根据当前对象类型判断进行不同操作：</p>
<pre><code>Object.defineProperty(Object.prototype, &#39;__c&#39;, {value: function(methodName) {
  if (!this.__obj &amp;&amp; !this.__clsName) return this[methodName].bind(this);
  var self = this
  return function(){
    var args = Array.prototype.slice.call(arguments)
    return _methodFunc(self.__obj, self.__clsName, methodName, args, self.__isSuper)
  }
}})
</code></pre><h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p>是用了JSCore的接口，在启动JSPatch的时候会创建一个<code>JSContext</code>实例，<code>JSContext</code>是JS的执行环境，可以给<code>JSContext</code>添加方法，JS可以直接调用。</p>
<pre><code>JSContext *context = [[JSContext alloc] init];
context[@&quot;hello&quot;] = ^(NSString *msg) {
    NSLog(@&quot;hello %@&quot;, msg);
};
[_context evaluateScript:@&quot;hello(&#39;word&#39;)&quot;];     //output hello word
</code></pre><p>JS 通过调用 JSContext 定义的方法把数据传给 OC，OC 通过返回值传会给 JS。调用这种方法，它的参数/返回值 JavaScriptCore 都会自动转换，OC 里的 NSArray, NSDictionary, NSString, NSNumber, NSBlock 会分别转为JS端的数组/对象/字符串/数字/函数类型。</p>
<h4 id="对象持有转换"><a href="#对象持有转换" class="headerlink" title="对象持有转换"></a>对象持有转换</h4><p>对于一个自定义id对象，JavaScriptCore 会把这个自定义对象的指针传给 JS，这个对象在 JS 无法使用，但在回传给 OC 时 OC 可以找到这个对象。对于这个对象生命周期的管理，按我的理解如果JS有变量引用时，这个 OC 对象引用计数就加1 ，JS 变量的引用释放了就减1，如果 OC 上没别的持有者，这个OC对象的生命周期就跟着 JS 走了，会在 JS 进行垃圾回收时释放。</p>
<p>传给 JS 的变量是这个 OC 对象的指针，这个指针也可以重新传回 OC，要在 JS 调用这个对象的某个实例方法，只需要在函数里把这个对象指针以及它要调用的方法名传回给 OC 就行了。</p>
<p>目前没找到方法判断一个 JS 对象是否表示 OC 指针，这里的解决方法是在 OC 把对象返回给 JS 之前，先把它包装成一个 NSDictionary：</p>
<pre><code>static NSDictionary *_wrapObj(id obj) {
    return @{@&quot;__obj&quot;: obj};
}
</code></pre><p>这样在JS对象里就可以变成这样</p>
<pre><code>{__obj: [OC Object 对象指针]}
</code></pre><h4 id="方法替换"><a href="#方法替换" class="headerlink" title="方法替换"></a>方法替换</h4><p>运用runtime的原理，不展开讲。</p>
<h4 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h4><p>javaScript 语言是单线程的，在 OC 使用 JavaScriptCore 引擎执行 JS 代码时，会对 JS 代码块加锁，保证同个 JSContext 下的 JS 代码都是顺序执行。所以调用 JSPatch 替换的方法，以及在 JSPatch 里调用 OC 方法，都会在这个锁里执行，这导致三个问题：</p>
<ol>
<li>JSPatch替换的方法无法并行执行，如果如果主线程和子线程同时运行了 JSPatch 替换的方法，这些方法的执行都会顺序排队，主线程会等待子线程的方法执行完后再执行，如果子线程方法耗时长，主线程会等很久，卡住主线程。</li>
<li>某种情况下，JavaScriptCore 的锁与 OC 代码上的锁混合时，会产生死锁。</li>
<li>UIWebView 的初始化会与 JavaScriptCore 冲突。若在 JavaScriptCore 的锁里(第一次)初始化 UIWebView 会导致 webview 无法解析页面。</li>
</ol>
<p>死锁的例子</p>
<pre><code>
// oc

@implementation AppDelegate
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 
{
    ClassA* obj = [[ClassA alloc] init];
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        //A线程
        @synchronized(obj) {    //X锁
            sleep(3);
            [obj methodA];   //methodA被JS替换，调用会进JS，请求JSCore的锁
        }
    });

    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        //B线程
        [obj methodA];  //methodA被JS替换，调用会进JS，请求JSCore的锁
    });
}
@end


@implementation ClassA
- (void)methodA
{
}
- (void)methodB
{
    @synchronized(self) {   //X锁
        int a = 0;
    }
}
@end


// js

defineClass(&#39;ClassA&#39;, {
    methodA: function() {
        self.methodB()   //调用到OC，
    },
})
</code></pre><p>为了解决死锁的问题，JSPatch设计了<code>performSelectorInOC</code>方法。</p>
<pre><code>{
    __isPerformInOC:1,
    obj:self.__obj,
    clsName:self.__clsName,
    sel: args[0],
    args: args[1],
    cb: args[2]
}
</code></pre><p>返回obj后，JS调用就结束了。在 OC 可以拿到 JS 函数的返回值，也就拿到了这个对象，然后判断它是否 <code>__isPerformInOC=1</code> 对象，若是就根据对象里的 selector / 参数等信息调用对应的 OC 方法，这时这个 OC 方法的调用是在 <code>JavaScriptCore</code> 的锁之外调用的，我们的目的就达到了。<br>执行 OC 方法后，会去调 {obj} 里的的 cb 函数，把 OC 方法的返回值传给 cb 函数，重新回到 JS 去执行代码。这里会循环判断这些回调函数是否还返回 <code>__isPerformInOC=1</code> 的对象，若是则重复上述流程执行，不是则结束。</p>
<h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><h4 id="传输安全"><a href="#传输安全" class="headerlink" title="传输安全"></a>传输安全</h4><p>JS 脚本可以调用任意 OC 方法，权限非常大，若被中间人攻击替换代码，会造成较大的危害。</p>
<p>解决方案 对称加密，HTTPS，RSA校验</p>
<p>有能力上HTTPS，简单安全用RSA，不推荐对称加密。</p>
<h4 id="执行安全"><a href="#执行安全" class="headerlink" title="执行安全"></a>执行安全</h4><p>下发的 JS 脚本灵活度大，相当于一次小型更新，若未进行充分测试，可能会出现 crash 等情况对 APP 稳定性造成影响。</p>
<p>解决方案：灰度，监控，回退</p>
<p>回退是推荐所有APP都接入，灰度和监控室中大型APP要考虑的</p>
<h4 id="对比RN-weex的优势"><a href="#对比RN-weex的优势" class="headerlink" title="对比RN/weex的优势"></a>对比RN/weex的优势</h4><ol>
<li>小巧。只需引入 JPEngine.h JPEngine.m JSPatch.js 三个小文件，体积小巧，也无需搭建环境。</li>
<li>学习成本低。可以继续沿用原来 OC 的思维写程序，无需学习新一套规则，即刻上手。</li>
<li>限制少。可以说完全没有限制，OC / JS 上玩出花的各种模式都可以照搬使用，不会被某一框架思维和写法限定。所有 OC / JS 库直接使用，无需适配。</li>
</ol>
<p>##个人观点</p>
<h3 id="RN-vs-weex"><a href="#RN-vs-weex" class="headerlink" title="RN vs weex"></a>RN vs weex</h3><h4 id="开发APP"><a href="#开发APP" class="headerlink" title="开发APP"></a>开发APP</h4><p>RN的优势无疑是国际大厂facebook的鼎力支持和开源社区极高的热情。RN的出生的目的已经决定了他未来的方向：替代Native开发。RN的基础架构设计让RN具有无线的可能，能用Native做到的，RN都能做到。然而，大而全也意味着前进困难，目前RN仍然未发布1.0版本，facebook自身也仅仅在几个用户量较小的APP上使用。Native端兼容问题和性能问题都还没能很好的解决。因此，使用RN开发，目前仅仅适合量级小，功能简单的APP，同时还需要一定量有Web,native段经验的工程师一同踩坑。</p>
<p>weex是国内大厂阿里的作品，从历史上来看，阿里开源了很多也弃坑了很多，对于weex这个刚开源出来的框架，多数人还是抱着谨慎乐观的态度。从一些公开技术分享上来看，阿里在weex上投入了很多人力，也是因为移动端和web的业务发展导致的。目前weex支持的组件和功能都是非常基础单一的，甚至很多必要的功能都没有实现，社区活跃度不高也导致很多坑可能需要自己慢慢看源码去踩。不过，weex站在RN巨人的肩膀上，丰富的开发工具链，提供了更便捷的调试工具和playGround。目前来看，如果阿里愿意投入更多力量，号召开源社区做贡献，未必不能与RN一较高下。目前来看，weex仅适合用于做非常简单的demo（比如一些套壳H5），还不适合做完整功能的APP。</p>
<h4 id="hot-fix"><a href="#hot-fix" class="headerlink" title="hot fix"></a>hot fix</h4><p>两个框架都适合做热更新，从这方面看，两者没有优劣区别。两者都只能改变已经实现的部分，不能添加或者修改已经存在的方法。</p>
<h3 id="JSPatch-vs-RN-amp-weex"><a href="#JSPatch-vs-RN-amp-weex" class="headerlink" title="JSPatch vs RN&amp;weex"></a>JSPatch vs RN&amp;weex</h3><h4 id="开发APP-1"><a href="#开发APP-1" class="headerlink" title="开发APP"></a>开发APP</h4><p>用JSPatch去开发一个APP有没有，有，但是目前我看到的，只有两个开源的小项目。从作者的观点来看，JSPatch可以用来开发一个单独的模块，但是不适合开发一整个APP。毕竟，JSPatch的思路依然是由native的思维用JS来开发，既然如此，不如直接用OC开发更加直接。但由于OC强大无比的runtime，JSPatch可以用于开发一个全新的页面去替代原本使用Native编写的页面，这一点是RN和weex做不到的。</p>
<h4 id="hot-patch"><a href="#hot-patch" class="headerlink" title="hot patch"></a>hot patch</h4><p>JSPatch的出生就是为了解决iOS发版困难的问题，基于OC的runtime和js的灵活使JSPatch在热修复上比RN/weex强上了一个量级。举两个例子</p>
<p>一：实现一个没有实现的功能。</p>
<p>RN/weex都需要实现一个jsBride，就是在native实现好，用js去调用。这样的方式就无法动态的添加方法，比如我们现在七贷做了个微信分享，砍掉了一个拷贝链接的按钮。用JSPatch就可以很快的加回去，不需要发版本，而如果是用RN开发的，Native原本就没有实现这段代码，那就无能为力了。</p>
<p>二：替换原生的页面</p>
<p>很多项目本身已经使用Native开发一段时间了，接入RN/weex后也只是局部新页面使用。RN可以开发一整个新功能界面，动态更新到app上，但是这个新功能界面怎么打开呢？办法有一个，app内有一套URLRoute的路由机制，并且辅助以云端可控的路由配置表，那么确实可以改变某些位置原本的界面跳转，从而跳转打开全新的RN界面，实现了新RN界面的动态更新，但是JSPatch就不需要URLRoute这套全局跳转的辅助机制帮忙，JSPatch完全有能力更改任何已经由OC写好的代码，随意的改变跳转到新界面，随意的增加新按钮，不改变旧界面就把新界面打开！</p>
<h4 id="内存控制差异"><a href="#内存控制差异" class="headerlink" title="内存控制差异"></a>内存控制差异</h4><p>JSPatch在OC和JC交互的时候，将OC对象，界面，Model直接传给JS的上下文，同时OC对象的引用计数会+1，并随着JS的垃圾回收而对这个OC对象进行额外的控制。JS中无法访问这个OC对象，但可以将OC对象的方法发回给OC环境去操作。</p>
<p>RN在OC与JS交互的时候，是完全不支持传递任何OC对象的，所有能在JS与OC中间传递的，一定是可以被json化，字符化的内容，数字，字典，数组，字符串，所以RN专门有个RCTConvert类去专门处理，json的序列化model化，反序列化反model化。那么RN是如何通过JS去控制一个纯OC的界面View呢?是通过viewTag，JS控制的每一个界面效果，都是传过来一个tag，让native创建，让native修改，native会储存住这些tag到一个hashmap里，这样JS才能够不直接传递OC对象，而是传递一个数字，从而控制OC对象</p>
<blockquote>
<p>二者的实现差异，是会造成一些底层运行差异的，OC与JS对象只传递JSON其实就保证了，JS上下文的内存与OC上下文的内存完全没有互通，各自的内从各自控制，JS是一套垃圾回收机制，而OC是一套引用计数机制。</p>
<p>JSPatch将二者进行了互通，这些互通的对象内存管理则是一套，又有引用计数控制，又有JS的垃圾回收，当JS的垃圾回收，并且iOS的引用计数归0，才会销毁。</p>
<p>这里没有优劣之分，JSPatch在双内存控制机制下，也是可以正常work没有问题的，RN&amp;Weex的这套机制，内存上简单清晰，不过这都是底层实现的问题，上层使用，都是没问题的</p>
</blockquote>
<p>##总结</p>
<p>这里借用JSPatch 作者给出的一个比较。</p>
<table>
<thead>
<tr>
<th>框架</th>
<th>学习成本</th>
<th>接入成本</th>
<th>开发效率</th>
<th>性能体验</th>
<th>热更新能力</th>
</tr>
</thead>
<tbody>
<tr>
<td>RN&amp;Weex</td>
<td>高</td>
<td>高</td>
<td>高，跨平台</td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td>JSPatch</td>
<td>低</td>
<td>低</td>
<td>中，单一iOS</td>
<td>高</td>
<td>很强</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2016/08/19/Method Swizzle 与 AOP/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/19/Method Swizzle 与 AOP/" itemprop="url">
                  Method Swizzle 与 AOP
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-19T23:03:29+08:00">
                2016-08-19
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Method-Swizzle"><a href="#Method-Swizzle" class="headerlink" title="Method Swizzle"></a>Method Swizzle</h2><p><code>Method Swizzle</code>是基于runtime实现“黑魔法”。</p>
<p>写这篇主要是源于上周一次项目bug fix。</p>
<p>项目基于React Native 0.20版本开发，在调用相机拍照后，由于照片自身带有了旋转信息，因此照片在客户看来不是“正的”。</p>
<pre><code>- (void)imagePickerController:(UIImagePickerController *)picker
didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *, id&gt; *)info
{
  NSString *mediaType = info[UIImagePickerControllerMediaType];
  BOOL isMovie = [mediaType isEqualToString:(NSString *)kUTTypeMovie];
  NSString *key = isMovie ? UIImagePickerControllerMediaURL : UIImagePickerControllerReferenceURL;
  NSURL *imageURL = info[key];
  if (imageURL) {
    [self _dismissPicker:picker args:@[imageURL.absoluteString]];
    return;
  }

  // This is a newly taken image, and doesn&#39;t have a URL yet.
  // We need to save it to the image store first.
  UIImage *originalImage = info[UIImagePickerControllerOriginalImage];

  // WARNING: Using ImageStoreManager may cause a memory leak because the
  // image isn&#39;t automatically removed from store once we&#39;re done using it.
  [_bridge.imageStoreManager storeImage:originalImage withBlock:^(NSString *tempImageTag) {
    [self _dismissPicker:picker args:tempImageTag ? @[tempImageTag] : nil];
  }];
}
</code></pre><p>可以看到其实就是需要对<code>originalImage</code>进行方向修正。</p>
<p>然后跟踪了RN的实现，发现他是存在应用的临时变量里面，可是用的是CGImage。意味着我们即使取出来了这个Image，也无法获知这个Image的方向信息。当时第一反应是。。我自己来实现一个选择器。。。不过这个工作量略大，而且可能会造成很多不知原因的坑。晚上洗澡的时候，突然想到可以可以通过Method swizzle的方式去实现。</p>
<p>新建了一个category，在<code>+(void)load</code>方法的替换了<code>imagePickerController</code>方法，测试一下，OK。</p>
<h3 id="什么时候用"><a href="#什么时候用" class="headerlink" title="什么时候用"></a>什么时候用</h3><p><code>Method Swizzle</code>是把锋利的刀，用的好，削铁如泥；用的不好，害人害己。</p>
<p>一般而言，如果能有好的方法解决，不推荐使用<code>Method Swizzle</code>。原因就是难以跟踪问题。如A实现一个方法<code>run</code>。一个开发在<code>A(B)</code>这个category里面替换成了<code>runFast</code>，而另一个开发在<code>A(C)</code>里面替换成了<code>runSlow</code>。那我们调用<code>run</code>方法的时候到底是什么结果？</p>
<h3 id="该怎么用"><a href="#该怎么用" class="headerlink" title="该怎么用"></a>该怎么用</h3><p>替换方法应该是在运行时确定唯一的，如果存在多次不确定的<code>Method Swizzle</code>，我们就无法知道最后获取的IMP来源于来个方法。因此在哪里替换，怎么替换，对于不同类型的方法都不一样。</p>
<h4 id="普通实例方法"><a href="#普通实例方法" class="headerlink" title="普通实例方法"></a>普通实例方法</h4><p>替换普通实例方法比较简单，创建了一个对应类的分类，在分类中实现<code>+(void)load</code>方法，在<code>+(void)load</code>方法中进行替换。</p>
<pre><code>+ (void)load {
    Class originalClass = NSClassFromString(@&quot;Car&quot;);
    Class swizzledClass = [self class];
    SEL originalSelector = NSSelectorFromString(@&quot;run:&quot;);
    SEL swizzledSelector = @selector(xxx_run:);
    Method originalMethod = class_getInstanceMethod(originalClass, originalSelector);
    Method swizzledMethod = class_getInstanceMethod(swizzledClass, swizzledSelector);

    IMP originalIMP = method_getImplementation(originalMethod);
    IMP swizzledIMP = method_getImplementation(swizzledMethod);
    const char *originalType = method_getTypeEncoding(originalMethod);
    const char *swizzledType = method_getTypeEncoding(swizzledMethod);

    class_replaceMethod(originalClass,swizzledSelector,originalIMP,originalType);
    class_replaceMethod(originalClass,originalSelector,swizzledIMP,swizzledType);
}
</code></pre><p>首先要知道为何在<code>+(void)load</code>中实现替换。<code>+(void)load</code>这个方法首先是在运行时执行，切只执行一次，因此就符合了我们在<code>在程序运行期只执行一次替换</code>的想法。其次，<code>+(void)load</code>的执行顺序是<code>父类-&gt;子类-&gt;分类</code>的顺序，且不覆盖。因此，分类的<code>+(void)load</code>不会影响类的<code>+(void)load</code>也是我们正需要的。</p>
<h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><p>实现类方法的实现思路也是一样的，不同的是我们不从实例方法列表中去获取相关方法实现</p>
<pre><code>+ (void)load {
    Class cls = [self class];
    SEL originalSelector = @selector(dictionary);
    SEL swizzledSelector = @selector(xxx_dictionary);

    // 使用class_getClassMethod来获取类方法的Method
    Method originalMethod = class_getClassMethod(cls, originalSelector);
    Method swizzledMethod = class_getClassMethod(cls, swizzledSelector);
    if (!originalMethod || !swizzledMethod) {
        return;
    }

    IMP originalIMP = method_getImplementation(originalMethod);
    IMP swizzledIMP = method_getImplementation(swizzledMethod);
    const char *originalType = method_getTypeEncoding(originalMethod);
    const char *swizzledType = method_getTypeEncoding(swizzledMethod);

    // 类方法添加,需要将方法添加到MetaClass中
    Class metaClass = objc_getMetaClass(class_getName(cls));
    class_replaceMethod(metaClass,originalSelector,swizzledIMP,swizzledType);
    class_replaceMethod(metaClass,swizzledSelector,originalIMP,originalType);
}
</code></pre><p>区别有2点</p>
<ol>
<li><code>class_getClassMethod(Class cls, SEL name)</code>替换掉<code>class_getInstanceMethod(Class cls, SEL name)</code>。看得出方法的差异。</li>
<li>实例方法的内容是记录在class的method list上的，而类方法是记录在meta-class 上的。</li>
</ol>
<h4 id="修改类簇"><a href="#修改类簇" class="headerlink" title="修改类簇"></a>修改类簇</h4><pre><code>+ (void)load {
    Class originalClass = NSClassFromString(@&quot;__NSDictionaryM&quot;);
    Class swizzledClass = [self class];
    SEL originalSelector = @selector(setObject:forKey:);
    SEL swizzledSelector = @selector(safe_setObject:forKey:);
    Method originalMethod = class_getInstanceMethod(originalClass, originalSelector);
    Method swizzledMethod = class_getInstanceMethod(swizzledClass, swizzledSelector);

    IMP originalIMP = method_getImplementation(originalMethod);
    IMP swizzledIMP = method_getImplementation(swizzledMethod);
    const char *originalType = method_getTypeEncoding(originalMethod);
    const char *swizzledType = method_getTypeEncoding(swizzledMethod);

    class_replaceMethod(originalClass,swizzledSelector,originalIMP,originalType);
    class_replaceMethod(originalClass,originalSelector,swizzledIMP,swizzledType);
}

- (void)safe_setObject:(id)anObject forKey:(id&lt;NSCopying&gt;)aKey {
    if (anObject &amp;&amp; aKey) {
        [self safe_setObject:anObject forKey:aKey];
    }
    else if (aKey) {
        [(NSMutableDictionary *)self removeObjectForKey:aKey];
    }
}
</code></pre><p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/ClassCluster.html" target="_blank" rel="external">官方文档</a><br>中详细讲解了什么是类簇。这里我们替换的是<code>__NSDictionaryM</code>中对应的<code>setObject:forKey:</code></p>
<h2 id="AOP-和-Method-Swizzle"><a href="#AOP-和-Method-Swizzle" class="headerlink" title="AOP 和 Method Swizzle"></a>AOP 和 Method Swizzle</h2><p>有一定开发经验的人一定听说过AOP。用一句个人觉得比较经典的话来概括<code>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程</code>。这里来看，通过Method Swizzle正好来实现AOP。在这方面，github上有一个实现非常好的开源库<a href="https://github.com/steipete/Aspects" target="_blank" rel="external">Aspects</a></p>
<p>这里的话，会用它来做一下分析，怎么去实现AOP。</p>
<h3 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h3><p><code>Aspects</code>这个库实现了AOP,那么实现到什么地步，能做到什么样的功能，可以从头文件定义中略知一二</p>
<pre><code>typedef NS_OPTIONS(NSUInteger, AspectOptions) {
    AspectPositionAfter   = 0,            /// Called after the original implementation (default)
    AspectPositionInstead = 1,            /// Will replace the original implementation.
    AspectPositionBefore  = 2,            /// Called before the original implementation.

    AspectOptionAutomaticRemoval = 1 &lt;&lt; 3 /// Will remove the hook after the first execution.
};
</code></pre><p>定义了<code>AspectOptions</code>，从名字看出，分别可以做到将新方法插入到老方法之前/之后，替换原有的方法，仅在第一次替换原来的方法。</p>
<pre><code>@protocol AspectToken &lt;NSObject&gt;

/// Deregisters an aspect.
/// @return YES if deregistration is successful, otherwise NO.
- (BOOL)remove;

@end

/// The AspectInfo protocol is the first parameter of our block syntax.
@protocol AspectInfo &lt;NSObject&gt;

/// The instance that is currently hooked.
- (id)instance;

/// The original invocation of the hooked method.
- (NSInvocation *)originalInvocation;

/// All method arguments, boxed. This is lazily evaluated.
- (NSArray *)arguments;

@end
</code></pre><p>两个协议，实现后可以实现撤销插入/ 获得插入的实例信息，原有方法内容和参数列表。</p>
<pre><code>@interface NSObject (Aspects)

/// Adds a block of code before/instead/after the current `selector` for a specific class.
///
/// @param block Aspects replicates the type signature of the method being hooked.
/// The first parameter will be `id&lt;AspectInfo&gt;`, followed by all parameters of the method.
/// These parameters are optional and will be filled to match the block signature.
/// You can even use an empty block, or one that simple gets `id&lt;AspectInfo&gt;`.
///
/// @note Hooking static methods is not supported.
/// @return A token which allows to later deregister the aspect.
+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector
                           withOptions:(AspectOptions)options
                            usingBlock:(id)block
                                 error:(NSError **)error;

/// Adds a block of code before/instead/after the current `selector` for a specific instance.
- (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector
                           withOptions:(AspectOptions)options
                            usingBlock:(id)block
                                 error:(NSError **)error;

@end
</code></pre><p>对NSObject定义了一个分类，只要两个方法，分别是对类方法和实例方法的操作。</p>
<p>可以看到，Aspect的实现功能还是很强大的。在提供基本Method swizzle的基础上还实现了对不同插入位置的功能，提供可撤回的替换。</p>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>在自己实现<code>Method Swizzle</code>的时候，我们也会考虑到，如果我需要恢复被替换的方法怎么做？如果我仅仅想在某个方法执行前或执行后执行一个方法呢？比如我需要在所有的<code>viewDidLoad</code>中插入一个log语句，这时候用<code>Method Swizzle</code>显然是不合适，而<code>Aspect</code>能做到的，也是让我们好奇的，来看看具体的实现方法。</p>
<pre><code>+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector
                      withOptions:(AspectOptions)options
                       usingBlock:(id)block
                            error:(NSError **)error {
    return aspect_add((id)self, selector, options, block, error);
}

/// @return A token which allows to later deregister the aspect.
- (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector
                      withOptions:(AspectOptions)options
                       usingBlock:(id)block
                            error:(NSError **)error {
    return aspect_add(self, selector, options, block, error);
}
</code></pre><p>两个公开API进来后都是调用<code>static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error)</code>这个静态方法，区别就是对类方法中替换要在self前用id修饰。</p>
<pre><code>static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) {
    NSCParameterAssert(self);
    NSCParameterAssert(selector);
    NSCParameterAssert(block);

    __block AspectIdentifier *identifier = nil;
    aspect_performLocked(^{
        if (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) {
            AspectsContainer *aspectContainer = aspect_getContainerForObject(self, selector);
            identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error];
            if (identifier) {
                [aspectContainer addAspect:identifier withOptions:options];

                // Modify the class to allow message interception.
                aspect_prepareClassAndHookSelector(self, selector, error);
            }
        }
    });
    return identifier;
}
</code></pre><p>方法中首先定义了一个<code>AspectIdentifier</code>类型的实例变量：</p>
<pre><code>@interface AspectIdentifier : NSObject
+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error;
- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info;
@property (nonatomic, assign) SEL selector;
@property (nonatomic, strong) id block;
@property (nonatomic, strong) NSMethodSignature *blockSignature;
@property (nonatomic, weak) id object;
@property (nonatomic, assign) AspectOptions options;
@end
</code></pre><p>可以看到这个类的定义就是对Aspect定义的。</p>
<p>随后执行<code>aspect_performLocked</code>：</p>
<pre><code>    static void aspect_performLocked(dispatch_block_t block) {
    static OSSpinLock aspect_lock = OS_SPINLOCK_INIT;
    OSSpinLockLock(&amp;aspect_lock);
    block();
    OSSpinLockUnlock(&amp;aspect_lock);
}
</code></pre><p>方法中创建了一个<code>OSSpinLockLock</code>自旋锁，对block执行进行保护。</p>
<blockquote>
<p>自旋锁是在多处理器系统(SMP)上为保护一段关键代码的执行或者关键数据的一种保护机制，是实现synchronization的一种手段。</p>
</blockquote>
<p>传入的block中，首先先执行<code>aspect_isSelectorAllowedAndTrack</code>方法</p>
<p><code>aspect_isSelectorAllowedAndTrack</code>比较长，从字面含义上来讲就是是否允许插入和追踪。</p>
<p>代码就不贴了。。简单说下思路。</p>
<p>我们知道有些方法是无法被替换的，有些hook的方法对插入的位置很敏感(好像很污的感觉)。这个方法就是对这些黑名单进行判断</p>
<p>首先是不能替换的，有<code>release</code>,<code>retain</code>,<code>autorelease</code>,<code>forwardInvocation</code></p>
<p>只能在添加block到hook方法前的：<code>dealloc</code></p>
<p>被hook的类响应SEL的。。。喂你再去检查下好吧</p>
<p>接下来被hook的是不是元类，如果不是的话就可以愉快的返回YES啦。</p>
<p>如果是元类。。稍微麻烦点。梳理一下逻辑如下</p>
<p><code>swizzledClassesDict</code>是一个dictionary，里面存放的已经是以当前类为key，以<code>AspectTracker</code>为value的键值对。<code>AspectTracker</code>定义如下：</p>
<pre><code>@interface AspectTracker : NSObject
- (id)initWithTrackedClass:(Class)trackedClass;
@property (nonatomic, strong) Class trackedClass;
@property (nonatomic, readonly) NSString *trackedClassName;
@property (nonatomic, strong) NSMutableSet *selectorNames;
@property (nonatomic, strong) NSMutableDictionary *selectorNamesToSubclassTrackers;
- (void)addSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName;
- (void)removeSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName;
- (BOOL)subclassHasHookedSelectorName:(NSString *)selectorName;
- (NSSet *)subclassTrackersHookingSelectorName:(NSString *)selectorName;
@end
</code></pre><p>意义如名字一样，实现的是一个跟踪对象。这个对象里面存放了跟踪的类，类的名字，选择器的名称已经子类跟踪对象的选择器。</p>
<p>获得<code>tracker</code>后，判断是否已经hook了子类的相同选择器方法，注意只能在继承链上hook一次相同选择器的方法。</p>
<p>随后递归父类，查看是否在继承链上已经hook过了。</p>
<p>如果上述过程都能顺利进行下来的话，说明可以hook啦，这时候递归父类，将selector添加到tracker里面。</p>
<p>回到上面的<code>aspect_performLocked</code>中，这时候我们得知是能hook啦，这时候根据传进来的<code>self</code>和<code>selector</code>创建一个<code>AspectsContainer</code>。<code>AspectsContainer</code>的定义如下：</p>
<pre><code>@interface AspectsContainer : NSObject
- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;
- (BOOL)removeAspect:(id)aspect;
- (BOOL)hasAspects;
@property (atomic, copy) NSArray *beforeAspects;
@property (atomic, copy) NSArray *insteadAspects;
@property (atomic, copy) NSArray *afterAspects;
@end
</code></pre><p>这里有三个属性，都是array类型，从名字不难看到，存的是hook前，被hook的，hook后的。</p>
<p>创建<code>AspectsContainer</code>之后，对<code>identifier</code>初始化，如果成功初始化，向<code>AspectsContainer</code>添加<code>identifier</code>。</p>
<pre><code>- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)options {
    NSParameterAssert(aspect);
    NSUInteger position = options&amp;AspectPositionFilter;
    switch (position) {
        case AspectPositionBefore:  self.beforeAspects  = [(self.beforeAspects ?:@[]) arrayByAddingObject:aspect]; break;
        case AspectPositionInstead: self.insteadAspects = [(self.insteadAspects?:@[]) arrayByAddingObject:aspect]; break;
        case AspectPositionAfter:   self.afterAspects   = [(self.afterAspects  ?:@[]) arrayByAddingObject:aspect]; break;
    }
}
</code></pre><p>判断option，将<code>AspectIdentifier</code>添加到对应的array</p>
<p>最后，执行<code>aspect_prepareClassAndHookSelector</code></p>
<p><code>aspect_prepareClassAndHookSelector</code>是整个<code>Aspect</code>里面最核心的部分了，前面的行为都是判断是否能hook和做相应的缓存操作，在这里才是真正的执行hook的地方。</p>
<pre><code>static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) {
    NSCParameterAssert(selector);
    Class klass = aspect_hookClass(self, error);
    Method targetMethod = class_getInstanceMethod(klass, selector);
    IMP targetMethodIMP = method_getImplementation(targetMethod);
    if (!aspect_isMsgForwardIMP(targetMethodIMP)) {
        // Make a method alias for the existing method implementation, it not already copied.
        const char *typeEncoding = method_getTypeEncoding(targetMethod);
        SEL aliasSelector = aspect_aliasForSelector(selector);
        if (![klass instancesRespondToSelector:aliasSelector]) {
            __unused BOOL addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);
            NSCAssert(addedAlias, @&quot;Original implementation for %@ is already copied to %@ on %@&quot;, NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), klass);
        }

        // We use forwardInvocation to hook in.
        class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding);
        AspectLog(@&quot;Aspects: Installed hook for -[%@ %@].&quot;, klass, NSStringFromSelector(selector));
    }
}
</code></pre><p>思路和我们自己动手实现<code>Method Swizzle</code>是差不多的，过程也是获取到被hook的class，然后通过<code>selector</code>获取到指定函数指针<code>IMP</code>。然后将传入的方法(block)替换掉<code>IMP</code>。</p>
<p>首先执行的是一个<code>aspect_hookClass</code>方法，返回一个Class对象。</p>
<p>整体的思路如下</p>
<pre><code>Class statedClass = self.class;
    Class baseClass = object_getClass(self);
</code></pre><p>如果对runtime不熟悉的人可能不知道这两者的有什么不同。简单的说，<code>self.class</code>返回的是这个Object<br>所属的类，而<code>object_getClass</code>返回的是这个Object的元类，也就是类对象的类（很绕口）。接下来，就来判断元类是否被修改过（元类的类名被添加了特有的后缀），如果没有修改过，将对象的类进行hook：</p>
<pre><code>static void _aspect_modifySwizzledClasses(void (^block)(NSMutableSet *swizzledClasses)) {
    static NSMutableSet *swizzledClasses;
    static dispatch_once_t pred;
    dispatch_once(&amp;pred, ^{
        swizzledClasses = [NSMutableSet new];
    });
    @synchronized(swizzledClasses) {
        block(swizzledClasses);
    }
}

static Class aspect_swizzleClassInPlace(Class klass) {
    NSCParameterAssert(klass);
    NSString *className = NSStringFromClass(klass);

    _aspect_modifySwizzledClasses(^(NSMutableSet *swizzledClasses) {
        if (![swizzledClasses containsObject:className]) {
            aspect_swizzleForwardInvocation(klass);
            [swizzledClasses addObject:className];
        }
    });
    return klass;
}

static NSString *const AspectsForwardInvocationSelectorName = @&quot;__aspects_forwardInvocation:&quot;;
static void aspect_swizzleForwardInvocation(Class klass) {
    NSCParameterAssert(klass);
    // If there is no method, replace will act like class_addMethod.
    IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, &quot;v@:@&quot;);
    if (originalImplementation) {
        class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, &quot;v@:@&quot;);
    }
    AspectLog(@&quot;Aspects: %@ is now aspect aware.&quot;, NSStringFromClass(klass));
}
</code></pre><p>理解起来不困难，用一个mutableSet存储类名，如果<code>swizzledClasses</code>不在set里面的话，执行<code>aspect_swizzleForwardInvocation</code>。这个方法就是替换<code>forwardInvocation</code>这方法，目的是替换掉<code>forwardInvocation</code>方法转发，采用自定以的<code>__aspects_forwardInvocation</code><br>核心就是下面两句：</p>
<pre><code>IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, &quot;v@:@&quot;);
    if (originalImplementation) {
        class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, &quot;v@:@&quot;);
    }
</code></pre><p><code>__ASPECTS_ARE_BEING_CALLED__</code>是最关键的方法，这个方法就是决定我们要替换的方法如何执行的地方。</p>
<pre><code>static void __ASPECTS_ARE_BEING_CALLED__(__unsafe_unretained NSObject *self, SEL selector, NSInvocation *invocation) {
    NSCParameterAssert(self);
    NSCParameterAssert(invocation);
    SEL originalSelector = invocation.selector;
    SEL aliasSelector = aspect_aliasForSelector(invocation.selector);
    invocation.selector = aliasSelector;
    AspectsContainer *objectContainer = objc_getAssociatedObject(self, aliasSelector);
    AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(self), aliasSelector);
    AspectInfo *info = [[AspectInfo alloc] initWithInstance:self invocation:invocation];
    NSArray *aspectsToRemove = nil;

    // Before hooks.
    aspect_invoke(classContainer.beforeAspects, info);
    aspect_invoke(objectContainer.beforeAspects, info);

    // Instead hooks.
    BOOL respondsToAlias = YES;
    if (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) {
        aspect_invoke(classContainer.insteadAspects, info);
        aspect_invoke(objectContainer.insteadAspects, info);
    }else {
        Class klass = object_getClass(invocation.target);
        do {
            if ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) {
                [invocation invoke];
                break;
            }
        }while (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass)));
    }

    // After hooks.
    aspect_invoke(classContainer.afterAspects, info);
    aspect_invoke(objectContainer.afterAspects, info);

    // If no hooks are installed, call original implementation (usually to throw an exception)
    if (!respondsToAlias) {
        invocation.selector = originalSelector;
        SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName);
        if ([self respondsToSelector:originalForwardInvocationSEL]) {
            ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation);
        }else {
            [self doesNotRecognizeSelector:invocation.selector];
        }
    }

    // Remove any hooks that are queued for deregistration.
    [aspectsToRemove makeObjectsPerformSelector:@selector(remove)];
}
</code></pre><p>这个方法里，实际上替换的就是<code>forwardInvocation:</code>这个runtime方法，自造了一个调用方法。<br>目的就是从原有方法和hook方法去做处理。</p>
<p>过程就是先用临时变量获取<code>invocation</code>的seletor，将<code>invocation</code>的selecor替换成aliasSelector。通过传入的参数构造<code>AspectInfo</code>。取得<code>objectContainer</code>和<code>classContainer</code>（都是<code>AspectsContainer</code>）类型的。调用<code>aspect_invoke</code></p>
<p><code>aspect_invoke</code>是一个宏方法（其实这里也不用写成宏）。</p>
<pre><code>#define aspect_invoke(aspects, info) \
for (AspectIdentifier *aspect in aspects) {\
    [aspect invokeWithInfo:info];\
    if (aspect.options &amp; AspectOptionAutomaticRemoval) { \
        aspectsToRemove = [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \
    } \
}
</code></pre><p>调用了<code>invokeWithInfo</code>判断aspect的option，如果需要一出，就讲他从对应的container中移除。<br><code>invokeWithInfo</code>的方法如下：</p>
<pre><code>- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info {
    NSInvocation *blockInvocation = [NSInvocation invocationWithMethodSignature:self.blockSignature];
    NSInvocation *originalInvocation = info.originalInvocation;
    NSUInteger numberOfArguments = self.blockSignature.numberOfArguments;

    // Be extra paranoid. We already check that on hook registration.
    if (numberOfArguments &gt; originalInvocation.methodSignature.numberOfArguments) {
        AspectLogError(@&quot;Block has too many arguments. Not calling %@&quot;, info);
        return NO;
    }

    // The `self` of the block will be the AspectInfo. Optional.
    if (numberOfArguments &gt; 1) {
        [blockInvocation setArgument:&amp;info atIndex:1];
    }

    void *argBuf = NULL;
    for (NSUInteger idx = 2; idx &lt; numberOfArguments; idx++) {
        const char *type = [originalInvocation.methodSignature getArgumentTypeAtIndex:idx];
        NSUInteger argSize;
        NSGetSizeAndAlignment(type, &amp;argSize, NULL);

        if (!(argBuf = reallocf(argBuf, argSize))) {
            AspectLogError(@&quot;Failed to allocate memory for block invocation.&quot;);
            return NO;
        }

        [originalInvocation getArgument:argBuf atIndex:idx];
        [blockInvocation setArgument:argBuf atIndex:idx];
    }

    [blockInvocation invokeWithTarget:self.block];

    if (argBuf != NULL) {
        free(argBuf);
    }
    return YES;
}
</code></pre><p>这个部分就是从原有方法中取出参数列表赋给block，在这过程总检查是否block不符合原来方法。将<code>self.block</code>设为<code>blockInvocation</code>的target。</p>
<p>回到<code>aspect_hookClass</code>，在上面特殊情况处理之后，就是一般情况，这时候创建动态子类，类名以<code>AspectsSubclassSuffix</code>为指定后缀。<code>aspect_hookedGetClass</code>中替换掉<code>Class</code>方法，使其返回的是<code>statedClass(被hook的类)</code>，这里将动态生成的子类的<code>Class</code>和<code>Meta Class</code>都替换成<code>statedClass</code>，最后将<code>subclass</code>注册进去，最后将<code>subclass</code>设置成<code>self</code>的类。这样就完成了hook的过程，<code>self</code>执行的方法和信息都被我们hook到了。</p>
<p>回到<code>aspect_prepareClassAndHookSelector</code>（感觉从很深的子树回来真的很不容易），接下来我们获得了我们要hook的<code>Method</code>和<code>IMP</code>,我们要判断是否有对应的IMP</p>
<pre><code>static BOOL aspect_isMsgForwardIMP(IMP impl) {
    return impl == _objc_msgForward
#if !defined(__arm64__)
    || impl == (IMP)_objc_msgForward_stret
#endif
    ;
}
</code></pre><p><code>_objc_msgForward_stret</code>和<code>_objc_msgForward</code>的区别在<a href="http://sealiesoftware.com/blog/archive/2008/10/30/objc_explain_objc_msgSend_stret.html" target="_blank" rel="external">这篇文章</a>里面有讲解，简单的引用JSPatch作者的解释</p>
<blockquote>
<p>大多数CPU在执行C函数时会把前几个参数放进寄存器里，对 obj_msgSend 来说前两个参数固定是 self / _cmd，它们会放在寄存器上，在最后执行完后返回值也会保存在寄存器上，取这个寄存器的值就是返回值。普通的返回值(int/pointer)很小，放在寄存器上没问题，但有些 struct 是很大的，寄存器放不下，所以要用另一种方式，在一开始申请一段内存，把指针保存在寄存器上，返回值往这个指针指向的内存写数据，所以寄存器要腾出一个位置放这个指针，self / _cmd 在寄存器的位置就变了。objc_msgSend 不知道 self / _cmd 的位置变了，所以要用另一个方法 objc_msgSend_stret 代替。原理大概就是这样。在 NSMethodSignature 的 debugDescription 上打出了是否 special struct，只能通过这字符串判断。所以最终的处理是，在非 arm64 下，是 special struct 就走 _objc_msgForward_stret，否则走 _objc_msgForward。</p>
</blockquote>
<p>这里如果IMP == _objc_msgForward，说明找不到 class / selector 对应的 IMP，如果能找到的话，我们就可以进行下一步了。</p>
<p>首先要创建一个<code>aliasSelector</code>选择器，用这个选择器去添加<code>targetMethod</code>对应的<code>IMP</code>。这个目的么，自然是保存下来将要被替换方法的实现。</p>
<p>接下来，<code>class_replaceMethod</code>替换掉我们需要hook的方法，使用了<code>aspect_getMsgForwardIMP</code>如下：</p>
<pre><code>static IMP aspect_getMsgForwardIMP(NSObject *self, SEL selector) {
    IMP msgForwardIMP = _objc_msgForward;
#if !defined(__arm64__)
    // As an ugly internal runtime implementation detail in the 32bit runtime, we need to determine of the method we hook returns a struct or anything larger than id.
    // https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/LowLevelABI/000-Introduction/introduction.html
    // https://github.com/ReactiveCocoa/ReactiveCocoa/issues/783
    // http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/IHI0042E_aapcs.pdf (Section 5.4)
    Method method = class_getInstanceMethod(self.class, selector);
    const char *encoding = method_getTypeEncoding(method);
    BOOL methodReturnsStructValue = encoding[0] == _C_STRUCT_B;
    if (methodReturnsStructValue) {
        @try {
            NSUInteger valueSize = 0;
            NSGetSizeAndAlignment(encoding, &amp;valueSize, NULL);

            if (valueSize == 1 || valueSize == 2 || valueSize == 4 || valueSize == 8) {
                methodReturnsStructValue = NO;
            }
        } @catch (__unused NSException *e) {}
    }
    if (methodReturnsStructValue) {
        msgForwardIMP = (IMP)_objc_msgForward_stret;
    }
#endif
    return msgForwardIMP;
}
</code></pre><p>这里对arm64做了特殊处理，原因就是上文提到实现问题，对返回的struct做特殊的处理。</p>
<p>至此，整个hook的过程就结束了，我们已经将需要hook的方法替换成了我们需要的实现。</p>
<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>写完后才发现整个思路虽然很清晰，但是跨越很大，如果去处理这个hook的类和方法需要做许多判断，然后将原有的类和方法的信息保存下来，以便于恢复，最后通过<code>class_replaceMethod</code>的方法替换掉了<code>forwardInvocation:</code>。这样通过实现了最后消息转发过程中hook，执行我们注入的方法了。</p>
<p>至于恢复被hook的方法，思路也很简单了，从cache中获取origin method，替换掉hook方法就行了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Aspect</code>的实现是基于对runtime强大的理解，通过hook<code>forwardInvocation</code>方法，做到了对消息转发的改变，任何对象不能处理的方法最后都会到<code>forwardInvovation</code>中，在这里我们能执行hook的方法和选择执行的时间，也达到了<code>AOP</code>的思想。</p>
<p><code>Method Swizzle</code>也好，<code>Aspect</code>也好，都是依赖对runtime的认识理解，尤其是<code>Aspect</code>，在学习代码的过程也增长了自己对语言的认知和理解。</p>
<p>在此，项目中也用上了<code>JSPatch</code>，试想如果结合<code>Aspect</code>，通过runtime强大的功能，我们几乎能做到任何时间(坏坏的事情不要想哦)。未来如果有很好的用例，也会分享出来。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2016/08/15/用GCD来实现个Timer/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/15/用GCD来实现个Timer/" itemprop="url">
                  用GCD来实现个Timer
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-15T00:04:39+08:00">
                2016-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##少用NSTimer</p>
<p>在iOS中开发中，定时器是经常用到的工具。一般情况下，我们都会去使用<code>NSTimer</code>这个类。然而，这个类一旦使用不当的话，会给我们造成很多无法预见的坑。</p>
<p><code>NSTimer</code>有哪些坑，一个个来数一数</p>
<h3 id="Timer必须作用在一个运行中的runloop"><a href="#Timer必须作用在一个运行中的runloop" class="headerlink" title="Timer必须作用在一个运行中的runloop"></a>Timer必须作用在一个运行中的<code>runloop</code></h3><p>用过<code>NSTimer</code>的都知道，在创建了<code>NSTimer</code>之后，必须将NSTimer加入到runloop中。如果是在主线程的还好，因为主线程默认是有runLoop的（实际上一般很少会在主线程开timer）。如果是在子线程，那么就要手动激活runLoop先，不然就调用时无效的。</p>
<h3 id="操作必须在同一个线程中"><a href="#操作必须在同一个线程中" class="headerlink" title="操作必须在同一个线程中"></a>操作必须在同一个线程中</h3><p>NSTimer的创建与撤销必须在同一个线程操作、performSelector的创建与撤销必须在同一个线程操作</p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>一般用NSTimer最容易出现的问题。首先来分析为什么会出现这个情况。</p>
<p>通常，我们创建一个<code>NSTimer</code>的方法是调用以下的API：</p>
<pre><code>+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;
+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;

- (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)ti target:(id)t selector:(SEL)s userInfo:(nullable id)ui repeats:(BOOL)rep NS_DESIGNATED_INITIALIZER;
</code></pre><p>这个时候，target会被timer持有，引用计数+1。</p>
<p>此时，如果直接销毁target，即使在target的deallco里面调用了[timer invaild]也无用。因为timer和target相关，因此必须提前调用[timer invaild]。这种BUG最常见的的就是一个<code>UIViewController</code>pop的时候，timer没有被invaild，结果<code>UIViewController</code>没有被销毁，导致了内存泄漏。</p>
<blockquote>
<p>This method is the only way to remove a timer from an NSRunLoop object. The NSRunLoop object removes its strong reference to the timer, either just before the invalidate method returns or at some later point.</p>
<p>If it was configured with target and user info objects, the receiver removes its strong references to those objects as well.<br>You must send this message from the thread on which the timer was installed. If you send this message from another thread, the input source associated with the timer may not be removed from its run loop, which could prevent the thread from exiting properly.</p>
</blockquote>
<p>注意到官方文档中提到，runLoop会持有NSTimer的引用，因此除了调用<code>invaild</code>方法外，没有别的方法.</p>
<p>##用GCD代替NSTimer</p>
<p>用过GCD的都说好，可以说把GCD玩的很溜的话，很多异步并行问题都能解决，在这里我们就要去解决NSTimer的坑的问题。这里用三个开源库来抛砖引玉，讲讲不同的实现由什么优缺点。</p>
<p>###RNTimer</p>
<p>这个库很老了，12年后就没有更新了，内容也很简单，只有两个文件，因为代码很少，直接上源码了</p>
<h4 id="源码摘要"><a href="#源码摘要" class="headerlink" title="源码摘要"></a>源码摘要</h4><pre><code class="Objective-C">
@interface RNTimer : NSObject

/**---------------------------------------------------------------------------------------
 @name Creating a Timer
 -----------------------------------------------------------------------------------------
*/

/** Creates and returns a new repeating RNTimer object and starts running it

 After `seconds` seconds have elapsed, the timer fires, executing the block.
 You will generally need to use a weakSelf pointer to avoid a retain loop.
 The timer is attached to the main GCD queue.

 @param seconds The number of seconds between firings of the timer. Must be greater than 0.
 @param block Block to execute. Must be non-nil

 @return A new RNTimer object, configured according to the specified parameters.
*/
+ (RNTimer *)repeatingTimerWithTimeInterval:(NSTimeInterval)seconds block:(dispatch_block_t)block;


/**---------------------------------------------------------------------------------------
 @name Firing a Timer
 -----------------------------------------------------------------------------------------
*/

/** Causes the block to be executed.

 This does not modify the timer. It will still fire on schedule.
*/
- (void)fire;


/**---------------------------------------------------------------------------------------
 @name Stopping a Timer
 -----------------------------------------------------------------------------------------
*/

/** Stops the receiver from ever firing again

 Once invalidated, a timer cannot be reused.

*/


@interface RNTimer ()
@property (nonatomic, readwrite, copy) dispatch_block_t block;
@property (nonatomic, readwrite, assign) dispatch_source_t source;
@end

@implementation RNTimer
@synthesize block = _block;
@synthesize source = _source;

+ (RNTimer *)repeatingTimerWithTimeInterval:(NSTimeInterval)seconds
                                                                            block:(void (^)(void))block {
    NSParameterAssert(seconds);
    NSParameterAssert(block);

    RNTimer *timer = [[self alloc] init];
    timer.block = block;
    timer.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,
                                                                                0, 0,
                                                                                dispatch_get_main_queue());
    uint64_t nsec = (uint64_t)(seconds * NSEC_PER_SEC);
    dispatch_source_set_timer(timer.source,
                                                        dispatch_time(DISPATCH_TIME_NOW, nsec),
                                                        nsec, 0);
    dispatch_source_set_event_handler(timer.source, block);
    dispatch_resume(timer.source);
    return timer;
}

- (void)invalidate {
    if (self.source) {
        dispatch_source_cancel(self.source);
        dispatch_release(self.source);
        self.source = nil;
    }
    self.block = nil;
}

- (void)dealloc {
    [self invalidate];
}

- (void)fire {
    self.block();
}
</code></pre>
<h4 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h4><p>实现很简单，用的是最基本的方法，即创建了一个<code>dispatch_source_t</code>，传入<code>block</code>，然后通过<code>dispatch_source_set_timer</code>将timer添加到<code>dispatch_source</code>，设置事件处理为传入的block,然后执行timer。</p>
<p>提供两个和<code>NSTimer</code>一样的方法，<code>invalidate</code>和<code>fire</code>。<code>fire</code>会立即执行block，但是不会使timer失效，依然会按照预定计划执行。</p>
<p>在API定义上，保持了和<code>NSTimer</code>一样的定义，所以切换起来没有压力。但是简单也以为这功能不完善。</p>
<ol>
<li>无法暂停挂起timer</li>
<li>无法指定线程</li>
<li>无法添加新的任务到timer中</li>
</ol>
<h3 id="MSWeakTimer"><a href="#MSWeakTimer" class="headerlink" title="MSWeakTimer"></a>MSWeakTimer</h3><p><code>MSWeakTimer</code>的API设计成和<code>NSTimer</code>一样，调用的方法也一致，直接使用并没有什么副作用。</p>
<pre><code class="Objective-C">
- (id)initWithTimeInterval:(NSTimeInterval)timeInterval
                                        target:(id)target
                                    selector:(SEL)selector
                                    userInfo:(id)userInfo
                                     repeats:(BOOL)repeats
                         dispatchQueue:(dispatch_queue_t)dispatchQueue;

                         /**
 * Creates an `MSWeakTimer` object and schedules it to start ticking inmediately.
 */
+ (instancetype)scheduledTimerWithTimeInterval:(NSTimeInterval)timeInterval
                                                                                target:(id)target
                                                                            selector:(SEL)selector
                                                                            userInfo:(id)userInfo
                                                                             repeats:(BOOL)repeats
                                                                 dispatchQueue:(dispatch_queue_t)dispatchQueue;

                                                                 /**
 * Starts the timer if it hadn&#39;t been schedule yet.
 * @warning calling this method on an already scheduled timer results in undefined behavior.
 */
- (void)schedule;

/**
 * Sets the amount of time after the scheduled fire date that the timer may fire to the given interval.
 * @discussion Setting a tolerance for a timer allows it to fire later than the scheduled fire date, improving the ability of the system to optimize for increased power savings and responsiveness. The timer may fire at any time between its scheduled fire date and the scheduled fire date plus the tolerance. The timer will not fire before the scheduled fire date. For repeating timers, the next fire date is calculated from the original fire date regardless of tolerance applied at individual fire times, to avoid drift. The default value is zero, which means no additional tolerance is applied. The system reserves the right to apply a small amount of tolerance to certain timers regardless of the value of this property.
 As the user of the timer, you will have the best idea of what an appropriate tolerance for a timer may be. A general rule of thumb, though, is to set the tolerance to at least 10% of the interval, for a repeating timer. Even a small amount of tolerance will have a significant positive impact on the power usage of your application. The system may put a maximum value of the tolerance.
 */
@property (atomic, assign) NSTimeInterval tolerance;

/**
 * Causes the timer to be fired synchronously manually on the queue from which you call this method.
 * You can use this method to fire a repeating timer without interrupting its regular firing schedule.
 * If the timer is non-repeating, it is automatically invalidated after firing, even if its scheduled fire date has not arrived.
 */
- (void)fire;

/**
 * You can call this method on repeatable timers in order to stop it from running and trying
 * to call the delegate method.
 * @note `MSWeakTimer` won&#39;t invoke the `selector` on `target` again after calling this method.
 * You can call this method from any queue, it doesn&#39;t have to be the queue from where you scheduled it.
 * Since it doesn&#39;t retain the delegate, unlike a regular `NSTimer`, your `dealloc` method will actually be called
 * and it&#39;s easier to place the `invalidate` call there, instead of figuring out a safe place to do it.
 */
- (void)invalidate;

- (id)userInfo;
</code></pre>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>先来看初始化方法：</p>
<pre><code>- (id)initWithTimeInterval:(NSTimeInterval)timeInterval
                                        target:(id)target
                                    selector:(SEL)selector
                                    userInfo:(id)userInfo
                                     repeats:(BOOL)repeats
                         dispatchQueue:(dispatch_queue_t)dispatchQueue
{
        NSParameterAssert(target);
        NSParameterAssert(selector);
        NSParameterAssert(dispatchQueue);

        if ((self = [super init]))
        {
                self.timeInterval = timeInterval;
                self.target = target;
                self.selector = selector;
                self.userInfo = userInfo;
                self.repeats = repeats;

                NSString *privateQueueName = [NSString stringWithFormat:@&quot;com.mindsnacks.msweaktimer.%p&quot;, self];
                self.privateSerialQueue = dispatch_queue_create([privateQueueName cStringUsingEncoding:NSASCIIStringEncoding], DISPATCH_QUEUE_SERIAL);
                dispatch_set_target_queue(self.privateSerialQueue, dispatchQueue);

                self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,
                                                                                        0,
                                                                                        0,
                                                                                        self.privateSerialQueue);
        }

        return self;
}
</code></pre><p>将传入的参数复制给当前类的属性，然后初始化<code>privateSerialQueue</code>，<code>privateSerialQueue</code>的名称是<code>privateQueueName</code>，可变参数为当前对象的内存地址。调用<code>dispatch_set_target_queue</code>将传参的<code>dispatchQueue</code>优先级赋给<code>privateSerialQueue</code>。最后，初始化<code>timer</code>。</p>
<p>然后看执行函数</p>
<pre><code>- (void)schedule
{
        [self resetTimerProperties];

        __weak MSWeakTimer *weakSelf = self;

        dispatch_source_set_event_handler(self.timer, ^{
                [weakSelf timerFired];
        });

        dispatch_resume(self.timer);
}
</code></pre><p>首先调用了<code>resetTimerProperties</code></p>
<pre><code>- (void)resetTimerProperties
{
        int64_t intervalInNanoseconds = (int64_t)(self.timeInterval * NSEC_PER_SEC);
        int64_t toleranceInNanoseconds = (int64_t)(self.tolerance * NSEC_PER_SEC);

        dispatch_source_set_timer(self.timer,
                                                            dispatch_time(DISPATCH_TIME_NOW, intervalInNanoseconds),
                                                            (uint64_t)intervalInNanoseconds,
                                                            toleranceInNanoseconds
                                                            );
}
</code></pre><p><code>resetTimerProperties</code>重置<code>timer</code>。</p>
<p><code>intervalInNanoseconds</code>和<code>toleranceInNanoseconds</code></p>
<p>充当<code>interval</code>和<code>leeway</code></p>
<p>在执行完<code>resetTimerProperties</code>后，<code>dispatch_source_set_event_handler</code>一个block到<code>timer</code>，执行<code>timerFired</code>：</p>
<pre><code>- (void)timerFired
{
        // Checking attomatically if the timer has already been invalidated.
        if (OSAtomicAnd32OrigBarrier(1, &amp;_timerFlags.timerIsInvalidated))
        {
                return;
        }

        // We&#39;re not worried about this warning because the selector we&#39;re calling doesn&#39;t return a +1 object.
        #pragma clang diagnostic push
        #pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;
                [self.target performSelector:self.selector withObject:self];
        #pragma clang diagnostic pop

        if (!self.repeats)
        {
                [self invalidate];
        }
}
</code></pre><p>这里<code>OSAtomicAnd32OrigBarrier</code>是个值得关注的函数。</p>
<p><code>OSAtomicAnd32OrigBarrier</code>是一个原子操作的布尔与运算，且带有内存屏障。<code>OSAtomicAnd32OrigBarrier</code>保证了在与操作之前数据结构的存储结构发生改变。</p>
<p>详细的只是可以参考下面这篇文章</p>
<p><a href="">http://southpeak.github.io/blog/2014/10/17/osatomicyuan-zi-cao-zuo/</a></p>
<p>在这里，<code>_timerFlags.timerIsInvalidated</code>与1做与操作，如果返回return 则返回，如果不是，执行.</p>
<p>这里如果不加入<code>invalidate</code>的话，恐怕说不清楚为什么这里要做这个判断</p>
<pre><code>- (void)invalidate
{
        // We check with an atomic operation if it has already been invalidated. Ideally we would synchronize this on the private queue,
        // but since we can&#39;t know the context from which this method will be called, dispatch_sync might cause a deadlock.
        if (!OSAtomicTestAndSetBarrier(7, &amp;_timerFlags.timerIsInvalidated))
        {
                dispatch_source_t timer = self.timer;
                dispatch_async(self.privateSerialQueue, ^{
                        dispatch_source_cancel(timer);
                        ms_release_gcd_object(timer);
                });
        }
}
</code></pre><pre><code>    if (!OSAtomicTestAndSetBarrier(7, &amp;_timerFlags.timerIsInvalidated))
</code></pre><p><code>OSAtomicTestAndSetBarrier</code>和<code>OSAtomicAnd32OrigBarrier</code>正好可以作为一个相对操作。</p>
<p><code>OSAtomicTestAndSetBarrier(7, &amp;_timerFlags.timerIsInvalidated)</code>会指定变量中的一个bit，把它设置为‘1’并返回旧值。如果要指定32bit integer最低位，n应该是7。因此如果第一次调用<code>OSAtomicTestAndSetBarrier</code>的话，返回false同时话将<code>timerIsInvalidated</code>置成1.由于原子操作和内存屏障，这个方法不会和<code>OSAtomicAnd32OrigBarrier</code>一同执行。如果执行到<code>timerFired</code>的时候，<code>OSAtomicAnd32OrigBarrier(1, &amp;_timerFlags.timerIsInvalidated)</code>返回true，就会返回了。通过这个方法保证了在调用<code>invalidate</code>后将timer失效。</p>
<p><code>timerFired</code>如果能执行，则通过<code>performSelector</code>来调用对用的<code>SEL</code></p>
<p>在<code>invalidate</code>中，如果需要释放，需要调用<code>dispatch_async</code>。原因是我们虽然通过原子操作保证了<code>invalidated</code>，但是我们无法确定当前的上下文情况，使用<code>dispatch_async</code>可能会造成死锁。</p>
<p>主流程分析就是如此，<code>MSWeakTimer</code>最值得关注的就是上面讲解决线程同步的方法。</p>
<p><code>MSWeakTimer</code>解决了前面提到的问题中无法添加指定线程（实际上也不是添加到那个线程，而是新开了一个线程）。由于模仿的是<code>NSTimer</code>的API，所以另外两个方法也没有解决。</p>
<h2 id="我的实现-–-ZXGCDTimer"><a href="#我的实现-–-ZXGCDTimer" class="headerlink" title="我的实现 – ZXGCDTimer"></a>我的实现 – ZXGCDTimer</h2><p>在参考了上面的两个开源库后，自己动手撸了一个简单的基于GCD的Timer。基本解决了上面提到了三个问题。</p>
<p>代码地址：<a href="">https://github.com/csbzhixing/ZXGCDTimer</a></p>
<p>思路是，通过<code>ZXGCDTimerManager</code>提供对外操作包括创建，执行，取消，挂起，回复功能。每个timer通过<code>ZXGCDTimer</code>为单位去管理，以<code>timerName</code>去区分不同的timer。支持自定义线程，支持新增Action。</p>
<p>由于是自己处于研究目的写的，可能存在各种问题，也欢迎大家提出批评和指正。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2016/04/07/post/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/07/post/" itemprop="url">
                  一年
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-07T00:03:44+08:00">
                2016-04-07
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>转眼间，我已经实习一年了。
转眼间，要大学毕业了。

</code></pre><p>如果不看日历，不去想时间，似乎和一年前的这个时候也没有什么不同。一样的担心，一样的焦虑。<br>一年前，因为自己陷入了学习的盲区，不知道如何去提升自己，只好想办法找个实习，想说自己找找自己的学习的方向。这么一做，就是一年过去了。</p>
<p>实习的一年，可以说很辛苦，也很充实。辛苦是因为不仅仅要完成自己学习上的东西，还要去完成工作上的事情，这点对我来说的确是不小的挑战。大学的前两年里面，每天白天上上课，晚上搞下作业，然后就可以快乐的玩耍了。然而到了实习，白天的工作就足以让自己心力交瘁，晚上回到学校后还有许多课业要补习。即使如此，我也没有后悔。如果不是实习，我现在可能还在盲目不知道怎么去找工作；如果不是实习，自己可能现在还在纠结自己未来在哪个方向前进；如果不是实习，可能现在还有改不掉的一堆学生气。</p>
<pre><code>时间不会让人成长，只有痛苦可以


</code></pre><p>还记得刚开始实习的时候特别痛苦。用学校那套学习方法进入工作肯定是行不通的。所以开始的一个月，在iOS上并没有什么长进。硬生生的啃了几本书也然并卵。到了第二个月，接触了项目，有了目标，一点点的去实现一个个目标，结合原理，才真正有了一点点突破。</p>
<pre><code>知识永远学不完，钱永远赚不完，找到自己的路就行


</code></pre><p>十月份换了个实习，回到了深圳。一个原因是原来的公司人员变动，自己也觉得平台太小已经没法接触更多的东西了，除此外回到深圳也可以解放自己更多时间来学习。于是乎很幸运的来到了现在的公司。在这里，从头开发了多个APP，接触了React Native。从一个辅助慢慢成为一个独立的开发。这个时候，很多同学已经确定下来了Offer.看着同学一个个比较自己的offer的时候，自己的心态也有点小小的波动。但是，最后，还是决定扎下来。现有的平台对于自己来说是足够的。一方面身边有足够厉害的人能够提携自己，一方面在项目和时间上能够让自己去深入学习和提高。比较1K,2k这点差距，技术积累和做人的学习恐怕才是最重要的。    </p>
<pre><code>一年后


</code></pre><p>虽然前不久才写完新年总结，之后也好久没有更新什么技术文章，这个总结也算另开一个头。已经从毕设中解放的我有更多时间去深入iOS和js了。希望在一年后的今天，能够在两个技术栈上都有不小的成就。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2016/01/02/2016/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/02/2016/" itemprop="url">
                  2016
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-01-02T00:51:17+08:00">
                2016-01-02
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Hello-2016-Goodbye-2015"><a href="#Hello-2016-Goodbye-2015" class="headerlink" title="Hello 2016, Goodbye 2015"></a>Hello 2016, Goodbye 2015</h1><p>转眼就一年过去了。感觉2015过的飞快。过年的时候去阳江好像就再前不久，如今已经是2016年。想起来今天过得特别快，大概是因为自己已经开始工作了吧。</p>
<p>在三月份，也就是大三下学期的时候，发现自己学习进入了一个瓶颈。对待很多技术都感到很好奇，也感觉自己有想法在这个行业做下去，但是却找不到一个方向去深入地学习。于是乎，在妹子的鼓励下，决定找公司去实习，通过对实际商业生产的了解，调整自己的技术学习方向。然而就这么误打误撞地进入了iOS开发。在广州业速的六个月里面，我从一个只是听闻iOS开发和觉得macbook最牛逼的一个乡下人（好吧我承认这个是自嘲）到一个基本熟悉iOS的初级开发。在这过程中，得益于likid的指导和帮助，收获了许多学习上的心得。在之前自己的学习都是浅尝即止，并没有深入到技术的本质，所以导致了自己好像很多东西都知道，但是说起来却又好像什么都不太懂的样子。在学习iOS开发的过程中，也矫正了自己很多不良的习惯。其中是懂了baidu都是呵呵呵，要查资料还是谷歌大法好（好吧其实我学校不能翻墙，怎么去一个不存在的网站搜东西）。然后是github和stackoverflow两个社区了解也算知道了真正学技术应该去啥地方学习T T,原来我之前三年基本都白过了，还好知道的不晚。</p>
<p>在十月的时候，在鹅厂无望后（主要是自己太水），决定回到深圳，来到了现在的这家公司。新公司给我最大的感受就是身边的大神特别多。其中最让我收益一个是charge对我在iOS开发上的指导，一个是春哥对我技术思考上的指导。在新公司里面，我不再把自己仅仅当做一个完成任务就好的实习生，而是更多地去作为一个团队的一份子。在这过程中，解决了之前很多从来都没思考也没有遇到过的问题，慢慢地能够更加独立地解决问题。虽然在新公司，加班的次数比起在广州多了不少，然而并没有让我觉得上班很无聊，似乎看来我还是适合干这行的，哈哈。在12月，新项目决定上React Native，这又给我了一个非常好的学习机会。在一周的时间学习了ES6和React Native的语法，写了几个简陋的组件，也算碰到了门槛。说不定2016年也会接触下安卓和前端开发。作为一个技术人，千万不能把自己限死在一个固定的平台上。掌握了基本的原则和思想，就应该能在所有的平台上都有所作为。学习能力和执行力永远是技术人的核心竞争力。</p>
<p>得益于今年自己的实习有了一些小小的外快和大牛市一波行情。今年买了特别多得东西。从一堆耳机，几部手机，macbook和新台式，音响。虽然买了很多东西，但是基本上没有靠父母出什么钱。在消费观念上，一年里面也是波动了很多，从舍不得花钱，到乱花钱，到有目的的花钱。新一年里面，如果能顺利拿到offer，也要为未来考虑下了。虽然比起别人不用在外面租房省下了不少的开支，但不意味着自己能够乱花钱。希望能够在10年内尽早的完全独立。</p>
<p>2015年，最大的收获就是想明白了，读书和锻炼这两样是绝对地收益终身的事情。于是乎，购入了kindle，买了跑鞋，开始了自己的精神和肉体的锻炼。这一年，读了杂七杂八的很多书，跑了快两百公里，感觉很不错，想在2016能够继续。只有保持健康的身体和清醒地大脑才能保持每天都能快乐地生活。</p>
<p>2016年，是自己大学的最后一年。不出意外的话应该是在实习的过程中国不知不觉的结束自己的大学生涯。对于大学，对我个人而言，收获恐怕不多，唯有明白了自己没有选错自己未来从事的行业。想来，大学也算玩过，开心过，也不枉自己最后任性的青春。即将踏上社会，再也没有借口给自己找退路，只能和一切困难斗争下去。2016，应该是会是个值得纪念的年份。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://p3.pstatp.com/large/ab000310321818ab99.jpg"
               alt="csbzhixing" />
          <p class="site-author-name" itemprop="name">csbzhixing</p>
          <p class="site-description motion-element" itemprop="description">之行的博客</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">29</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/csbzhixing" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/csbzhixing/activities" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">csbzhixing</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.0"></script>



</body>
</html>
