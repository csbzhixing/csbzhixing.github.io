<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="hello world" />





  <link rel="alternate" href="/atom.xml" title="学海无涯" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="之行的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="学海无涯">
<meta property="og:url" content="http://csbzhixing.github.io/page/5/index.html">
<meta property="og:site_name" content="学海无涯">
<meta property="og:description" content="之行的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学海无涯">
<meta name="twitter:description" content="之行的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://csbzhixing.github.io/page/5/"/>





  <title> 学海无涯 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">学海无涯</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2015/09/22/arc/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/22/arc/" itemprop="url">
                  重新认识ARC
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-09-22T17:48:06+08:00">
                2015-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>第一次接触ARC还是在第一次拿到项目的时候。学习OC的时候使用的教材主要是通过MRC来讲解Retain Counting(引用计数)的。后面只是简单的了解了下ARC是编译器在编译的过程中自动去估算对象的生命周期来自动添加retain和realse的。解放了双手，也就没有什么动力去研究了。现在得空了，是时候增强自己的技能树。当前的目标如下</p>
<p>&lt;!--more--&gt;  
</p>
<ol>
<li>增加网络编程的相关知识<ul>
<li>TCP/IP HTTP HTTPS 协议的学习和了解</li>
<li>JSON和XML的解析</li>
<li>iOS自身关于网络请求相关的类和API</li>
<li>第三方库AFNetWorking源码阅读</li>
</ul>
</li>
<li>增加iOS内核方面的知识<ul>
<li>内存基本知识和管理方式</li>
<li>ARC</li>
<li>进程线程</li>
<li>RunTime</li>
</ul>
</li>
</ol>
<p>简单的看是两个大类七个点，但是感觉每一个点都非常多东西。目前暂时把1.1的点给补完了。不过任然需要投入大量的时间去复习。这里打算整合2.1和2.2。</p>
<p>##内存管理<br>学过计算机基础的人对于内存都不陌生，哪怕是没有计算机基础的人也明白内存对于电脑（终端）的重要性。内存管理，就是在程序运行的过程中，申请，使用，释放内存的过程。程序写的好不好，就看你在完成功能的同时是不是使用了尽可能少的内存。</p>
<p><em>堆和栈</em></p>
<p>在内存中，有两个重要的概念，分别是<code>堆和栈</code>。这里不仅仅指代他们的数据结构。我们知道，一个函数执行的时候，他会被压入栈中。栈中的内存单元保存了函数的返回地址，局部变量，传参等数据。当函数被弹出栈的时候，一切数据都会被销毁。而<code>堆</code>上的数据是由开发者自行申请管理的，生命周期由开发者自行掌握。</p>
<p><em>引用计数</em></p>
<p>学过OC的人都知道，在OC中管理内存的方法是<code>引用计数</code>(Retain Counting)。通过对堆和栈的了解，我们可以得出OC上的对象<em>都是在堆上</em>的。</p>
<p>在苹果开发文档里面有一张图很好的说明的通过引用计数来管理对象生命周期的过程。</p>
<p><img src="/media/14429735006902.jpg" alt="引用计数"></p>
<p>同样，引用计数也遵循几大内存管理原则</p>
<ol>
<li>谁申请谁拥有</li>
<li>肯以申请拥有一个存在的对象</li>
<li>当不需要的再拥有对象的时候，申请释放</li>
<li>不能释放不属于自己没有拥有的对象</li>
</ol>
<p>##Automatic Reference Counting (ARC)</p>
<p>在学习iOS开发半年后，ARC给我留下了很深的印象。ARC是苹果在引用计数的基础上改善了编译器实现的功能。要了解ARC，首先要看看在没有ARC之前开发者是怎么去通过引用计数管理的。</p>
<p>在ARC之前，我们统称为<code>MRC（Manual Reference Counting</code>，即手动引用技术。通过调用<code>retain</code>和<code>release</code>来管理对象的生命周期。有了ARC之后，在编译的过程中，编译器可以根据上下文估算对象的生命周期，以此来自动的添加<code>retain</code>和<code>release</code>。</p>
<p>注意，ARC只对OC对象有作用，对于C的类型对象不则按照C的内存管理的方法去管理。</p>
<p>如果在工程中开启了使用ARC，那么就要遵循ARC定义的一些规范</p>
<ol>
<li>不能显示的调用<code>dealloc</code>,<code>ratain</code>,<code>release</code>,<code>retainCount</code>,<code>autoRelease</code>。</li>
<li>如果要复写<code>dealloc</code>方法，不需要显示调用<code>[super dealloc]</code>方法。</li>
<li>不能再使用<code>AutoReleasepool</code></li>
</ol>
<p><em>ARC下的修饰符</em></p>
<p>在@Property 中，有四种修饰符是ARC提供的，他们分别是</p>
<ol>
<li>strong</li>
<li>weak</li>
<li>unsafe_unretained</li>
<li>__autoreleasing</li>
</ol>
<p>其中，重点来谈谈strong和weak</p>
<ul>
<li>strong。我们理解为强引用。当前的对象实际拥有这个对象。默认情况下ARC使用的strong来修饰。</li>
<li>weak。相对于strong的强引用，weak指的是弱引用。当引用的对象被释放掉的时候，当前引用对象会被自动置nil。weak通常被用来解决循环引用的问题。</li>
</ul>
<p><code>__autoreleasing</code>和<code>__unsafe_unretained</code>在实际应用中是很少的。<code>__unsafe_unretained</code>是为了兼容iOS4之前的版本，现在基本上不会使用了，主要是为了实现weak的功能。<code>__autoreleasing</code>是表示在autorelease pool中自动释放对象的引用。</p>
<h2 id="block-在ARC下"><a href="#block-在ARC下" class="headerlink" title="block 在ARC下"></a>block 在ARC下</h2><p>block在之前已经小小的讨论过了，出现的几个问题都有谈论到，这里主要从ARC的角度上再谈一谈。</p>
<p>block在ARC下最特殊的地方就是怎么去解决循环引用。在block的篇章中没有很详细讨论，原因也是没从内存的角度来看。这里详细讲下循环引用产生原因和在ARC下解决循环引用的方法。</p>
<p>&gt;<br>You can use lifetime qualifiers to avoid strong reference cycles. For example, typically if you have a graph of objects arranged in a parent-child hierarchy and parents need to refer to their children and vice versa, then you make the parent-to-child relationship strong and the child-to-parent relationship weak. Other situations may be more subtle, particularly when they involve block objects.<br>&gt;<br>In manual reference counting mode, <strong>block id x; has the effect of not retaining x. In ARC mode, </strong>block id x; defaults to retaining x (just like all other values). To get the manual reference counting mode behavior under ARC, you could use <strong>unsafe_unretained </strong>block id x;. As the name <strong>unsafe_unretained implies, however, having a non-retained variable is dangerous (because it can dangle) and is therefore discouraged. Two better options are to either use </strong>weak (if you don’t need to support iOS 4 or OS X v10.6), or set the __block value to nil to break the retain cycle.<br>&gt;<br>The following code fragment illustrates this issue using a pattern that is sometimes used in manual reference counting.</p>
<p>上面是苹果官方文档对循环引用的解释。通过引用计数，我们了解到，如果有两个对象，对彼此都是强引用的话，双方都无法释放对方，也就无法释放delloc对象，最终就造成了死循环。在iOS5以下的版本里面，我们可以通过手动使用<code>unsafe_unretained</code>来使其中一个变量变成野指针。而在ARC下，我们通过使用weak来修饰其中一个变量，这样在block中就不存在双方强引用的抢矿。</p>
<p>但是，上面的处理方法有个问题。我们不知道weak修饰的对象什么时候会被释放掉了，有可能在执行block里面的对象在之前就已经被释放掉了。在AFNetWorking中，提供了一个非常好的解决思路</p>
<p><img src="/media/14429947239639.jpg" alt=""></p>
<p>上面方法中，在block外先将self用<code>weak</code>引用一个weakSelf，进入block后再使用一个<code>_strong_typeof</code>去创建一个strong引用对象。这样的做法既能避免产生循环引用，也能避免weak对象提前被释放掉。</p>
<p>##ARC与Toll-Free Bridging</p>
<p>Toll-Free Briding保证了在程序中，可以方便和谐的使用Core Foundation类型的对象和Objective-C类型的对象。但是，我们知道，到了ARC的时候，两者的内存管理方法不同了。对于一种对象，我们不能用该两种内存管理方法去管理。所以在进入ARC之后，Toll-Free Bridging也进行了相应的变化。</p>
<p><em>__bridge</em></p>
<p>只是申明了类型转变，并没有改变内存管理方法。</p>
<p><em>__bridge_retained（修饰符） or CFBridgingRetain（函数）</em></p>
<p>表示将指针类型转变的同时，将内存管理的责任由原来的Objective-C交给Core Foundation来处理，也就是，将ARC转变为MRC。</p>
<p><em>__bridge_transfer（修饰符） or CFBridgingRelease（函数）</em></p>
<p>这个修饰符和函数的功能和上面那个__bridge_retained相反，它表示将管理的责任由Core Foundation转交给Objective-C，即将管理方式由MRC转变为ARC。</p>
<p>上面就是要谈的ARC的内容了。其实ARC的坑比起MRC已经少了很多了，对于我们可怜的程序员来说已经是很大的解放了。</p>
<p>这里对于内存管理仅仅是基于OC简单的谈了谈，觉得还是不够深刻，主要是自己在这方面的知识的确很欠缺。读了<br><a href="http://casatwy.com/ccheng-xu-de-nei-cun-guan-li.html" target="_blank" rel="external">C程序的内存管理</a>这篇文章学到了很多，在这里也安利一下。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2015/09/18/title/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/18/title/" itemprop="url">
                  IP TCP HTTPs 随便谈
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-09-18T16:48:55+08:00">
                2015-09-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index">
                    <span itemprop="name">Network</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="IP-TCP-HTTPs-随便谈"><a href="#IP-TCP-HTTPs-随便谈" class="headerlink" title="IP TCP HTTPs 随便谈"></a>IP TCP HTTPs 随便谈</h1><p>在总结自己的技能书的缺点后，决定优先补充自己在计算机网络上知识的漏洞。现在互联网企业，离开了互联网什么都不是。对互联网，普通人可能停留在概念和使用上，而开发人员应该去深入的了解运行进制，进而去优化自己开发的产品。这篇文章，主要是记录自己最近看的一些资料的笔记。<br>&lt;!--more--&gt;  </p>
<p>##IP 协议</p>
<p>IP协议，是网络协议（Internet Protocol）的缩写。IP协议是互联网众多协议的基础。</p>
<p>IP协议实现了解<code>*分组交换网络*</code>。在协议下，每个机器被称为<code>*主机*</code>，IP协议明确了主机之间数据包的传输方式。</p>
<p>数据包，也就是一段二进制数据，包含了传输源的主机的信息。IP协议的特点是<code>*尽力服务*</code>（best effort），提供有效的服务并尽可能的传输。这说明，在传输过程中，可能会丢失数据包，也可能传输了多个相同的数据包。</p>
<p>IP 网络中的主机都配有自己的地址，被称为<code>*IP 地址*</code>。每个数据包中都包含了源主机和目标主机的 IP 地址。IP 协议负责路径计算，即 IP 数据包在网络中的传输传输时，数据包所经过的每一个主机节点都会读取数据包中的目标主机地址信息，以便选择朝什么地方传送数据包。</p>
<p>##蛋疼的IPv4</p>
<p>如今，多数数据包任然使用的是IPv4（版本4），每一个IP地址都是32位的。比如192.168.1.1就是一个IPV4地址。我们可以算下，IPv4有多少个地址。。嗯，好像很多有43亿吗。。但是呢，到了10年的时候，就已经不到8%的了。。</p>
<p>人们发现IPV4不够用啊，快用完了啊，用完了就不能加主机了啊！！！那怎么办，启用新的协议版本啊，所以除了个IPv6，将地址扩充到128位了。比如<code>2001:0db8:85a3:0042:1000:8a2e:0370:7334</code><br>就是一个IPv6的地址了。</p>
<p>128位就是2的128次方个，据说够地球上每个沙子配一个IP了。但是呢，这个协议转换的很慢，目前基本国内的都是还是使用IPv4协议。。看来也不是很着急么。。</p>
<p>##IP数据包的结构<br>一个IP数据包通常包括一个数据头部（header）和有效数据（payload）。有效数据自然是数据包中要传送的数据。而数据头部就是包含了一些传输数据相关的数据。</p>
<p>####我们先来看个IPv4的头部</p>
<p><img src="/media/Screen%20Shot%202015-09-20%20at%2020.15.59.png" alt="Screen Shot 2015-09-20 at 20.15.59"></p>
<p>可以看到，头部信息包含了当前版本的信息，payload采用的协议。Total Length 表明是有效数据加上头部信息长度的总长度。</p>
<p>####在来看看一个IPv6的报头信息</p>
<p><img src="/media/14427519874258.jpg" alt=""></p>
<p>IPv6的头部长度固定到了40.同时IPv6可以链接下一个头部信息（Next Header）。</p>
<p>##数据传输</p>
<p>我们知道，在数据链路层对对所传输的数据帧数有限制，<code>*（MTU，最大传输单元）*</code>。在IPv4的上，使用<code>*分片*</code>来对数据包进行处理。具体来说，我们可以认为如果数据超过了最大传输单元，那么就会将数据切成几片。当数据到达目标主机后，可以根据分片的信息进行重组。当然，发送源可以选择不进行对数据进行<code>*分片*</code>。如果超过了链路层最大传输单元又不进行<code>*分片*</code>的话，发送源就会收到ICMP（Internet Control Message Protocol，Internet报文控制协议）的数据帧超长报告信息。</p>
<p>在IPv6中，如果数据包超过了长度限制，路由会直接丢弃数据包（好狠）并且向ICMP6报告数据帧过长。然后数据源和目标源会根据这个特性来进行<code>路由发现</code>，就是寻找两端之间最大传输单元的路由。找到最大传输单元的路由后，仅当此时数据包任然超过最大传输单元的时候，IPv6才会进行分片。`对于IPv6下的TCP来说，不会造成什么影响。</p>
<hr>
<p>到此，IP协议就到了一个段落了。IP协议是TCP协议的基础，因此了解是必须的。</p>
<p>##TCP协议</p>
<p>TCP协议是重头戏。TCP协议是重头戏。TCP协议是重头戏。重要的事情要说三遍。</p>
<p>上面说了，IP协议是基于<code>尽可能服务</code>的，那么TCP协议就是要基于IP协议，解决IP协议采用的不可靠传输引起的复杂的问题。因此，下面的重点就是来谈谈TCP连接的三个部分：建立连接，传输数据，断开连接的详细过程</p>
<p>####TCP建立连接</p>
<p>首先，我们要知道TCP连接是全双工的,是建立在两个主机之间的。每个连接都存在两种角色：<code>服务器端，监听连接</code>，<code>客户端，主动连接服务器端</code>。客户端主动连接服务器端被称为<code>active open(主动打开)</code>。而服务器端这种监听连接的行为被称为<code>passive open(被动打开)</code>。</p>
<p><strong>三次握手</strong></p>
<p>TCP建立连接是一个确认和反复确认的过程，我们习惯统称为三次握手。这个地方也是几乎所有面试会问的地方，需要注意了。</p>
<p>三次连接，具体的过程有语言描述为以下的过程。</p>
<blockquote>
<ol>
<li>客服端向服务器端发送SYN包和一个随机序列号X，表示本次的连接的身份。</li>
<li>服务器端收到客服端发送的连接的请求以后，发送一个SYN-ACK包和一个确认ack号X+1(确认序列号X的连接请求确认)。此时服务器还会发送一个随机序列号Y，表示向客户端连接的请求。</li>
<li>客户端收到服务器的回复后，会发送一个ACK包，一个确认号Y+1和序列号X+1给服务器。</li>
</ol>
</blockquote>
<p>SYN包，为<code>synchronize sequence numbers (同步序列号)</code>。用于确认两段传输数据的身份，确保数据包最后都达到了应该到的地方。在建立连接的时候，源和目标都需要确认<code>同步序列号</code>。</p>
<p>ACK包，为<code>acknowledgment (确认)</code>。某一端接到数据后，通过回传序列号来确认收到报文。</p>
<p><img src="/media/14428004882999.jpg" alt="三次握手"></p>
<p>####传输数据</p>
<p>建立连接，就是为了传输数据。发送端发出的报文都会带有一个序列号，与当前已传送的字节总数有关。接受端会根据已经接收的报文给发送端传送确认报文，确认信息同样在头部的缩写带的ACK。</p>
<p><img src="/media/14427976037921.jpg" alt=""></p>
<p>注意的整个过程是双向的。两端都会持续的发送数据。X端发送的数据不会等到Y端发送确认后才发送下一个报文。</p>
<p>TCP协议是可靠的传输协议，所以有一系列复杂的机制来进行具体的的拥塞控制。需要处理的问题如下:<code>丢失报文重发</code>，<code>动态调整发送报文的频率</code></p>
<p><strong>流量控制</strong></p>
<p>流量控制的原则就是发送数据的一方的速度不能比接受数据一方的速度要快。接收方，也就是<code>接收窗口</code>会告诉发送方自身<code>接收窗口</code>数据缓冲区的大小。在tcp包，通过两个两个关键的字段可以得出接收窗口的大小:<code>win -- 窗口大小</code>和<code>wscale -- 窗口发大因子</code> 。如果win=65535 , wscale = 4，那么我们可以计算出接收窗口的大小是 64kB * 4 = 256kB。</p>
<p><strong>拥塞控制</strong></p>
<p>拥塞控制相比于流量控制要复杂一些。拥塞控制就是根据当前网络情况计算出当前网络数据传输的最佳速度。首先我们要认识到，最佳速度不一定就是要最快。一方面，我们希望以更快的速度传输数据。另一方面，由于传输的速度过快，导致大量的数据传入会使处理性能受到影响。在分组交换网络中有一个特点就是<code>超负荷崩溃</code>。当负载过大的时候，数据包之间会产生拥塞，直接导致丢包率上升。</p>
<blockquote>
<p>拥塞控制需要充分考虑对流量的影响。RFC 5681 中对 TCP 拥塞控制有 6,000 字左右的阐述。发送方要时刻关注来自接收方的确认信息。要做到这点并不简单，有的时候还需要一定的妥协。要知道底部 IP 协议数据包是无序传输的，数据包会丢失也会重复。发送方需要评估 RTT 往返时间，然后基于 RTT 去确定是否收到了接收方的确认信息。重发数据包也有很大代价，除了连接延迟问题，网络的负载也会发生明显的波动。导致 TCP 需要不停的去适应当前网络情况。</p>
<p>更重要的是，TCP 连接本身是易变的。除了数据传输，连接的两端还会不时的发送一些提醒和确认信息以便可以适当的调整状态来维持连接。</p>
<p>基于这种一直在相互协调中的连接关系，TCP 连接往往会是短暂而低效的。在建立连接的初期，TCP 协议算法还不能完全了解当前网络状况。而在连接将要结束的时候，反馈给发送方的信息又可能不充分，这样就很难对连接状况做出实时的合理的评估。</p>
</blockquote>
<p><em>四次挥手，断开连接</em></p>
<p>建立连接是通过<code>三次握手</code>，而释放连接是通过<code>四次握手</code>。在最下方有图示解释整个过程。那么为什么需要四次握手才能释放连接呢？</p>
<p>上文提到了，TCP是全双工的，因此每个方向上的连接需要单独关闭。这个原则就是当一方没有数据可以传送的时候，发送FIN来终止这一方的连接，但是另一方向上的数据仍然可以发送。当另一方向也发送了FIN的时候，整个连接才完全的关闭了。无论服务器端还是客户端都可以发送来FIN来主动关闭连接。</p>
<p><img src="/media/14428004433668.jpg" alt="四次挥手"></p>
<p>##HTTPS</p>
<p>之前的博文谈到了HTTP（超文本传输协议）。如今苹果操作系统iOS也升级到了iOS9。在iOS9中强制所有网络传输协议使用HTTPS。看来对HTTPS的了解是势在必行的了。</p>
<p>HTTPS,实际上可以看作HTTP的加密版本。HTTPS将HTTP协议数据包放到SSL/TSL层加密后，在TCP/IP蹭去传输。到了目标源后，在SST/TSL将数据包解密，传递到HTTP层就是普通的HTTP数据包了。</p>
<p>HTTPS = HTTP + SSL/TSL</p>
<p><strong>SSL/TSL</strong></p>
<p>关于SSL/TSL，我们可以参考下面两篇文章：</p>
<p>!<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>
<p>!<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a></p>
<p>简单的来说，通过SSL/TSL四次握手，来解决下面三个问题。</p>
<ol>
<li>数字证书：该证书包含了公钥等信息，一般是由服务器发给客户端，接收方通过验证这个证书是不是由信赖的CA签发，或者与本地的证书相对比，来判断证书是否可信；假如需要双向验证，则服务器和客户端都需要发送数字证书给对方验证；</li>
<li>三个随机数：这三个随机数构成了后续通信过程中用来对数据进行对称加密解密的“对话密钥”。<br>首先客户端先发第一个随机数N1，然后服务器回了第    二个随机数N2（这个过程同时把之前提到的证书发给    客户端），这两个随机数都是明文的；而第三个随机    数N3（这个随机数被称为Premaster secret），    客户端用数字证书的公钥进行非对称加密，发给服务    器；而服务器用只有自己知道的私钥来解密，获取第    三个随机数。这样，服务端和客户端都有了三个随机    数N1+N2+N3，然后两端就使用这三个随机数来生    成“对话密钥”，在此之后的通信都是使用这个“对话    密钥”来进行对称加密解密。因为这个过程中，服务端    的私钥只用来解密第三个随机数，从来没有在网络中    传输过，这样的话，只要私钥没有被泄露，那么数据    就是安全的。</li>
<li>加密通信协议：就是双方商量使用哪一种加密方式，假如两者支持的加密方式不匹配，则无法进行通信；</li>
</ol>
<p>具体的可以参考上面两篇文章的内容，去了解SSL/TSL加密的过程。在这里想重点说的是在iOS中使用HTTPS。</p>
<p>在iOS中，常用的是<code>NSURLConnection</code>支持HTTPS的实现。而常用的第三方库<code>AFNetworking</code>封装了使用<code>NSURLConnection</code>实现的逻辑代码，更加完善。在<code>AFNetworking</code>中使用的方法如下</p>
<pre><code>Objective-C

NSURL * url = [NSURL URLWithString:@&quot;https://www.google.com&quot;];
AFHTTPRequestOperationManager * requestOperationManager = [[AFHTTPRequestOperationManager alloc] initWithBaseURL:url];
dispatch_queue_t requestQueue = dispatch_create_serial_queue_for_name(&quot;kRequestCompletionQueue&quot;);
requestOperationManager.completionQueue = requestQueue;

AFSecurityPolicy * securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];

//allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO
//如果是需要验证自建证书，需要设置为YES
securityPolicy.allowInvalidCertificates = YES;

//validatesDomainName 是否需要验证域名，默认为YES；
//假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。
//置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。
//如置为NO，建议自己添加对应域名的校验逻辑。
securityPolicy.validatesDomainName = YES;

//validatesCertificateChain 是否验证整个证书链，默认为YES
//设置为YES，会将服务器返回的Trust Object上的证书链与本地导入的证书进行对比，这就意味着，假如你的证书链是这样的：
//GeoTrust Global CA 
//    Google Internet Authority G2
//        *.google.com
//那么，除了导入*.google.com之外，还需要导入证书链上所有的CA证书（GeoTrust Global CA, Google Internet Authority G2）；
//如是自建证书的时候，可以设置为YES，增强安全性；假如是信任的CA所签发的证书，则建议关闭该验证，因为整个证书链一一比对是完全没有必要（请查看源代码）；
securityPolicy.validatesCertificateChain = NO;

requestOperationManager.securityPolicy = securityPolicy;
</code></pre><p>##杂谈</p>
<p>关于连接。TCP连接容易在两个地方出问题：初始设置，以及通过连接传输最后一部分的内容。</p>
<hr>
<p>建立连接的时候，TCP由于要进行三次握手，所以在这过程中会有一定的时间损耗。一般一个移动终端向服务发送一个数据包普遍需要250ms, 三次握手的话就是需要750ms。而在HTTPS中则更加夸张。因为HTTPS需要四次握手。。。嗯，在TCP和HTTPS都握手完后，大概需要1750ms.是建立一个HTTP连接的两倍。为了安全，就肯定要牺牲时间效率。</p>
<p>此外，由于TCP需要侦测当前最佳的转发路由，所以在传送大量的数据时，需要不停地去调整以便得到最佳速度。这种算法被称为<code>慢启动</code>。注意到，慢启动在数据链路层传输质量差的网络上表现的更差，无线网络就是典型的例子。(4G说，怪我咯)。</p>
<hr>
<p>通过TCP释放连接的过程，我们也知道可能存在问题</p>
<blockquote>
<p>如果发送方完成数据发送，接受方自然会停止发送 ACK 确认。在最后四个报文传输的过程中，快速重发算法是没有办法处理这四个报文的数据包的丢失问题的（因为不会收到三个相同的确认 ACK，所以不能界定传输丢包）。在常规网络环境下，四个数据包相当于 5.7kB 的数据规模。总之，在这最后 5.7kB 的传输的过程中，快速重发机制是无效的。针对这种情况，TCP 会启用其他机制来侦测丢包问题。对于这种情况，重传操作可能要消耗几秒钟去执行，这并不奇怪</p>
</blockquote>
<hr>
<p><em>超时处理</em></p>
<p>在APP实际处理中，经常发生网络请求超时的现象。许多APP大概在15秒后收不到反馈就会提示超时信息。这种设计其实并不是很友好。我们知道，只有TCP连接还在，TCP都会保证将请求发送出去并会等待响应的返回，只是时间长短的问题。</p>
<p>个人在这里参考了一些APP的做法，觉得应该在每次请求的时候设置一个计时器，当计时器到达倒数完成后，可以提示用户是否继续网络请求，如果取消就将TCP连接断开，如果继续就继续等待网络请求响应。</p>
<p>##最后</p>
<p>了解了IP TCP HTTPS后，接下来想阅读一些文章怎么从这些方面入手去优化网络请求。在互联网时代，数据和网络是承载产品的基础。因此，网络，怎么深入学习都不过分。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2015/09/14/interview-9-dot-14/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/14/interview-9-dot-14/" itemprop="url">
                  面试小计 9.14
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-09-14T23:22:57+08:00">
                2015-09-14
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天是人生第二次面试。约的公司十一点半。十一点就到了公司楼下。公司所在的地方到家里不远，曾经这里也是充满了许多童年的记忆。想不到过了十几年，自己也会来这里面试，也有可能在这里工作，想想一切都充满许多有趣的偶然。</p>
<p>谈起面试，这只是第二次面试。第一次面试让我感觉非常不好，受到了不小的打击，然而不知道为何现在的公司会收留我做实习生（难道是我长的很适合程序员？）经过了半年的实习经历，踏过了许多以前完全想不到的坑，有了一定的收获，但是这次面试还是有些紧张。相比于第一次面试，我对自己的不足有了更多的认识，也就担心了更多，后面发现我担心是对的，但是担心的点完全不对。。</p>
<p>上了楼，被HR妹子领到一个卡座等待面试。不得不说这个公司的环境要比我的现在的实习公司好了不是一个量级，连拿给我的矿泉水都很高级。。等了大概有五分钟到十分钟，来了个哥们，一看上去就是很厉害的程序员（的确我发现厉害的程序员在长相上都能体现出来）。先自我介绍了一下。由于HR那边只有拉勾网的简历，实在是太普通，所以我把自己带的简历从新给面试官看了下。面试官开始说他也不是负责iOS的（当时内心一惊，我其实很怂考算法和数据结构这种所谓的基础- -）</p>
<p>然后开始聊了下自己现在在公司所做的项目。用电脑展示了一下，开始问第一个问题就是自己负责的了哪些功能，答UI和后台都有设计。然后问了一下一些UI设计的问题，接着就提出一个我刚好思考过的问题：UITableView在网络请求的时候加载图片如何保证流畅性。这个问题刚好周末也和同事讨论过问题，之前也有在网上查了一些不同人思考，就讲了下自己的见解，大概就是通过异步的方式，将UI刷新和图片读取放入不同的线程，通过判断滑动状态来决定是否更新UI。然后他提出我的解决方案中存在的一个问题：如果快速的滑动，只会显示一些预设的空白图片，这样不利于用户去搜索的一个固定的目标。这个问题我回答的时候缺乏了思考，我回答的是通过网络异步请求加载，在前几个屏的Cell延后显示，同时将图片下载预存，快速滑动的时候将新滑入屏幕的cell进行设置图片。后来想来其实有个更讨巧的方法，就是通过分页，控制一次刷新的cell的数量，就避免了用户快速滑动的情况出现。</p>
<p>对于项目，由于面试官也不是做iOS开发的，所以就没设计到一些我准备很久的题目，随后他提出了在项目中是如何与后台联调的。这个问题的许多地方我只知道一些概念，所以理解上有点偏差，但是总体还是回答出来了。</p>
<p>然后面试官随后话锋一转开始问HTTP协议。好险之前抽空整理了HTTP相关知识。HTTP协议必问状态码，在解释了状态码的分类和一些常见的状态码后，他问了我3XX状态码的问题。。怕什么来什么，虽然我记得3XX状态码的归类，但是具体到细节上还是有些遗忘（果真必须什么都要掌握啊）。回答稍微差了一点。</p>
<p>随后面试官问了网络优化的问题。这个问题我感觉比较广泛，不是很好回答，面试官也说不仅限于服务器或者客户端。大概谈了一下自己在项目中的一点想法，特别是当网络服务不好的时候，如何去制造一些交互让用户减少对网络不良造成的影响产生不好反应的可能。然后面试官放了大招 – 请你谈谈网络安全问题。。。当时真的有点慌了，因为和自己准备的东西偏差有点大。随后就从自己的角度谈了下常规的网络攻击的问题。然后。。。然后问了我SQL注入。。这个我真的只是听说啊，臣妾做不到啊。。。</p>
<p>后面还问了一些项目体会，一些经历。。还考了下指针环的判断和一个小球掉落的题目。。那个小球掉落的题目不知道答案应该是什么，感觉就是一个二分查找。。应该问下面试官他的答案的。</p>
<p>到此，第一个面试官问完，走了出去，松了口气，缓一缓。。压力很大，因为和自己想的有点偏差，即使考数据结构和算法都没这样。。因为是没有心理准备。</p>
<p>大概等了有十分钟。来了第二个面试官，上来换了个座位，然后开始让我简单的自我介绍。然后问了下在校成绩和在校所做的项目。。这时候我就有点忧伤了，因为在笑的项目最大的是就是学院的薪资管理系统，但是这个项目时间比较久了而且记忆的东西不多了（所以同学们一定要写自己有把握的项目啊）。然后出了个SQL题目让我写。。。比较没把握的写了，然后提出自己在项目中用的是Hibernate框架，在这个方向上可能不是很对。在之后就是聊天了，大概就是介绍公司的一些状况，一些学习的途径，还问我来深圳工作是否会错过学校的校招，不考研的原因是什么。在这些问题上我都有自己的想法也就简单说了下。最后问我了下现在公司的情况，薪资问题。。然后就问我有事很么了解的（这算过了还是没过。。）然后讨论了一些我在现在公司开发的遇到的坑。。感觉两个面试官能力都很强，思维能力的确看得出来的不一样。最后出来已经是12点15了。</p>
<p>总结这次面试，作为一个应届生应该有更扎实的基础和全面的知识。自己近半年的精力都放在了iOS上，面对一些问题已经很生疏了，但是这不是抛弃其他知识的理由。第二个面试官也谈到了，广泛的涉猎，单一的深入，才能长久的在技术的路上走下去。最后还是希望进入这家公司，无论从环境上还是见到的人上都觉得非常不错。。当然希望自己的薪资也能高一点。</p>
<p>进和没进，都会更新一下。</p>
<hr>
<p>最终担心了两天，还是过了！希望能够在新的团队里面学到更多的知识。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2015/09/13/socket/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/13/socket/" itemprop="url">
                  socket
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-09-13T05:27:26+08:00">
                2015-09-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index">
                    <span itemprop="name">Network</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##写在前面</p>
<p>最近一直在找更好的实习，发现网络编程是一个优秀的程序员必备的技能。而自己在学校中学到的东西很少（逃。要不是有之前的实习和做个一个小小的项目，对于很多知识可能还只是停留在书本上（其实就是没进脑）。最近有人问我是否了解socket，我顿时语塞。对与socket的认识还是学习java的时候知道可以使用socket进行客户端与服务器端的通信，可是当时并没有去实践。欠下的债都是要还的。</p>
<p>此外为什么我每篇博文的开头都写点自己的感受。我觉得博客不仅仅是记录自己的技术积累，也是抒发自己心情的一个途经，所以我会在每篇文章前面写一点点自己在写博文的时候的心情。<br>&lt;!--more--&gt;  </p>
<p>##正文</p>
<p>socket，套接字，是基于TCP/IP协议族下的一种网络通信方式。我们知道，在本地，进程之间有多种方法去通信。在网络中，我们同样可以使用socket进行通信。接下来一步步来看socket是如何使网络上的进程相互通信的。</p>
<p>我们知道，要像让进程通信，首先必须确认进程的身份。如同我们只有知道了和自己谈话的是谁，我们才知道谈什么。在本地，进程拥有唯一的标识PID。在网络上，基于TCP/IP协议，通过<em>IP，协议，端口号</em>，我们可以确认一个进程的唯一身份。</p>
<p>使用TCP/IP协议的应用程序通常采用应用编程接口，有本文讲到的socket（套接字）和TIL（被淘汰了）。目前而言，绝多大数的应用程序都是基于socket进行网络通信的，所以了解socket是一个程序员必备的。</p>
<p>##scocket 究竟是什么</p>
<p>socket起源于UNIX。我们知道UNIX的设计原理就是<em>一切皆文件</em>，操作都是<em>open -&gt; read/write -&gt; close</em>。所以说，我们可以认为socket也是一个文件，是基于上述设计原理的实现。socket函数就是专门来完成相应操作的。</p>
<p>##socket 操作</p>
<p>在上面我们知道了socket是一个文件，那么socket自然有对应的操作方法，下面是基于TCP的几个基本操作。<br>(注，本文的方法是使用Objective-C写的，其实socket在任何语言都是差不多的)</p>
<pre><code class="objective-c">
// 创建并初始化socket，返回socket的文件描述符，如果返回值为-1则创建失败
int socket(int addresFamily, int type, int protocol)

// 关闭socket
int close(int socketFileDescriptor)

// 将socket与特定的IP地址和端口号绑定，成功返回0，失败返回-1
int bind(int socketFileDescriptor, sockadd *addressToBind)

// 接受客户端的请求并且将客户端的网络地址信息存入clientAddress
// 当客户端的连接请求被接受后，双方的通信链路就建立好了，两者就可以开始通信了。

int accept(int socketFileDescriptor, sockaddr *clientAddress, int clientAddressStructLength)

// 客户端向特定的IP的服务器发送连接请求，成功返回0，失败返回-1
// 当服务器建立好后，客户端就可以通过这个函数与服务器端建立连接。
// 对于UDP来说，该接口是可选的，如果调用了这个接口表明设置了UDP socket默认的网络地址.
// 对于TCP来说，这里就是三次握手发生的地方

int connect(int socketFileDescriptor, sockaddr *serverAddress, int serverAddressLength)

// 通过DNS查找特定的IP，如果找不到返回NULL
hostent *gethostbyname(char *hostname)

// 发送数据，发送成功后返回成功发送的字节数，否则返回-1
int send(int socketFileDescriptor,char *buffer, int flags)

// 接收数据，成功后返回成功读取的字节数，否则返回-1
int receive(int socketFileDesciptor,char *buffer,int flags)

// 下面两个方法是UDP的方法

// UDP发送,返回状态同上
int sendto(int socketFileDesciptor, char *buffer, int bufferLength, int flags, sockaddr *destinationAddress, int destinationAddressLength)

// UDP读取，返回状态同上
int recvfrom(int socketFileDesciptor, char *buffer, int bufferLength, int flags, sockaddr *fromAddress, int fromAddressLength)
</code></pre>
<p>通过观察方法，我们发现socket其实就是<em>确认目标 -&gt;建立连接 -&gt; 传送/读取 -&gt; 断开</em> 的过程</p>
<p>我们再来看看TCP和UDP下socket操作的不同的地方</p>
<p>####TCP</p>
<p><img src="http://www.coderyi.com//qiniu/429/image/5269612b25e6df1b3ee5ab8352b2c3b6.jpg" alt="TCP"></p>
<p>####UDP<br><img src="http://www.coderyi.com//qiniu/429/image/cd6d1690d3d6eefd300987e590c1483f.jpg" alt="UDP"></p>
<p>##最后</p>
<p>到此，对于socket编程的概念有了个一个初步的认识了。在实际开发中，我们一般不会直接调用这些底层的API。借助于一些开源的第三方库更有利于项目的开发运行。不过，对于基本的理论知识还是必须要掌握的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2015/09/12/gcd/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/12/gcd/" itemprop="url">
                  GCD小结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-09-12T21:16:43+08:00">
                2015-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#写在最前面</p>
<p>最近发现自己学东西的效率好像高了，难道是因为写博客做笔记的原因吗？的确通过写博客来记录自己学习的成果能够加强自己对很多问题的理解。只有能够通过自己的语言将学习到的内容讲出来才是真的理解。所以以后看来要多写写。<br>&lt;!--more--&gt;  </p>
<p>#正文</p>
<p>##GCD是什么鬼</p>
<p>GCD，简单的来说就是苹果自己出的一套多核运算的解决方案。虽然苹果没有安卓那么多核心，但是并行化运算能够提高流程性是不可争辩的事实。GCD内部自动管理线程 的生命周期，不需要我们自己去手动管理。我们只需要调用对应的API就可以了。GCD是基于C语言开发的，不过由于使用了block，所以使用起来很方便。在了解GCD之前，我们需要了解一点多线程运行的原理。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>GCD中有两个重要的概念：<em>任务</em> 和 <em>队列</em></p>
<ol>
<li>任务。我们可以理解任务就是一个动作，放在GCD中就是一个代码块（block）。执行任务有两种，分别为<em>同步执行</em> 和 <em>异步执行</em>。同步和异步的区别其实很好理解。<code>同步执行</code>既是当前任务执行完前会阻塞当前进程，<code>而异步执行</code>就不会。</li>
<li><p>队列。队列是用来存放任务的。我们可以理解为任务就是队列中排队等待执行。队列分为<em>串行队列</em>和<em>并行队列</em>。</p>
<ul>
<li>串行队列，就像排队一样，严格遵守FIFO。</li>
<li>并行队列，同样执行FIFO。不同的是，取出来的任务会根据情况放到别的线程上。由于多个线程出队的时间间隔可能很短，所以容易认为是非FIFO的。不过即使这样，系统也会根据硬件条件来判断，并不一定会所有任务都在同时执行。</li>
</ul>
<hr>
<p>创建队列的操作如下图所示</p>
<p><img src="http://i3.tietuku.com/045e13ec06064ef3.png" alt="queue"></p>
<hr>
<p>创建任务如下如图所示</p>
<p><img src="http://i3.tietuku.com/b2ef139ced93771f.png" alt="task"></p>
</li>
</ol>
<h4 id="队列组"><a href="#队列组" class="headerlink" title="队列组"></a>队列组</h4><p>  对列组就是将多个队列添加到一个组里。这样的方式使我们可以在队列里所有的任务都完成后收到一个通知方法。</p>
<pre><code>  objective-c

  // 创建队列组
    dispatch_group_t group = dispatch_group_create();

    dispatch_group_async(group, globalQueue, ^{
      for (NSInteger i = 0; i &lt; 3; i++)
      {
          NSLog(@&quot;group - queue - %@&quot;, [NSThread currentThread]);
      }
    });
</code></pre><h2 id="NSOperation-和-NSOperationQueue"><a href="#NSOperation-和-NSOperationQueue" class="headerlink" title="NSOperation 和 NSOperationQueue"></a>NSOperation 和 NSOperationQueue</h2><p>  NSOperation 和 NSOperationQueue是苹果对GCD的基于面向对象的完全封装，使其更容易理解。操作方式也更简单</p>
<ol>
<li>将要执行的任务封装到一个<code>NSOperation</code>对象中</li>
<li><p>将任务添加到一个<code>NSOperationQueue</code>中</p>
<p>此后系统将自动在执行任务。</p>
</li>
</ol>
<h3 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h3><p> 由于NSOperation是一个抽象类，所以不能直接封装任务。但是有两个子类用于封装任务：<code>NSInvocationOperation</code> 和 <code>NSBlockOperation</code>。创建一个队列后，需要调动<code>start()</code>方法来启动，<em>默认在当前队列同步执行</em>。同时队列提供<code>cancel()</code>方法在中途取消任务。</p>
<ul>
<li>NSInvocationOperation 传入一个方法名。</li>
<li>NSBlockOperation 传入一个代码块。<ul>
<li>在NSBlockOperation中，有一个方法<code>addExecutionBlock</code>方法。这个方法使我们可以添加多个block到队列中。<em>这些block将会并发执行**，将在</em>主线程和其他的多个线程``执行任务</li>
</ul>
</li>
</ul>
<p>###添加队列</p>
<p>   多数时候，我们不希望当前线程被占用，因为会影响到UI的流畅性（UI永远在主线程上）。因此我们需要创建新的队列。只要我们添加任务到队列上，就会自动调用任务的<code>start()</code>方法。如果任务在其他队列上，那么他就会在其他线程上并行执行。</p>
<p>   我们发现，<code>NSOperationQueue</code>并没有设置串行和并行队列的问题，那么<code>NSOperationQueue</code>是怎么确定队列的类型的呢。苹果通过封装巧妙的使调用者不需要特意的去注意队列的性质，只需要设置<code>NSOperationQueue</code>中的<code>maxConcurrentOperationCount</code> – 最大并发数就可以了。</p>
<p>##总结</p>
<p>   在上篇block的文章中也谈到了block在gcd的中的应用。通过gcd，我们可以最大化的去使用硬件的性能，避免出现卡顿的现象。多线程用的好不好，也基本上代表了一个开发者的能力水平。虽然多线程编程有许多坑，但只有跨过一个个坑，才能变成大牛，不是吗？</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://p3.pstatp.com/large/ab000310321818ab99.jpg"
               alt="csbzhixing" />
          <p class="site-author-name" itemprop="name">csbzhixing</p>
          <p class="site-description motion-element" itemprop="description">之行的博客</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">30</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/csbzhixing" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/csbzhixing/activities" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">csbzhixing</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.0"></script>



</body>
</html>
