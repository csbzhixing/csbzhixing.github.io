<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>学海无涯</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="之行的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="学海无涯">
<meta property="og:url" content="http://csbzhixing.github.io/page/2/index.html">
<meta property="og:site_name" content="学海无涯">
<meta property="og:description" content="之行的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学海无涯">
<meta name="twitter:description" content="之行的博客">
  
    <link rel="alternative" href="/atom.xml" title="学海无涯" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://forum.guildlaunch.net/2/6/2/8/438262/forums/sleepy_by_marutar0-d6rlepj.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">之行</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/csbzhixing" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">之行</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img src="http://forum.guildlaunch.net/2/6/2/8/438262/forums/sleepy_by_marutar0-d6rlepj.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
			</div>
			<hgroup>
			  <h1 class="header-author">之行</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/csbzhixing" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-thread" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/25/thread/" class="article-date">
  	<time datetime="2015-09-25T01:49:52.000Z" itemprop="datePublished">2015-09-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/25/thread/">多线程开发详谈</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>按照计划，这篇文章主要谈iOS下的并发编程。</p>
<p>之前的文章已经谈过了GCD的实现，包括苹果在GCD之上实现的NSOperation。但是在几次面试后发现，仅仅了解API还不够，要去深入的了解整个运行的机制。只有对整个系统有了更深刻的了解，才能不被API给限制住。</p>
<p>##并发</p>
<p>并发，概念就是同时运行多个任务。这些任务可以以分时的方式运行在单核CPU上面，也可以以真正的并发运行在多核CPU上面。</p>
<p>实现并发，不仅可以最大化地利用硬件的性能，也可以提高程序的功能。</p>
<p>###线程</p>
<p><code>线程(thread)</code>是组成进程的子单元，操作系统可以对线程进行单独的调用。在苹果系统上的API都是以线程为单元进行调度的。</p>
<p>多线程运行不仅能够在多核CPU上运行，也可以仅仅运行在单核CPU上。通过CPU分时，系统将极小的时间片分配给不同线程，让用户以为是多任务运行的。但是通过分时的效果不如多线程直接运行在多核CPU上。</p>
<p>通过使用<code>Instruments</code>中的<code>CPU strategy view</code>可以观察代码如何在多核CPU运行的。</p>
<p>##并发变成的API</p>
<p>在之前的文章已经谈过了高层封装的两种，这里的重点不是如何使用API。</p>
<p>在苹果的多线程中，有以下API供我们使用，从底层到高层一次如下:</p>
<ol>
<li>pthread</li>
<li>NSThread, 苹果在pthread上的封装</li>
<li>Grand Central Dispatch（GCD）</li>
<li>Operation Queues</li>
<li>Run Loops</li>
</ol>
<p>这里想重点谈一下Run Loops。</p>
<p><code>Run Loops</code>不同于<code>GCD</code>或者<code>Operation Queues</code>一样的并发机制，因为<code>Run Loops</code>并不能并行执行任务。不过在主dispatch/operation中，Run Loops提供了一种异步执行代码的机制。通过Run Loops，我们不必担心并发中的各种陷阱，就能<code>异步</code>执行任务。</p>
<p>在主线程中，每一个 Cocoa 和 CocoaTouch 程序中，Main run loop都是扮演了最重要的角色。因为是run loop 来处理相关的内核事件的。</p>
<p>线程和run loop是一一对应的。线程在创建的时候并没有run loop，如果不主动获取，那run loop就不会存在。Run Loop的创建在第一次获取的时候，销毁在线程结束的时候。除了主线程外，只能在一个线程的内部获取run loop。</p>
<p>对于run loop的详细，又是一篇很长的文章来说了。这里就不详细说了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/base/">base</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-json-and-xml" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/24/json-and-xml/" class="article-date">
  	<time datetime="2015-09-24T08:44:36.000Z" itemprop="datePublished">2015-09-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/24/json-and-xml/">json&amp;amp;xml</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="网络传输格式-JSON-amp-XML"><a href="#网络传输格式-JSON-amp-XML" class="headerlink" title="网络传输格式 JSON &amp; XML"></a>网络传输格式 JSON &amp; XML</h1><p>第一次接触这两个格式还是在学校做一个财务管理系统的时候。在之前变成都是纯粹的单机编程，不设计到网络数据传输的问题。到了这个项目才开始考虑如何在服务器和客户端之间传输数据。项目中使用的是JSON，所以在这里先讲JSON的部分。</p>
<p>##JSON</p>
<p>JSON是一种轻量化的数据格式。他的特点就是方便已用。目前90%的网络传输都是依赖于JSON格式。</p>
<p>首先来看看JSON格式是怎么样的。</p>
<pre><code class="json">
&quot;access_token&quot;: &quot;ACCESS_TOKEN&quot;,

   &quot;expires_in&quot;: 1234,

   &quot;remind_in&quot;:&quot;798114&quot;,

   &quot;uid&quot;:&quot;12341234&quot;
</code></pre>
<p>这是一个常见的JSON格式。比较容易的看出，其实就是一种key-value的形式。</p>
<p>key我们都好了解，是一个string。那么value就会有不一样的值。通过对比OC的对象，我们可以更容易的理解JSON中的数据类型。</p>
<pre><code>            JSON                    OC

            {}                        NSDictionary

            []                        NSArray

            &quot;&quot;                        NSString

           数字                      NSNumber


</code></pre><p>知道了JSON所对应的OC对象，我们就可以通过解析JSON对象，将相关的数据转换成OC对象来存储。在这里，介绍一种能够在本地模拟API的方式，这也是由于自己找不到很好的开发API所以想在本地能够模拟API的方式。</p>
<p>##JSON Server 模拟 API</p>
<p>###第一步 安装</p>
<ul>
<li>安装Homebrew。这个可是个神器，能够管理mac上的第三方的库的工具。据说被作者写不出反转二叉树个谷歌拒了然后去了苹果。</li>
</ul>
<p><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p>
<ul>
<li>安装node.js</li>
</ul>
<p><code>brew install node</code></p>
<ul>
<li>安装json-server</li>
</ul>
<p><code>npm install -g json-server</code></p>
<h2 id="根据需求创建JSON"><a href="#根据需求创建JSON" class="headerlink" title="根据需求创建JSON"></a>根据需求创建JSON</h2><p>安装完毕后，随便找个你喜欢的文件夹，创建一个JSON格式的文件，如下</p>
<pre><code class="JSON">{
  &quot;posts&quot;: [
    { &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; }
  ],
  &quot;comments&quot;: [
    { &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 }
  ],
  &quot;profile&quot;: { &quot;name&quot;: &quot;typicode&quot; }
}
</code></pre>
<p>然后保存。</p>
<p>###启动JSON-Server</p>
<p>通过命令<code>json-server --watch JSON文件的名字.json</code>来启动Server</p>
<p>到这里，我们就相当于在本地创建了一个服务器能够相应我们想对应的请求。</p>
<p>以上面的的JSON文件为例</p>
<p><img src="/media/14430769630713.jpg" alt=""></p>
<p>当然，功能不止这么一点，JSON-Server还有更多方式，详见github<a href="https://github.com/typicode/json-server" target="_blank" rel="external">json-server</a></p>
<p>##OC对象和JSON对象的转换</p>
<ul>
<li>通过<code>NSJSONSerialization</code>来序列化JSON.</li>
</ul>
<pre><code>![](/media/14430773793672.jpg)


</code></pre><p>输出的结果</p>
<p><img src="/media/14430774045308.jpg" alt=""></p>
<p>对比上面的JSON数据，我们可以看出解析的结果是正确的</p>
<ul>
<li>通过第三方库JSONKit来解析</li>
</ul>
<p> 下载地址 <a href="https://github.com/johnezang/JSONKit" target="_blank" rel="external">JSONKit</a></p>
<p> <img src="/media/14430745214364.jpg" alt=""></p>
<ul>
<li>使用Mantle</li>
</ul>
<p>在项目中用的最多的方法，也觉得非常好用</p>
<p>下载地址：<a href="https://github.com/Mantle/Mantle" target="_blank" rel="external">Mantle</a></p>
<p>使用的方法：</p>
<ol>
<li>在本地创建对应的OC类<br><img src="/media/14430784491980.jpg" alt=""></li>
</ol>
<ol>
<li>实现相关的方法</li>
</ol>
<p><img src="/media/14430794069120.jpg" alt=""></p>
<p>第三种是直接将JSON通过一定的方法转成了OC的类对象。在使用的时候感觉更方便。</p>
<p>##XML</p>
<p>虽然JSON在网络传输中有90%的使用率，但是我们依然不能放弃10%的XML是吧。</p>
<p>XML全称是Extensible Markup Language，译作“可扩展标记语言”<br>跟JSON一样，也是常用的一种用于交互的数据格式<br>一般也叫XML文档（XML Document）</p>
<p>下面是一个典型的XML文件的结构</p>
<pre><code>一个元素包括了开始标签和结束标签
拥有元素内容：&lt;city&gt;上海&lt;/city&gt;
没有元素内容：&lt;city&gt;&lt;/city&gt;
没有元素内容的简写：&lt;city/&gt; 

一个元素可以嵌套若干个子元素（不能出现交叉嵌套）
&lt;citys&gt;
    &lt;city&gt;
        &lt;name&gt;上海&lt;/name&gt;
        &lt;weather&gt;大暴雨&lt;/weather&gt;
          &lt;air&gt;舒适&lt;/air&gt;
    &lt;/city&gt;
&lt;/citys&gt;

规范的XML文档最多只有1个根元素，其他元素都是根元素的子孙元素
XML中的所有空格和换行，都会当做具体内容处理

一个元素可以拥有多个属性，属性值必须用 双引号&quot;&quot; 或者 单引号&#39;&#39; 括住。
&lt;city name=&quot;上海&quot; weather=&quot;大暴雨&quot; air=&quot;舒适&quot; /&gt;


属性表示的信息也可以用子元素来表示，比如

   &lt;city&gt;
        &lt;weather&gt;大暴雨&lt;/weather&gt;
          &lt;air&gt;舒适&lt;/air&gt;
    &lt;/city&gt;
</code></pre><p>解析XML有两种方式</p>
<ol>
<li>DOM解析：一次性将整个XML文档加载进内存，比较适合解析小文件</li>
<li>SAX解析：从根元素开始，按顺序一个元素一个元素往下解析，比较适合解析大文件</li>
</ol>
<p>在iOS SDK里面，提供了两种解析的框架</p>
<ol>
<li>NSXMLParser：它是基于objective-c语言的sax解析框架，是ios sdk默认的xml解析框架，不支持dom模式。</li>
<li>libxml2: 它是基于c语言的xml解析器，被苹果整合在ios sdk中，支持sax和dom模式。</li>
</ol>
<p>同样，第三方也有许多解析XML的库。这里不打算讲第三方的，一个XML使用的比较少，一个使用SDK自身的效率往往已经非常好了。</p>
<p>###NSXMLParser</p>
<p>NSXMLParser属于SAX解析，是从上往下依次解析每个元素，在解析到每个元素的时候会通知代理，所以使用NSXMLParser必须遵守他的协议。<br>使用非常简单</p>
<p><img src="/media/14430815879826.jpg" alt=""><br>从当前项目读取XML文件，读出数据，穿件解析器，设置代理，开始解析。</p>
<p>XML文件内容如下</p>
<p><img src="/media/14430816475695.jpg" alt=""><br>设置代理后，我们要实现代理方法，主要有以下方法，直接上图了</p>
<p><img src="/media/14430816906329.jpg" alt=""></p>
<p><img src="/media/14430817012681.jpg" alt=""></p>
<p><img src="/media/14430833160910.jpg" alt=""></p>
<p><img src="/media/14430833236999.jpg" alt=""></p>
<p>###libxml2</p>
<p>重点在于导入libxml2的库</p>
<p><img src="/media/14430836046841.jpg" alt=""></p>
<p><img src="/media/14430836140287.jpg" alt=""></p>
<p><img src="/media/14430836178120.jpg" alt=""></p>
<p><img src="/media/14430836230051.jpg" alt=""></p>
<p><img src="/media/14430836285068.jpg" alt=""></p>
<p>编译项目，通过了就没问题了。</p>
<p>用法参见<a href="https://github.com/neonichu/GDataXML" target="_blank" rel="external"></a></p>
<p>##总结</p>
<p>在实际使用中，还JSON用的更多，所以对于JSON的解析过程要更加了解。对于XML，有一些公司任然会使用，而一些现存的数据也会用XML存储，所有也要有一定的了解。</p>
<p>这篇文章讲解了在网络通信中数据的格式。下一篇的话就进入iOS内如何进行网络通信了。虽然使用AFNetWorking已经有段时间了，但是对内部整个机制并不了解，要好好补课了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Network/">Network</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-arc" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/22/arc/" class="article-date">
  	<time datetime="2015-09-22T09:48:06.000Z" itemprop="datePublished">2015-09-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/22/arc/">重新认识ARC</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>第一次接触ARC还是在第一次拿到项目的时候。学习OC的时候使用的教材主要是通过MRC来讲解Retain Counting(引用计数)的。后面只是简单的了解了下ARC是编译器在编译的过程中自动去估算对象的生命周期来自动添加retain和realse的。解放了双手，也就没有什么动力去研究了。现在得空了，是时候增强自己的技能树。当前的目标如下</p>
<p>&lt;!--more--&gt;  
</p>
<ol>
<li>增加网络编程的相关知识<ul>
<li>TCP/IP HTTP HTTPS 协议的学习和了解</li>
<li>JSON和XML的解析</li>
<li>iOS自身关于网络请求相关的类和API</li>
<li>第三方库AFNetWorking源码阅读</li>
</ul>
</li>
<li>增加iOS内核方面的知识<ul>
<li>内存基本知识和管理方式</li>
<li>ARC</li>
<li>进程线程</li>
<li>RunTime</li>
</ul>
</li>
</ol>
<p>简单的看是两个大类七个点，但是感觉每一个点都非常多东西。目前暂时把1.1的点给补完了。不过任然需要投入大量的时间去复习。这里打算整合2.1和2.2。</p>
<p>##内存管理<br>学过计算机基础的人对于内存都不陌生，哪怕是没有计算机基础的人也明白内存对于电脑（终端）的重要性。内存管理，就是在程序运行的过程中，申请，使用，释放内存的过程。程序写的好不好，就看你在完成功能的同时是不是使用了尽可能少的内存。</p>
<p><em>堆和栈</em></p>
<p>在内存中，有两个重要的概念，分别是<code>堆和栈</code>。这里不仅仅指代他们的数据结构。我们知道，一个函数执行的时候，他会被压入栈中。栈中的内存单元保存了函数的返回地址，局部变量，传参等数据。当函数被弹出栈的时候，一切数据都会被销毁。而<code>堆</code>上的数据是由开发者自行申请管理的，生命周期由开发者自行掌握。</p>
<p><em>引用计数</em></p>
<p>学过OC的人都知道，在OC中管理内存的方法是<code>引用计数</code>(Retain Counting)。通过对堆和栈的了解，我们可以得出OC上的对象<em>都是在堆上</em>的。</p>
<p>在苹果开发文档里面有一张图很好的说明的通过引用计数来管理对象生命周期的过程。</p>
<p><img src="/media/14429735006902.jpg" alt="引用计数"></p>
<p>同样，引用计数也遵循几大内存管理原则</p>
<ol>
<li>谁申请谁拥有</li>
<li>肯以申请拥有一个存在的对象</li>
<li>当不需要的再拥有对象的时候，申请释放</li>
<li>不能释放不属于自己没有拥有的对象</li>
</ol>
<p>##Automatic Reference Counting (ARC)</p>
<p>在学习iOS开发半年后，ARC给我留下了很深的印象。ARC是苹果在引用计数的基础上改善了编译器实现的功能。要了解ARC，首先要看看在没有ARC之前开发者是怎么去通过引用计数管理的。</p>
<p>在ARC之前，我们统称为<code>MRC（Manual Reference Counting</code>，即手动引用技术。通过调用<code>retain</code>和<code>release</code>来管理对象的生命周期。有了ARC之后，在编译的过程中，编译器可以根据上下文估算对象的生命周期，以此来自动的添加<code>retain</code>和<code>release</code>。</p>
<p>注意，ARC只对OC对象有作用，对于C的类型对象不则按照C的内存管理的方法去管理。</p>
<p>如果在工程中开启了使用ARC，那么就要遵循ARC定义的一些规范</p>
<ol>
<li>不能显示的调用<code>dealloc</code>,<code>ratain</code>,<code>release</code>,<code>retainCount</code>,<code>autoRelease</code>。</li>
<li>如果要复写<code>dealloc</code>方法，不需要显示调用<code>[super dealloc]</code>方法。</li>
<li>不能再使用<code>AutoReleasepool</code></li>
</ol>
<p><em>ARC下的修饰符</em></p>
<p>在@Property 中，有四种修饰符是ARC提供的，他们分别是</p>
<ol>
<li>strong</li>
<li>weak</li>
<li>unsafe_unretained</li>
<li>__autoreleasing</li>
</ol>
<p>其中，重点来谈谈strong和weak</p>
<ul>
<li>strong。我们理解为强引用。当前的对象实际拥有这个对象。默认情况下ARC使用的strong来修饰。</li>
<li>weak。相对于strong的强引用，weak指的是弱引用。当引用的对象被释放掉的时候，当前引用对象会被自动置nil。weak通常被用来解决循环引用的问题。</li>
</ul>
<p><code>__autoreleasing</code>和<code>__unsafe_unretained</code>在实际应用中是很少的。<code>__unsafe_unretained</code>是为了兼容iOS4之前的版本，现在基本上不会使用了，主要是为了实现weak的功能。<code>__autoreleasing</code>是表示在autorelease pool中自动释放对象的引用。</p>
<h2 id="block-在ARC下"><a href="#block-在ARC下" class="headerlink" title="block 在ARC下"></a>block 在ARC下</h2><p>block在之前已经小小的讨论过了，出现的几个问题都有谈论到，这里主要从ARC的角度上再谈一谈。</p>
<p>block在ARC下最特殊的地方就是怎么去解决循环引用。在block的篇章中没有很详细讨论，原因也是没从内存的角度来看。这里详细讲下循环引用产生原因和在ARC下解决循环引用的方法。</p>
<p>&gt;<br>You can use lifetime qualifiers to avoid strong reference cycles. For example, typically if you have a graph of objects arranged in a parent-child hierarchy and parents need to refer to their children and vice versa, then you make the parent-to-child relationship strong and the child-to-parent relationship weak. Other situations may be more subtle, particularly when they involve block objects.<br>&gt;<br>In manual reference counting mode, <strong>block id x; has the effect of not retaining x. In ARC mode, </strong>block id x; defaults to retaining x (just like all other values). To get the manual reference counting mode behavior under ARC, you could use <strong>unsafe_unretained </strong>block id x;. As the name <strong>unsafe_unretained implies, however, having a non-retained variable is dangerous (because it can dangle) and is therefore discouraged. Two better options are to either use </strong>weak (if you don’t need to support iOS 4 or OS X v10.6), or set the __block value to nil to break the retain cycle.<br>&gt;<br>The following code fragment illustrates this issue using a pattern that is sometimes used in manual reference counting.</p>
<p>上面是苹果官方文档对循环引用的解释。通过引用计数，我们了解到，如果有两个对象，对彼此都是强引用的话，双方都无法释放对方，也就无法释放delloc对象，最终就造成了死循环。在iOS5以下的版本里面，我们可以通过手动使用<code>unsafe_unretained</code>来使其中一个变量变成野指针。而在ARC下，我们通过使用weak来修饰其中一个变量，这样在block中就不存在双方强引用的抢矿。</p>
<p>但是，上面的处理方法有个问题。我们不知道weak修饰的对象什么时候会被释放掉了，有可能在执行block里面的对象在之前就已经被释放掉了。在AFNetWorking中，提供了一个非常好的解决思路</p>
<p><img src="/media/14429947239639.jpg" alt=""></p>
<p>上面方法中，在block外先将self用<code>weak</code>引用一个weakSelf，进入block后再使用一个<code>_strong_typeof</code>去创建一个strong引用对象。这样的做法既能避免产生循环引用，也能避免weak对象提前被释放掉。</p>
<p>##ARC与Toll-Free Bridging</p>
<p>Toll-Free Briding保证了在程序中，可以方便和谐的使用Core Foundation类型的对象和Objective-C类型的对象。但是，我们知道，到了ARC的时候，两者的内存管理方法不同了。对于一种对象，我们不能用该两种内存管理方法去管理。所以在进入ARC之后，Toll-Free Bridging也进行了相应的变化。</p>
<p><em>__bridge</em></p>
<p>只是申明了类型转变，并没有改变内存管理方法。</p>
<p><em>__bridge_retained（修饰符） or CFBridgingRetain（函数）</em></p>
<p>表示将指针类型转变的同时，将内存管理的责任由原来的Objective-C交给Core Foundation来处理，也就是，将ARC转变为MRC。</p>
<p><em>__bridge_transfer（修饰符） or CFBridgingRelease（函数）</em></p>
<p>这个修饰符和函数的功能和上面那个__bridge_retained相反，它表示将管理的责任由Core Foundation转交给Objective-C，即将管理方式由MRC转变为ARC。</p>
<p>上面就是要谈的ARC的内容了。其实ARC的坑比起MRC已经少了很多了，对于我们可怜的程序员来说已经是很大的解放了。</p>
<p>这里对于内存管理仅仅是基于OC简单的谈了谈，觉得还是不够深刻，主要是自己在这方面的知识的确很欠缺。读了<br><a href="http://casatwy.com/ccheng-xu-de-nei-cun-guan-li.html" target="_blank" rel="external">C程序的内存管理</a>这篇文章学到了很多，在这里也安利一下。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Objective-C/">Objective-C</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-title" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/18/title/" class="article-date">
  	<time datetime="2015-09-18T08:48:55.000Z" itemprop="datePublished">2015-09-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/18/title/">IP TCP HTTPs 随便谈</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="IP-TCP-HTTPs-随便谈"><a href="#IP-TCP-HTTPs-随便谈" class="headerlink" title="IP TCP HTTPs 随便谈"></a>IP TCP HTTPs 随便谈</h1><p>在总结自己的技能书的缺点后，决定优先补充自己在计算机网络上知识的漏洞。现在互联网企业，离开了互联网什么都不是。对互联网，普通人可能停留在概念和使用上，而开发人员应该去深入的了解运行进制，进而去优化自己开发的产品。这篇文章，主要是记录自己最近看的一些资料的笔记。<br>&lt;!--more--&gt;  </p>
<p>##IP 协议</p>
<p>IP协议，是网络协议（Internet Protocol）的缩写。IP协议是互联网众多协议的基础。</p>
<p>IP协议实现了解<code>*分组交换网络*</code>。在协议下，每个机器被称为<code>*主机*</code>，IP协议明确了主机之间数据包的传输方式。</p>
<p>数据包，也就是一段二进制数据，包含了传输源的主机的信息。IP协议的特点是<code>*尽力服务*</code>（best effort），提供有效的服务并尽可能的传输。这说明，在传输过程中，可能会丢失数据包，也可能传输了多个相同的数据包。</p>
<p>IP 网络中的主机都配有自己的地址，被称为<code>*IP 地址*</code>。每个数据包中都包含了源主机和目标主机的 IP 地址。IP 协议负责路径计算，即 IP 数据包在网络中的传输传输时，数据包所经过的每一个主机节点都会读取数据包中的目标主机地址信息，以便选择朝什么地方传送数据包。</p>
<p>##蛋疼的IPv4</p>
<p>如今，多数数据包任然使用的是IPv4（版本4），每一个IP地址都是32位的。比如192.168.1.1就是一个IPV4地址。我们可以算下，IPv4有多少个地址。。嗯，好像很多有43亿吗。。但是呢，到了10年的时候，就已经不到8%的了。。</p>
<p>人们发现IPV4不够用啊，快用完了啊，用完了就不能加主机了啊！！！那怎么办，启用新的协议版本啊，所以除了个IPv6，将地址扩充到128位了。比如<code>2001:0db8:85a3:0042:1000:8a2e:0370:7334</code><br>就是一个IPv6的地址了。</p>
<p>128位就是2的128次方个，据说够地球上每个沙子配一个IP了。但是呢，这个协议转换的很慢，目前基本国内的都是还是使用IPv4协议。。看来也不是很着急么。。</p>
<p>##IP数据包的结构<br>一个IP数据包通常包括一个数据头部（header）和有效数据（payload）。有效数据自然是数据包中要传送的数据。而数据头部就是包含了一些传输数据相关的数据。</p>
<p>####我们先来看个IPv4的头部</p>
<p><img src="/media/Screen%20Shot%202015-09-20%20at%2020.15.59.png" alt="Screen Shot 2015-09-20 at 20.15.59"></p>
<p>可以看到，头部信息包含了当前版本的信息，payload采用的协议。Total Length 表明是有效数据加上头部信息长度的总长度。</p>
<p>####在来看看一个IPv6的报头信息</p>
<p><img src="/media/14427519874258.jpg" alt=""></p>
<p>IPv6的头部长度固定到了40.同时IPv6可以链接下一个头部信息（Next Header）。</p>
<p>##数据传输</p>
<p>我们知道，在数据链路层对对所传输的数据帧数有限制，<code>*（MTU，最大传输单元）*</code>。在IPv4的上，使用<code>*分片*</code>来对数据包进行处理。具体来说，我们可以认为如果数据超过了最大传输单元，那么就会将数据切成几片。当数据到达目标主机后，可以根据分片的信息进行重组。当然，发送源可以选择不进行对数据进行<code>*分片*</code>。如果超过了链路层最大传输单元又不进行<code>*分片*</code>的话，发送源就会收到ICMP（Internet Control Message Protocol，Internet报文控制协议）的数据帧超长报告信息。</p>
<p>在IPv6中，如果数据包超过了长度限制，路由会直接丢弃数据包（好狠）并且向ICMP6报告数据帧过长。然后数据源和目标源会根据这个特性来进行<code>路由发现</code>，就是寻找两端之间最大传输单元的路由。找到最大传输单元的路由后，仅当此时数据包任然超过最大传输单元的时候，IPv6才会进行分片。`对于IPv6下的TCP来说，不会造成什么影响。</p>
<hr>
<p>到此，IP协议就到了一个段落了。IP协议是TCP协议的基础，因此了解是必须的。</p>
<p>##TCP协议</p>
<p>TCP协议是重头戏。TCP协议是重头戏。TCP协议是重头戏。重要的事情要说三遍。</p>
<p>上面说了，IP协议是基于<code>尽可能服务</code>的，那么TCP协议就是要基于IP协议，解决IP协议采用的不可靠传输引起的复杂的问题。因此，下面的重点就是来谈谈TCP连接的三个部分：建立连接，传输数据，断开连接的详细过程</p>
<p>####TCP建立连接</p>
<p>首先，我们要知道TCP连接是全双工的,是建立在两个主机之间的。每个连接都存在两种角色：<code>服务器端，监听连接</code>，<code>客户端，主动连接服务器端</code>。客户端主动连接服务器端被称为<code>active open(主动打开)</code>。而服务器端这种监听连接的行为被称为<code>passive open(被动打开)</code>。</p>
<p><strong>三次握手</strong></p>
<p>TCP建立连接是一个确认和反复确认的过程，我们习惯统称为三次握手。这个地方也是几乎所有面试会问的地方，需要注意了。</p>
<p>三次连接，具体的过程有语言描述为以下的过程。</p>
<blockquote>
<ol>
<li>客服端向服务器端发送SYN包和一个随机序列号X，表示本次的连接的身份。</li>
<li>服务器端收到客服端发送的连接的请求以后，发送一个SYN-ACK包和一个确认ack号X+1(确认序列号X的连接请求确认)。此时服务器还会发送一个随机序列号Y，表示向客户端连接的请求。</li>
<li>客户端收到服务器的回复后，会发送一个ACK包，一个确认号Y+1和序列号X+1给服务器。</li>
</ol>
</blockquote>
<p>SYN包，为<code>synchronize sequence numbers (同步序列号)</code>。用于确认两段传输数据的身份，确保数据包最后都达到了应该到的地方。在建立连接的时候，源和目标都需要确认<code>同步序列号</code>。</p>
<p>ACK包，为<code>acknowledgment (确认)</code>。某一端接到数据后，通过回传序列号来确认收到报文。</p>
<p><img src="/media/14428004882999.jpg" alt="三次握手"></p>
<p>####传输数据</p>
<p>建立连接，就是为了传输数据。发送端发出的报文都会带有一个序列号，与当前已传送的字节总数有关。接受端会根据已经接收的报文给发送端传送确认报文，确认信息同样在头部的缩写带的ACK。</p>
<p><img src="/media/14427976037921.jpg" alt=""></p>
<p>注意的整个过程是双向的。两端都会持续的发送数据。X端发送的数据不会等到Y端发送确认后才发送下一个报文。</p>
<p>TCP协议是可靠的传输协议，所以有一系列复杂的机制来进行具体的的拥塞控制。需要处理的问题如下:<code>丢失报文重发</code>，<code>动态调整发送报文的频率</code></p>
<p><strong>流量控制</strong></p>
<p>流量控制的原则就是发送数据的一方的速度不能比接受数据一方的速度要快。接收方，也就是<code>接收窗口</code>会告诉发送方自身<code>接收窗口</code>数据缓冲区的大小。在tcp包，通过两个两个关键的字段可以得出接收窗口的大小:<code>win -- 窗口大小</code>和<code>wscale -- 窗口发大因子</code> 。如果win=65535 , wscale = 4，那么我们可以计算出接收窗口的大小是 64kB * 4 = 256kB。</p>
<p><strong>拥塞控制</strong></p>
<p>拥塞控制相比于流量控制要复杂一些。拥塞控制就是根据当前网络情况计算出当前网络数据传输的最佳速度。首先我们要认识到，最佳速度不一定就是要最快。一方面，我们希望以更快的速度传输数据。另一方面，由于传输的速度过快，导致大量的数据传入会使处理性能受到影响。在分组交换网络中有一个特点就是<code>超负荷崩溃</code>。当负载过大的时候，数据包之间会产生拥塞，直接导致丢包率上升。</p>
<blockquote>
<p>拥塞控制需要充分考虑对流量的影响。RFC 5681 中对 TCP 拥塞控制有 6,000 字左右的阐述。发送方要时刻关注来自接收方的确认信息。要做到这点并不简单，有的时候还需要一定的妥协。要知道底部 IP 协议数据包是无序传输的，数据包会丢失也会重复。发送方需要评估 RTT 往返时间，然后基于 RTT 去确定是否收到了接收方的确认信息。重发数据包也有很大代价，除了连接延迟问题，网络的负载也会发生明显的波动。导致 TCP 需要不停的去适应当前网络情况。</p>
<p>更重要的是，TCP 连接本身是易变的。除了数据传输，连接的两端还会不时的发送一些提醒和确认信息以便可以适当的调整状态来维持连接。</p>
<p>基于这种一直在相互协调中的连接关系，TCP 连接往往会是短暂而低效的。在建立连接的初期，TCP 协议算法还不能完全了解当前网络状况。而在连接将要结束的时候，反馈给发送方的信息又可能不充分，这样就很难对连接状况做出实时的合理的评估。</p>
</blockquote>
<p><em>四次挥手，断开连接</em></p>
<p>建立连接是通过<code>三次握手</code>，而释放连接是通过<code>四次握手</code>。在最下方有图示解释整个过程。那么为什么需要四次握手才能释放连接呢？</p>
<p>上文提到了，TCP是全双工的，因此每个方向上的连接需要单独关闭。这个原则就是当一方没有数据可以传送的时候，发送FIN来终止这一方的连接，但是另一方向上的数据仍然可以发送。当另一方向也发送了FIN的时候，整个连接才完全的关闭了。无论服务器端还是客户端都可以发送来FIN来主动关闭连接。</p>
<p><img src="/media/14428004433668.jpg" alt="四次挥手"></p>
<p>##HTTPS</p>
<p>之前的博文谈到了HTTP（超文本传输协议）。如今苹果操作系统iOS也升级到了iOS9。在iOS9中强制所有网络传输协议使用HTTPS。看来对HTTPS的了解是势在必行的了。</p>
<p>HTTPS,实际上可以看作HTTP的加密版本。HTTPS将HTTP协议数据包放到SSL/TSL层加密后，在TCP/IP蹭去传输。到了目标源后，在SST/TSL将数据包解密，传递到HTTP层就是普通的HTTP数据包了。</p>
<p>HTTPS = HTTP + SSL/TSL</p>
<p><strong>SSL/TSL</strong></p>
<p>关于SSL/TSL，我们可以参考下面两篇文章：</p>
<p>!<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>
<p>!<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a></p>
<p>简单的来说，通过SSL/TSL四次握手，来解决下面三个问题。</p>
<ol>
<li>数字证书：该证书包含了公钥等信息，一般是由服务器发给客户端，接收方通过验证这个证书是不是由信赖的CA签发，或者与本地的证书相对比，来判断证书是否可信；假如需要双向验证，则服务器和客户端都需要发送数字证书给对方验证；</li>
<li>三个随机数：这三个随机数构成了后续通信过程中用来对数据进行对称加密解密的“对话密钥”。<br>首先客户端先发第一个随机数N1，然后服务器回了第    二个随机数N2（这个过程同时把之前提到的证书发给    客户端），这两个随机数都是明文的；而第三个随机    数N3（这个随机数被称为Premaster secret），    客户端用数字证书的公钥进行非对称加密，发给服务    器；而服务器用只有自己知道的私钥来解密，获取第    三个随机数。这样，服务端和客户端都有了三个随机    数N1+N2+N3，然后两端就使用这三个随机数来生    成“对话密钥”，在此之后的通信都是使用这个“对话    密钥”来进行对称加密解密。因为这个过程中，服务端    的私钥只用来解密第三个随机数，从来没有在网络中    传输过，这样的话，只要私钥没有被泄露，那么数据    就是安全的。</li>
<li>加密通信协议：就是双方商量使用哪一种加密方式，假如两者支持的加密方式不匹配，则无法进行通信；</li>
</ol>
<p>具体的可以参考上面两篇文章的内容，去了解SSL/TSL加密的过程。在这里想重点说的是在iOS中使用HTTPS。</p>
<p>在iOS中，常用的是<code>NSURLConnection</code>支持HTTPS的实现。而常用的第三方库<code>AFNetworking</code>封装了使用<code>NSURLConnection</code>实现的逻辑代码，更加完善。在<code>AFNetworking</code>中使用的方法如下</p>
<pre><code>Objective-C

NSURL * url = [NSURL URLWithString:@&quot;https://www.google.com&quot;];
AFHTTPRequestOperationManager * requestOperationManager = [[AFHTTPRequestOperationManager alloc] initWithBaseURL:url];
dispatch_queue_t requestQueue = dispatch_create_serial_queue_for_name(&quot;kRequestCompletionQueue&quot;);
requestOperationManager.completionQueue = requestQueue;

AFSecurityPolicy * securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];

//allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO
//如果是需要验证自建证书，需要设置为YES
securityPolicy.allowInvalidCertificates = YES;

//validatesDomainName 是否需要验证域名，默认为YES；
//假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。
//置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。
//如置为NO，建议自己添加对应域名的校验逻辑。
securityPolicy.validatesDomainName = YES;

//validatesCertificateChain 是否验证整个证书链，默认为YES
//设置为YES，会将服务器返回的Trust Object上的证书链与本地导入的证书进行对比，这就意味着，假如你的证书链是这样的：
//GeoTrust Global CA 
//    Google Internet Authority G2
//        *.google.com
//那么，除了导入*.google.com之外，还需要导入证书链上所有的CA证书（GeoTrust Global CA, Google Internet Authority G2）；
//如是自建证书的时候，可以设置为YES，增强安全性；假如是信任的CA所签发的证书，则建议关闭该验证，因为整个证书链一一比对是完全没有必要（请查看源代码）；
securityPolicy.validatesCertificateChain = NO;

requestOperationManager.securityPolicy = securityPolicy;
</code></pre><p>##杂谈</p>
<p>关于连接。TCP连接容易在两个地方出问题：初始设置，以及通过连接传输最后一部分的内容。</p>
<hr>
<p>建立连接的时候，TCP由于要进行三次握手，所以在这过程中会有一定的时间损耗。一般一个移动终端向服务发送一个数据包普遍需要250ms, 三次握手的话就是需要750ms。而在HTTPS中则更加夸张。因为HTTPS需要四次握手。。。嗯，在TCP和HTTPS都握手完后，大概需要1750ms.是建立一个HTTP连接的两倍。为了安全，就肯定要牺牲时间效率。</p>
<p>此外，由于TCP需要侦测当前最佳的转发路由，所以在传送大量的数据时，需要不停地去调整以便得到最佳速度。这种算法被称为<code>慢启动</code>。注意到，慢启动在数据链路层传输质量差的网络上表现的更差，无线网络就是典型的例子。(4G说，怪我咯)。</p>
<hr>
<p>通过TCP释放连接的过程，我们也知道可能存在问题</p>
<blockquote>
<p>如果发送方完成数据发送，接受方自然会停止发送 ACK 确认。在最后四个报文传输的过程中，快速重发算法是没有办法处理这四个报文的数据包的丢失问题的（因为不会收到三个相同的确认 ACK，所以不能界定传输丢包）。在常规网络环境下，四个数据包相当于 5.7kB 的数据规模。总之，在这最后 5.7kB 的传输的过程中，快速重发机制是无效的。针对这种情况，TCP 会启用其他机制来侦测丢包问题。对于这种情况，重传操作可能要消耗几秒钟去执行，这并不奇怪</p>
</blockquote>
<hr>
<p><em>超时处理</em></p>
<p>在APP实际处理中，经常发生网络请求超时的现象。许多APP大概在15秒后收不到反馈就会提示超时信息。这种设计其实并不是很友好。我们知道，只有TCP连接还在，TCP都会保证将请求发送出去并会等待响应的返回，只是时间长短的问题。</p>
<p>个人在这里参考了一些APP的做法，觉得应该在每次请求的时候设置一个计时器，当计时器到达倒数完成后，可以提示用户是否继续网络请求，如果取消就将TCP连接断开，如果继续就继续等待网络请求响应。</p>
<p>##最后</p>
<p>了解了IP TCP HTTPS后，接下来想阅读一些文章怎么从这些方面入手去优化网络请求。在互联网时代，数据和网络是承载产品的基础。因此，网络，怎么深入学习都不过分。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Network/">Network</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-interview-9-dot-14" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/14/interview-9-dot-14/" class="article-date">
  	<time datetime="2015-09-14T15:22:57.000Z" itemprop="datePublished">2015-09-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/14/interview-9-dot-14/">面试小计 9.14</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天是人生第二次面试。约的公司十一点半。十一点就到了公司楼下。公司所在的地方到家里不远，曾经这里也是充满了许多童年的记忆。想不到过了十几年，自己也会来这里面试，也有可能在这里工作，想想一切都充满许多有趣的偶然。</p>
<p>谈起面试，这只是第二次面试。第一次面试让我感觉非常不好，受到了不小的打击，然而不知道为何现在的公司会收留我做实习生（难道是我长的很适合程序员？）经过了半年的实习经历，踏过了许多以前完全想不到的坑，有了一定的收获，但是这次面试还是有些紧张。相比于第一次面试，我对自己的不足有了更多的认识，也就担心了更多，后面发现我担心是对的，但是担心的点完全不对。。</p>
<p>上了楼，被HR妹子领到一个卡座等待面试。不得不说这个公司的环境要比我的现在的实习公司好了不是一个量级，连拿给我的矿泉水都很高级。。等了大概有五分钟到十分钟，来了个哥们，一看上去就是很厉害的程序员（的确我发现厉害的程序员在长相上都能体现出来）。先自我介绍了一下。由于HR那边只有拉勾网的简历，实在是太普通，所以我把自己带的简历从新给面试官看了下。面试官开始说他也不是负责iOS的（当时内心一惊，我其实很怂考算法和数据结构这种所谓的基础- -）</p>
<p>然后开始聊了下自己现在在公司所做的项目。用电脑展示了一下，开始问第一个问题就是自己负责的了哪些功能，答UI和后台都有设计。然后问了一下一些UI设计的问题，接着就提出一个我刚好思考过的问题：UITableView在网络请求的时候加载图片如何保证流畅性。这个问题刚好周末也和同事讨论过问题，之前也有在网上查了一些不同人思考，就讲了下自己的见解，大概就是通过异步的方式，将UI刷新和图片读取放入不同的线程，通过判断滑动状态来决定是否更新UI。然后他提出我的解决方案中存在的一个问题：如果快速的滑动，只会显示一些预设的空白图片，这样不利于用户去搜索的一个固定的目标。这个问题我回答的时候缺乏了思考，我回答的是通过网络异步请求加载，在前几个屏的Cell延后显示，同时将图片下载预存，快速滑动的时候将新滑入屏幕的cell进行设置图片。后来想来其实有个更讨巧的方法，就是通过分页，控制一次刷新的cell的数量，就避免了用户快速滑动的情况出现。</p>
<p>对于项目，由于面试官也不是做iOS开发的，所以就没设计到一些我准备很久的题目，随后他提出了在项目中是如何与后台联调的。这个问题的许多地方我只知道一些概念，所以理解上有点偏差，但是总体还是回答出来了。</p>
<p>然后面试官随后话锋一转开始问HTTP协议。好险之前抽空整理了HTTP相关知识。HTTP协议必问状态码，在解释了状态码的分类和一些常见的状态码后，他问了我3XX状态码的问题。。怕什么来什么，虽然我记得3XX状态码的归类，但是具体到细节上还是有些遗忘（果真必须什么都要掌握啊）。回答稍微差了一点。</p>
<p>随后面试官问了网络优化的问题。这个问题我感觉比较广泛，不是很好回答，面试官也说不仅限于服务器或者客户端。大概谈了一下自己在项目中的一点想法，特别是当网络服务不好的时候，如何去制造一些交互让用户减少对网络不良造成的影响产生不好反应的可能。然后面试官放了大招 – 请你谈谈网络安全问题。。。当时真的有点慌了，因为和自己准备的东西偏差有点大。随后就从自己的角度谈了下常规的网络攻击的问题。然后。。。然后问了我SQL注入。。这个我真的只是听说啊，臣妾做不到啊。。。</p>
<p>后面还问了一些项目体会，一些经历。。还考了下指针环的判断和一个小球掉落的题目。。那个小球掉落的题目不知道答案应该是什么，感觉就是一个二分查找。。应该问下面试官他的答案的。</p>
<p>到此，第一个面试官问完，走了出去，松了口气，缓一缓。。压力很大，因为和自己想的有点偏差，即使考数据结构和算法都没这样。。因为是没有心理准备。</p>
<p>大概等了有十分钟。来了第二个面试官，上来换了个座位，然后开始让我简单的自我介绍。然后问了下在校成绩和在校所做的项目。。这时候我就有点忧伤了，因为在笑的项目最大的是就是学院的薪资管理系统，但是这个项目时间比较久了而且记忆的东西不多了（所以同学们一定要写自己有把握的项目啊）。然后出了个SQL题目让我写。。。比较没把握的写了，然后提出自己在项目中用的是Hibernate框架，在这个方向上可能不是很对。在之后就是聊天了，大概就是介绍公司的一些状况，一些学习的途径，还问我来深圳工作是否会错过学校的校招，不考研的原因是什么。在这些问题上我都有自己的想法也就简单说了下。最后问我了下现在公司的情况，薪资问题。。然后就问我有事很么了解的（这算过了还是没过。。）然后讨论了一些我在现在公司开发的遇到的坑。。感觉两个面试官能力都很强，思维能力的确看得出来的不一样。最后出来已经是12点15了。</p>
<p>总结这次面试，作为一个应届生应该有更扎实的基础和全面的知识。自己近半年的精力都放在了iOS上，面对一些问题已经很生疏了，但是这不是抛弃其他知识的理由。第二个面试官也谈到了，广泛的涉猎，单一的深入，才能长久的在技术的路上走下去。最后还是希望进入这家公司，无论从环境上还是见到的人上都觉得非常不错。。当然希望自己的薪资也能高一点。</p>
<p>进和没进，都会更新一下。</p>
<hr>
<p>最终担心了两天，还是过了！希望能够在新的团队里面学到更多的知识。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-socket" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/13/socket/" class="article-date">
  	<time datetime="2015-09-12T21:27:26.000Z" itemprop="datePublished">2015-09-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/13/socket/">socket</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##写在前面</p>
<p>最近一直在找更好的实习，发现网络编程是一个优秀的程序员必备的技能。而自己在学校中学到的东西很少（逃。要不是有之前的实习和做个一个小小的项目，对于很多知识可能还只是停留在书本上（其实就是没进脑）。最近有人问我是否了解socket，我顿时语塞。对与socket的认识还是学习java的时候知道可以使用socket进行客户端与服务器端的通信，可是当时并没有去实践。欠下的债都是要还的。</p>
<p>此外为什么我每篇博文的开头都写点自己的感受。我觉得博客不仅仅是记录自己的技术积累，也是抒发自己心情的一个途经，所以我会在每篇文章前面写一点点自己在写博文的时候的心情。<br>&lt;!--more--&gt;  </p>
<p>##正文</p>
<p>socket，套接字，是基于TCP/IP协议族下的一种网络通信方式。我们知道，在本地，进程之间有多种方法去通信。在网络中，我们同样可以使用socket进行通信。接下来一步步来看socket是如何使网络上的进程相互通信的。</p>
<p>我们知道，要像让进程通信，首先必须确认进程的身份。如同我们只有知道了和自己谈话的是谁，我们才知道谈什么。在本地，进程拥有唯一的标识PID。在网络上，基于TCP/IP协议，通过<em>IP，协议，端口号</em>，我们可以确认一个进程的唯一身份。</p>
<p>使用TCP/IP协议的应用程序通常采用应用编程接口，有本文讲到的socket（套接字）和TIL（被淘汰了）。目前而言，绝多大数的应用程序都是基于socket进行网络通信的，所以了解socket是一个程序员必备的。</p>
<p>##scocket 究竟是什么</p>
<p>socket起源于UNIX。我们知道UNIX的设计原理就是<em>一切皆文件</em>，操作都是<em>open -&gt; read/write -&gt; close</em>。所以说，我们可以认为socket也是一个文件，是基于上述设计原理的实现。socket函数就是专门来完成相应操作的。</p>
<p>##socket 操作</p>
<p>在上面我们知道了socket是一个文件，那么socket自然有对应的操作方法，下面是基于TCP的几个基本操作。<br>(注，本文的方法是使用Objective-C写的，其实socket在任何语言都是差不多的)</p>
<pre><code class="objective-c">
// 创建并初始化socket，返回socket的文件描述符，如果返回值为-1则创建失败
int socket(int addresFamily, int type, int protocol)

// 关闭socket
int close(int socketFileDescriptor)

// 将socket与特定的IP地址和端口号绑定，成功返回0，失败返回-1
int bind(int socketFileDescriptor, sockadd *addressToBind)

// 接受客户端的请求并且将客户端的网络地址信息存入clientAddress
// 当客户端的连接请求被接受后，双方的通信链路就建立好了，两者就可以开始通信了。

int accept(int socketFileDescriptor, sockaddr *clientAddress, int clientAddressStructLength)

// 客户端向特定的IP的服务器发送连接请求，成功返回0，失败返回-1
// 当服务器建立好后，客户端就可以通过这个函数与服务器端建立连接。
// 对于UDP来说，该接口是可选的，如果调用了这个接口表明设置了UDP socket默认的网络地址.
// 对于TCP来说，这里就是三次握手发生的地方

int connect(int socketFileDescriptor, sockaddr *serverAddress, int serverAddressLength)

// 通过DNS查找特定的IP，如果找不到返回NULL
hostent *gethostbyname(char *hostname)

// 发送数据，发送成功后返回成功发送的字节数，否则返回-1
int send(int socketFileDescriptor,char *buffer, int flags)

// 接收数据，成功后返回成功读取的字节数，否则返回-1
int receive(int socketFileDesciptor,char *buffer,int flags)

// 下面两个方法是UDP的方法

// UDP发送,返回状态同上
int sendto(int socketFileDesciptor, char *buffer, int bufferLength, int flags, sockaddr *destinationAddress, int destinationAddressLength)

// UDP读取，返回状态同上
int recvfrom(int socketFileDesciptor, char *buffer, int bufferLength, int flags, sockaddr *fromAddress, int fromAddressLength)
</code></pre>
<p>通过观察方法，我们发现socket其实就是<em>确认目标 -&gt;建立连接 -&gt; 传送/读取 -&gt; 断开</em> 的过程</p>
<p>我们再来看看TCP和UDP下socket操作的不同的地方</p>
<p>####TCP</p>
<p><img src="http://www.coderyi.com//qiniu/429/image/5269612b25e6df1b3ee5ab8352b2c3b6.jpg" alt="TCP"></p>
<p>####UDP<br><img src="http://www.coderyi.com//qiniu/429/image/cd6d1690d3d6eefd300987e590c1483f.jpg" alt="UDP"></p>
<p>##最后</p>
<p>到此，对于socket编程的概念有了个一个初步的认识了。在实际开发中，我们一般不会直接调用这些底层的API。借助于一些开源的第三方库更有利于项目的开发运行。不过，对于基本的理论知识还是必须要掌握的。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Network/">Network</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-gcd" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/12/gcd/" class="article-date">
  	<time datetime="2015-09-12T13:16:43.000Z" itemprop="datePublished">2015-09-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/12/gcd/">GCD小结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#写在最前面</p>
<p>最近发现自己学东西的效率好像高了，难道是因为写博客做笔记的原因吗？的确通过写博客来记录自己学习的成果能够加强自己对很多问题的理解。只有能够通过自己的语言将学习到的内容讲出来才是真的理解。所以以后看来要多写写。<br>&lt;!--more--&gt;  </p>
<p>#正文</p>
<p>##GCD是什么鬼</p>
<p>GCD，简单的来说就是苹果自己出的一套多核运算的解决方案。虽然苹果没有安卓那么多核心，但是并行化运算能够提高流程性是不可争辩的事实。GCD内部自动管理线程 的生命周期，不需要我们自己去手动管理。我们只需要调用对应的API就可以了。GCD是基于C语言开发的，不过由于使用了block，所以使用起来很方便。在了解GCD之前，我们需要了解一点多线程运行的原理。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>GCD中有两个重要的概念：<em>任务</em> 和 <em>队列</em></p>
<ol>
<li>任务。我们可以理解任务就是一个动作，放在GCD中就是一个代码块（block）。执行任务有两种，分别为<em>同步执行</em> 和 <em>异步执行</em>。同步和异步的区别其实很好理解。<code>同步执行</code>既是当前任务执行完前会阻塞当前进程，<code>而异步执行</code>就不会。</li>
<li><p>队列。队列是用来存放任务的。我们可以理解为任务就是队列中排队等待执行。队列分为<em>串行队列</em>和<em>并行队列</em>。</p>
<ul>
<li>串行队列，就像排队一样，严格遵守FIFO。</li>
<li>并行队列，同样执行FIFO。不同的是，取出来的任务会根据情况放到别的线程上。由于多个线程出队的时间间隔可能很短，所以容易认为是非FIFO的。不过即使这样，系统也会根据硬件条件来判断，并不一定会所有任务都在同时执行。</li>
</ul>
<hr>
<p>创建队列的操作如下图所示</p>
<p><img src="http://i3.tietuku.com/045e13ec06064ef3.png" alt="queue"></p>
<hr>
<p>创建任务如下如图所示</p>
<p><img src="http://i3.tietuku.com/b2ef139ced93771f.png" alt="task"></p>
</li>
</ol>
<h4 id="队列组"><a href="#队列组" class="headerlink" title="队列组"></a>队列组</h4><p>  对列组就是将多个队列添加到一个组里。这样的方式使我们可以在队列里所有的任务都完成后收到一个通知方法。</p>
<pre><code>  objective-c

  // 创建队列组
    dispatch_group_t group = dispatch_group_create();

    dispatch_group_async(group, globalQueue, ^{
      for (NSInteger i = 0; i &lt; 3; i++)
      {
          NSLog(@&quot;group - queue - %@&quot;, [NSThread currentThread]);
      }
    });
</code></pre><h2 id="NSOperation-和-NSOperationQueue"><a href="#NSOperation-和-NSOperationQueue" class="headerlink" title="NSOperation 和 NSOperationQueue"></a>NSOperation 和 NSOperationQueue</h2><p>  NSOperation 和 NSOperationQueue是苹果对GCD的基于面向对象的完全封装，使其更容易理解。操作方式也更简单</p>
<ol>
<li>将要执行的任务封装到一个<code>NSOperation</code>对象中</li>
<li><p>将任务添加到一个<code>NSOperationQueue</code>中</p>
<p>此后系统将自动在执行任务。</p>
</li>
</ol>
<h3 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h3><p> 由于NSOperation是一个抽象类，所以不能直接封装任务。但是有两个子类用于封装任务：<code>NSInvocationOperation</code> 和 <code>NSBlockOperation</code>。创建一个队列后，需要调动<code>start()</code>方法来启动，<em>默认在当前队列同步执行</em>。同时队列提供<code>cancel()</code>方法在中途取消任务。</p>
<ul>
<li>NSInvocationOperation 传入一个方法名。</li>
<li>NSBlockOperation 传入一个代码块。<ul>
<li>在NSBlockOperation中，有一个方法<code>addExecutionBlock</code>方法。这个方法使我们可以添加多个block到队列中。<em>这些block将会并发执行**，将在</em>主线程和其他的多个线程``执行任务</li>
</ul>
</li>
</ul>
<p>###添加队列</p>
<p>   多数时候，我们不希望当前线程被占用，因为会影响到UI的流畅性（UI永远在主线程上）。因此我们需要创建新的队列。只要我们添加任务到队列上，就会自动调用任务的<code>start()</code>方法。如果任务在其他队列上，那么他就会在其他线程上并行执行。</p>
<p>   我们发现，<code>NSOperationQueue</code>并没有设置串行和并行队列的问题，那么<code>NSOperationQueue</code>是怎么确定队列的类型的呢。苹果通过封装巧妙的使调用者不需要特意的去注意队列的性质，只需要设置<code>NSOperationQueue</code>中的<code>maxConcurrentOperationCount</code> – 最大并发数就可以了。</p>
<p>##总结</p>
<p>   在上篇block的文章中也谈到了block在gcd的中的应用。通过gcd，我们可以最大化的去使用硬件的性能，避免出现卡顿的现象。多线程用的好不好，也基本上代表了一个开发者的能力水平。虽然多线程编程有许多坑，但只有跨过一个个坑，才能变成大牛，不是吗？</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Objective-C/">Objective-C</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-http" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/10/http/" class="article-date">
  	<time datetime="2015-09-10T15:46:08.000Z" itemprop="datePublished">2015-09-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/10/http/">HTTP学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#HTTP学习</p>
<p>HTTP协议是网络中最广泛的协议之一，对HTTP协议的了解应该是每一个和网络打交道的程序员必须具备的技能。很多公司面试都要求对网络知识有一定的了解，一个是TCP/IP协议，一个就是HTTP协议，HTTP协议应用层的协议，内容比较少，这周花时间去总结了一下，做一个备忘。<br>&lt;!--more--&gt;  </p>
<p>##HTTP简单分析</p>
<p>HTTP是一个基于请求/响应模式的、无状态的协议。即，浏览器与服务端连接之后，浏览器向服务器发送一个请求，服务器返回响应信息之后，双方的链接就被关闭。</p>
<p>HTTP1.0是典型的请求/响应模式。</p>
<p>HTTP1.1在1.0的基础上进行了改进，加入了“持续连接”的机制。通过这种机制，客户端发送请求得到响应后，连接不会马上关闭，可以继续发送请求，还可以流水线发送多个请求、而不用等待每一个响应的到来。</p>
<ul>
<li>URI和URL<ul>
<li>URL我们应该是很熟悉的了，全名是统一资源定位符，包含了需要查找的信息的资源。</li>
<li>而URI是URL的父集，纯粹是一个WEB的资源符号</li>
</ul>
</li>
</ul>
<h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><p><img src="http://i3.tietuku.com/2c834f74cd465d7e.png" alt="HTTP Request"></p>
<p>简单的来说 HTTP请求可以分为三部分</p>
<ol>
<li>请求行</li>
</ol>
<ol>
<li>消息报头</li>
</ol>
<ol>
<li>请求正文</li>
</ol>
<p>###请求行</p>
<hr>
<p>请求行主要的内容是是请求方法和请求的位置（URL）</p>
<p>请求方法主要有以下几种方法（注意方法都是全部字母大写）</p>
<p><img src="http://i3.tietuku.com/05fa7108f6959f91.png" alt="HTTP Request method"></p>
<p>在APP中，最多用的到的就是POST 和 GET 两种方法。许多地方都要求区别两者的区别，所以在这里做一下重点笔记对比两者方法的不同</p>
<p>（在这里小小的吐槽，在学校计算机网络的学习中，POST和GET的区别基本就是一句话：POST比GET更好更安全。其实在查阅了许多资料后，发现并没有那么简单）</p>
<hr>
<p>####POST</p>
<ul>
<li>根据HTTP规范，POST表示可能修改服务器上的资源的请求，比如提交表格，注册等等都是常用POST</li>
</ul>
<ul>
<li>POST将请求的正文包在HTTP包体中</li>
</ul>
<ul>
<li>POST没有大小限制</li>
</ul>
<hr>
<p>####GET</p>
<ul>
<li><p>GET操作，根据HTTP规范，仅仅用于信息获取，而且是应该是安全的幂等。</p>
</li>
<li><p>GET操作会将请求的数据附在URL后面，参数之间以&amp;相连（这就是为什么很多人认为GET不安全了）</p>
</li>
</ul>
<ul>
<li>GET的数据限制，由于浏览器或者服务器可能会对URL存在长度限制，所以有可能会产生影响</li>
</ul>
<p>通过对比，我们发现常见的误区有两个</p>
<ol>
<li>POST比GET更安全。通过上面对比，我们发现，虽然POST没有将参数直接放在URL中，但是通过抓包的手段，我们依然可以获得HTTP包体中的参数。由此看来，想依靠POST就简单保证安全是不可能的。</li>
</ol>
<ol>
<li>POST能比GET传输更多。通过上面的叙述也可以得知，其实HTTP协议本身没有进行限制，POST和GET都没有大小限制，而是第三方的浏览器和服务器造成了差别</li>
</ol>
<p>什么时候用POST，什么时候用GET，我们要依据不同的使用场景来区分。如果有缓存的需求，那自然就不能用POST方法。如果必须要用表格，GET也不行了。</p>
<h2 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h2><p>请求响应类似与请求。如图所示</p>
<p>可以看到，HTTP响应的第一行叫状态行，包含了HTTP版本，状态码，状态描述信息。</p>
<p>状态码是判断请求状态的重要标志，由三位数字组成，有五种定义：</p>
<ol>
<li>1XX —- 请示信息，表示请求已经接受，可以继续处理</li>
<li>2XX —- 成功状态，表示请求被服务器接受</li>
<li>3XX —- 重定向，要完成请求的话需要更进一步的操作</li>
<li>4XX —- 客户端错误，请求错误或者请求无法被实现</li>
<li>5XX —- 服务器端错误，服务器未能完成合法的请求</li>
</ol>
<p>全部取值如下：</p>
<blockquote>
<pre><code>    100——客户必须继续发出请求
   101——客户要求服务器根据请求转换HTTP协议版本


     200——交易成功
    201——提示知道新文件的URL
    202——接受和处理、但处理未完成
    203——返回信息不确定或不完整
    204——请求收到，但返回信息为空
    205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
    206——服务器已经完成了部分用户的GET请求

      300——请求的资源可在多处得到
    301——删除请求数据
    302——在其他地址发现了请求数据
    303——建议客户访问其他URL或访问方式
    304——客户端已经执行了GET，但文件未变化
    305——请求的资源必须从服务器指定的地址得到
    306——前一版本HTTP中使用的代码，现行版本中不再使用
    307——申明请求的资源临时性删除

     400——错误请求，如语法错误
    401——请求授权失败
    402——保留有效ChargeTo头响应
    403——请求不允许
    404——没有发现文件、查询或URl
    405——用户在Request-Line字段定义的方法不允许
    406——根据用户发送的Accept拖，请求资源不可访问
    407——类似401，用户必须首先在代理服务器上得到授权
    408——客户端没有在用户指定的饿时间内完成请求
    409——对当前资源状态，请求不能完成
    410——服务器上不再有此资源且无进一步的参考地址
    411——服务器拒绝用户定义的Content-Length属性请求
    412——一个或多个请求头字段在当前请求中错误
    413——请求的资源大于服务器允许的大小
    414——请求的资源URL长于服务器允许的长度
    415——请求资源不支持请求项目格式
    416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段
    417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求

       500——服务器产生内部错误
    501——服务器不支持请求的函数
    502——服务器暂时不可用，有时是为了防止发生系统过载
    503——服务器过载或暂停维修
    504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长
    505——服务器不支持或拒绝支请求头中指定的HTTP版本



</code></pre></blockquote>
<p>常见的错误主要有400 404 403 500 503等等</p>
<p>相应正文，包含了请求获得的资源，有HTML文件，JSON格式数据，文件的URL等等</p>
<h3 id="消息报头"><a href="#消息报头" class="headerlink" title="消息报头"></a>消息报头</h3><hr>
<p>HTTP请求和HTTP响应都有消息报头。而消息报头是由众多报头域组成。每一个报头域都由名字＋“：”＋空格组成，消息报头域的名字是大小写无关的。</p>
<p>HTTP消息报头包括普通报头、请求报头、响应报头和实体报头。</p>
<hr>
<h4 id="普通报头："><a href="#普通报头：" class="headerlink" title="普通报头："></a>普通报头：</h4><p>在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。</p>
<p>常见的普通报头：</p>
<p>1）Cache-Control</p>
<pre><code>Cache-Control用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。

请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;
响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.


</code></pre><p>2）Date</p>
<pre><code>Date普通报头域表示消息产生的日期和时间


</code></pre><p>3）Connection</p>
<pre><code>Connection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接


</code></pre><hr>
<h4 id="请求报头"><a href="#请求报头" class="headerlink" title="请求报头"></a>请求报头</h4><p>请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。<br>（在APP中，一些身份验证的信息可能需要在header中添加）</p>
<p>常见的请求报头：</p>
<p>1)Accept</p>
<pre><code>Accept请求报头域用于指定客户端接受哪些类型的信息。


</code></pre><p>2)Accept-Charset</p>
<pre><code>Accept-Charset请求报头域用于指定客户端接受的字符集。如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。


</code></pre><p>3）Accept-Encoding</p>
<pre><code>Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。


</code></pre><p>4）Accept-Language</p>
<pre><code>Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。


</code></pre><p>5）Authorization</p>
<pre><code>Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。


</code></pre><p>6）Host</p>
<pre><code>发送请求时，该报头域是必需的。Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。


</code></pre><p>7）User-Agent</p>
<pre><code>User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。


</code></pre><hr>
<h4 id="响应报头"><a href="#响应报头" class="headerlink" title="响应报头"></a>响应报头</h4><p>响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。</p>
<p>常见的实体报头：</p>
<p>1）Location</p>
<pre><code>Location响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。


</code></pre><p>2）Server</p>
<pre><code>Server响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。


</code></pre><p>3）WWW-Authenticate</p>
<pre><code>WWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。


</code></pre><hr>
<h4 id="实体报头"><a href="#实体报头" class="headerlink" title="实体报头"></a>实体报头</h4><p>请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。</p>
<p>实体报头包括：</p>
<p>常见的实体报头：</p>
<p>1）Content-Encoding</p>
<pre><code>Content-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding主要用于记录文档的压缩方法。


</code></pre><p>2）Content-Language</p>
<pre><code>Content-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言

</code></pre><p>阅读者。</p>
<p>3）Content-Length</p>
<pre><code>Content-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。即一个数字字符占一个字节，用其对应的ASCII码来存储传输。


</code></pre><p>4）Content-Type</p>
<pre><code>Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。


</code></pre><p>5）Expires</p>
<pre><code>Expires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。


</code></pre><p>6）Last-Modified</p>
<pre><code>Last-Modified实体报头域用于指示资源的最后修改日期和时间。


</code></pre><p>##总结</p>
<p>HTTP协议的内容不是多，常用的内容就几个，但是需要非常熟悉，因为HTTP协议是网络交互重要的协议之一。</p>
<p>接下来花一些时间去回顾TCP/IP协议，内容多就会有几篇文章来记录学习的一些笔记心得。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Network/">Network</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-block" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/07/block/" class="article-date">
  	<time datetime="2015-09-07T09:25:40.000Z" itemprop="datePublished">2015-09-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/07/block/">block</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##Block是个什么</p>
<p>和kvo/kvc一样，block的使用也是我在学习Objective-C的过程中碰到的一个大拦路虎。第一遍过语法的时候并没有太注意这部分的内容。而到了后面阅读各类大神的源码的时候，发现block的应用非常多。而对这块内容的疏忽导致自己一直不能很顺利的阅读各类代码，在项目中也是一知半解的应用，所以在这里想总结下。<br>&lt;!--more--&gt;  </p>
<p>###Blcok 是什么</p>
<p>block是在iOS SDK 4.0引入的黑魔法。从他诞生的时候，Apple就倾注了大量的心血。字面上看，block就是一个代码块。在许多语言中都可以看到相似的语法设计。但是block自身由于可以在内联执行的时候还可以传递参数，同时自身可以作为参数在函数之间来传递，所有有了许多神奇的用法（好吧是我觉得很神奇）</p>
<p>一个典型的block的应用如下</p>
<pre><code class="Objective-C"> BOOL (^isName)(NSString *) = ^(NSString *name) {
      if ([name isEqualToString:@&quot;csb&quot;])
      {
          return YES;
      }
      else
      {
          return NO;
      }
    };
</code></pre>
<p>定义一个block开头是和函数一样是返回类型，（^）跟着是block的名字，后面跟着是传入的数据类型。括号里面是代码块。</p>
<p>一个完整的例子</p>
<pre><code class="Objective-C">
- (void)blockTest
{
    BOOL (^isName)(NSString *) = ^(NSString *name) {
      if ([name isEqualToString:@&quot;csb&quot;])
      {
          return YES;
      }
      else
      {
          return NO;
      }
    };

    self.sark.name = @&quot;csb&quot;;
    NSLog(@&quot;is csb ? %@&quot;, isName(self.sark.name) ? @&quot;yes&quot; : @&quot;no&quot;);
}
</code></pre>
<p>那么block有什么特别之处？前面提到了，block能够使用block外的参数，我们来实验下</p>
<pre><code>- (void)blockTest
{
    NSString *csbName = @&quot;csbzhixing&quot;;
    BOOL (^isName)(NSString *) = ^(NSString *name) {
      if ([name isEqualToString:csbName])
      {
          return YES;
      }
      else
      {
          return NO;
      }
    };

    self.sark.name = @&quot;csbzhixing&quot;;
    NSLog(@&quot;is csb ? %@&quot;, isName(self.sark.name) ? @&quot;yes&quot; : @&quot;no&quot;);
}
</code></pre><p>输出<br><code>2015-09-07 16:48:25.452 CSBRepository[83032:1549339] is csb ? yes</code></p>
<p>注意到，定义了block后，修改了block中引用的局部变量，那么block中的局部变量仍然会保持不变。</p>
<p><img src="http://i3.tietuku.com/a60eb087f6bfd358.png" alt="pic1"></p>
<p>好吧，如果我们的确有这个需求怎么弄呢？使用<code>_block</code>修饰符来修饰局部变量可以解决这个问题</p>
<p><img src="http://i3.tietuku.com/ba1814837f233066.png" alt="pic2"></p>
<p>block调用实例变量，这个没有好说的。。直接用就是了。</p>
<p>##小小的问题，循环引用</p>
<p>需要注意的一个问题是block的retain cycle问题，即循环引用。</p>
<p>如果要细究这个问题，要回到老生常谈的引用计数的问题上。有许多很详细的文章解释了为何存在这种问题，在这里我只简单的谈下我的理解。</p>
<p>retain cycle的问题根源在于block和object可能会互相强引用，互相retain了对方，这样就导致了retain cycle的问题。到了最后就发现两者谁也释放不了谁，导致了崩溃。（你不让我，我不让你怎么行）。</p>
<p>解决的方法就是打破这种循环，使用弱引用。这点可以参考最有名的第三方库AFNetworking的源码，在block上afn的写法最值得参考学习。</p>
<p>##Block该用在什么地方</p>
<p>在项目中，主要应用block的地方有场景之间的数据传输，UI刷新，网络请求等等。在参考官方的建议和大神的博客后，总结了一下几个方面</p>
<ol>
<li>枚举 – 通过block获取对象和控制枚举进程</li>
<li>View动画 – 规定动画，参考官方的demo可以很快的了解</li>
<li>通知 – 事件完成后执行block内的代码，比如网络请求成功后</li>
<li>完成 – 同上</li>
<li>GCD多线程 – 这个是下一篇想要去了解学习的内容</li>
<li>错误处理 – 错误发生的时候执行</li>
<li>排序 </li>
</ol>
<p>深入学习block还有很多的内容，比如block是怎么实现，block的类型等等。这里只是我目前学习的一个小结，有机会还要再深入的学习。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Objective-C/">Objective-C</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-kvo-kvc" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/07/kvo-kvc/" class="article-date">
  	<time datetime="2015-09-07T03:50:52.000Z" itemprop="datePublished">2015-09-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/07/kvo-kvc/">kvo/kvc小结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>从学习Objective-C以来，有两个地方一直搞不明白。一个是KVO和KVC的应用和与Delegate的应用场景的区别，一个是Block的应用场景。总结起来就死对Objective-C的数据传送的应用不理解。乘着放假几天对这个知识点进行了一些学习和总结，学习了一个小demo，在这里记录一下自己的学习情况。</p>
<p>参考</p>
<ol>
<li>– <a href="http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/" target="_blank" rel="external">http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/</a></li>
<li>– <a href="http://objccn.io/issue-7-3/" target="_blank" rel="external">http://objccn.io/issue-7-3/</a><p>&lt;!--more--&gt;  
</p>
#KVO</li>
</ol>
<h2 id="KVO简单使用"><a href="#KVO简单使用" class="headerlink" title="KVO简单使用"></a>KVO简单使用</h2><h4 id="KVO-Key-Value-Observing-，是观察者模式在Foundation中的实现"><a href="#KVO-Key-Value-Observing-，是观察者模式在Foundation中的实现" class="headerlink" title="KVO(Key Value Observing)，是观察者模式在Foundation中的实现"></a>KVO(Key Value Observing)，是观察者模式在Foundation中的实现</h4><p>观察者模式，比较容易理解，就是一方对另一方观察，如果进行了改变，那么就要观察者接收到了消息就用进行相应的操作。在KVO中，总结起来就死以下几个操作。</p>
<ol>
<li>当一个object有观察者的时候，动态创建这个object的子类。</li>
<li>对于每一个被观察的属性Property,重写他的set方法</li>
<li>在重写的set方法中，调用 <code>- willChangeValueForKey</code> 和 <code>- didChangeValueForKey</code> 方法</li>
<li>当一个属性Property没有被观察的时候，删除重写的方法</li>
<li>当没有observer观察任何一个property的时候，删除动态创建的子类</li>
</ol>
<p>使用的时候，主要通过以下几个方法来使用</p>
<p><code>addObserver:&lt;#(NSObject *)#&gt; forKeyPath:&lt;#(NSString *)#&gt; options:&lt;#(NSKeyValueObservingOptions)#&gt; context:&lt;#(void *)#&gt;</code></p>
<p>通过这个方法来为一个对象添加观察者，观察减值“key”,option是观察返回的类型字典，总共有以下几种</p>
<ol>
<li>NSKeyValueObservingOptionOld – 变化前的值</li>
<li>NSKeyValueObservingOptionNew – 变化后的值</li>
<li>NSKeyValueObservingOptionPrior – 值变化前进行通知</li>
<li>NSKeyValueObservingOptionInitial – 在添加观察者的时候出发相关方法</li>
</ol>
<p>context 是一个指针当<code>observeValueForKeyPath:ofObject:change:context:</code>方法执行时context会提供给观察者。context可以是C指针或者一个对象引用，既可以当作一个唯一的标识来分辨被观察的变更，也可以向观察者提供数据。</p>
<h4 id="当观察者接受到消息的时"><a href="#当观察者接受到消息的时" class="headerlink" title="当观察者接受到消息的时"></a>当观察者接受到消息的时</h4><p>当被观察的属性变更时，观察者会接到<code>observeValueForKeyPath:ofObject:change:context:</code>消息，所有的观察者都必须实现这个方法。<br>观察者会被提供触发通知的对象和keyPath，一个包含变更详细信息的字典，还有一个注册观察者时提供的context指针。</p>
<p>关于change字典，总共包含以下五个键值</p>
<pre><code>NSString *const NSKeyValueChangeKindKey;  
NSString *const NSKeyValueChangeNewKey;  
NSString *const NSKeyValueChangeOldKey;  
NSString *const NSKeyValueChangeIndexesKey;  
NSString *const NSKeyValueChangeNotificationIsPriorKey;
</code></pre><ol>
<li>NSKeyValueChangeKindKey</li>
</ol>
<p>指明了变更的类型，值为“NSKeyValueChange”枚举中的某一个，类型为NSNumber。</p>
<pre><code>enum {
   NSKeyValueChangeSetting = 1,
   NSKeyValueChangeInsertion = 2,
   NSKeyValueChangeRemoval = 3,
   NSKeyValueChangeReplacement = 4
};
typedef NSUInteger NSKeyValueChange;
</code></pre><ol>
<li>NSKeyValueChangeNewKey</li>
</ol>
<p>如果 <code>NSKeyValueChangeKindKey</code>的值为 <code>NSKeyValueChangeSetting</code>，并且 <code>NSKeyValueObservingOptionNew</code>选项在注册观察者时也指定了，那么这个键的值就是属性变更后的新值。<br>对于 <code>NSKeyValueChangeInsertion</code>或者<code>NSKeyValueChangeReplacement</code>，如果 <code>NSKeyValueObservingOptionNew</code>选项在注册观察者时也指定了，这个键的值是一个数组，其包含了插入或替换的对象</p>
<ol>
<li>NSKeyValueChangeOldKey</li>
</ol>
<h2 id="移除观察者"><a href="#移除观察者" class="headerlink" title="移除观察者"></a>移除观察者</h2><p>你可以通过发送removeObserver:forKeyPath:消息来移除观察者，你需要指明观察对象和路径</p>
<p>注意，在移除观察者之前，如果context是一个对象的引用，那么必须保持对它的强引用直到观察者被移除。</p>
<h2 id="注册依赖键"><a href="#注册依赖键" class="headerlink" title="注册依赖键"></a>注册依赖键</h2><p>有时候，有些属性的值取决于一个或者多个属性的值，一旦某个依赖的属性的值改变了，依赖它的属性的值需要被通知进行改变。</p>
<h3 id="To-One"><a href="#To-One" class="headerlink" title="To - One"></a>To - One</h3><p>要触发to - one 关系，有两种方法</p>
<ol>
<li>定义名称为 <code>keyPathForValueAffecting&lt;key&gt;</code>方法</li>
<li>重写 <code>keyPathForValueAffectingForKey:</code> 方法</li>
</ol>
<h3 id="To-Many"><a href="#To-Many" class="headerlink" title="To - Many"></a>To - Many</h3><p>由于<code>keyPathForValueAffectingForKey</code>不支持包含to-many关系的keypath。如果一个类的属性对另一个类的多个属性有依赖关系的时候，必须通过其他方法来实现KVO。</p>
<ol>
<li><p>将parent类作为所有children类的相关属性的观察者。此时必须注意如果将将child类添加或者删除的时候必须对parent类对child类的观察者添加或者删除。此时通过<code>observeValueForKeyPath:ofObject:change:context:</code>可以通过对被依赖属性的变化来更新依赖属性的值。</p>
</li>
<li><p>Core Data中有另外一种实现观察者模式的方法，由于我还没有使用过Core Data,暂且不谈</p>
</li>
</ol>
<h2 id="调试KVO"><a href="#调试KVO" class="headerlink" title="调试KVO"></a>调试KVO</h2><p>在LLDB中，我们可以通过<code>po [object observationInfo]</code>来获取观察者信息</p>
<p>#KVC</p>
<h2 id="KVC简单使用"><a href="#KVC简单使用" class="headerlink" title="KVC简单使用"></a>KVC简单使用</h2><p>KVC即是键值编码。以字符串的形式向对象发送消息，这个字符串是我们关注的焦点。</p>
<p>基本调用是<code>-valueForKey</code> 和 <code>-setValue:forKey</code></p>
<p>对于KVC，Cocoa自动放入和取出标量值（int，float和struct）放入NSNumber和NSValue中，当使用<code>-setValue:forKey</code>的使用，他自动将标量值从这些对象中取出。</p>
<p>使用KVC访问属性的代价比直接使用存取方法要大，所以只有在需要的时候才使用。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 之行
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: undefined,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: undefined
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>