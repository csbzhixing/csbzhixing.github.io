<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="hello world" />





  <link rel="alternate" href="/atom.xml" title="学海无涯" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="之行的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="学海无涯">
<meta property="og:url" content="http://csbzhixing.github.io/page/2/index.html">
<meta property="og:site_name" content="学海无涯">
<meta property="og:description" content="之行的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学海无涯">
<meta name="twitter:description" content="之行的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://csbzhixing.github.io/page/2/"/>





  <title> 学海无涯 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">学海无涯</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2015/11/06/week-code-1/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/06/week-code-1/" itemprop="url">
                  一周刷题总结 - 1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-11-06T22:36:06+08:00">
                2015-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上周开始复习算法和数据结构，一周每天在睡前都拿出不少时间去学习，做了一些题目，想来每周都应该把相关的题目总结一下，才能更好的去学习。</p>
<ul>
<li>237    Delete Node in a Linked List</li>
</ul>
<p>这是上次笔记里面写过的内容，但是我自己写得时候又出现了问题，看来简单的问题业不能去忽略。</p>
<pre><code class="c">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
void deleteNode(struct ListNode* node) {
    if(node == NULL) return;
    struct ListNode *temp = node-&gt;next;
    node-&gt;val = temp-&gt;val;
    node-&gt;next = temp-&gt;next;
    free(temp);
}
</code></pre>
<ul>
<li>171    Excel Sheet Column Number</li>
</ul>
<p>简单的来说就是一个26进制的数，没什么难点</p>
<pre><code class="c">int titleToNumber(char* s) {
    int length = strlen(s);

    int all = 0;

    for(int i=0;i&lt;length;i++)
    {
        all=((s[i]-&#39;A&#39;)+1) + all * 26;
    }

    return all;
}
</code></pre>
<ul>
<li>169    Majority Element</li>
</ul>
<p>出现超过n/2的数，通过遍历就可以了</p>
<pre><code class="c">
int majorityElement(int* nums, int numsSize) {
    int time=0,maj;
    for(int i=0;i&lt;numsSize;i++)
    {
        if(time == 0)
        {
            maj = nums[i];
        }
        if(nums[i]==maj) 
        {
            time++;
        }
       else{
         time--;  
       } 
    }
    return maj;
}
</code></pre>
<ul>
<li>206    Reverse Linked List</li>
</ul>
<p>反转链表，基础题目</p>
<pre><code class="c">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* reverseList(struct ListNode* head) {

    struct ListNode* pre = NULL;
    struct ListNode* cur = head;
    struct ListNode* next = NULL;

    while(cur)
    {
        next = cur-&gt;next;
        cur-&gt;next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
</code></pre>
<ul>
<li>263    Ugly Number</li>
</ul>
<p>简单的递归问题</p>
<pre><code class="c">
bool isUgly(int num) {

    if(num&lt;1) return false;

    if(num%2==0)
    {
        num/=2;
        return isUgly(num);
    }

     if(num%3==0)
    {
        num/=3;
        return isUgly(num);
    }

     if(num%5==0)
    {
        num/=5;
        return isUgly(num);
    }

    if(num == 1) return true;

    return false;

}
</code></pre>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2015/11/01/runtime/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/01/runtime/" itemprop="url">
                  runtime
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-11-01T10:07:27+08:00">
                2015-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>从开始写博客的时候，就由一个准备把Runtime好好研究整理出来。后来发现写runtime得文章太多了，而且自己研究的也算不上有多么深入，写出来估计很多错误- —–（因为主要是给自己看得）。最近在项目中，第一次用到了runtime解决了一个实际问题，这启发我，我的文章应该从怎么利用runtime去解决实际的问题，给自己提供一个解决问题的新思路。</p>
<p>##runtime 关联对象</p>
<p>从关联对象说起，是因为在最近的项目中用到了这个方法。当时的场景是，我需要创建一个category，里面需要一个block对象。然而我们知道，我们不能在category中添加成员变量。如果我们尝试添加的话，编译器会报错。当然，使用全局变量能解决这个问题，但明显是一个很优雅的方法，也很容易造成错误。Objective-C针对这一中问题，提供了一个解决方案，就是<code>关联对象(Associated Object)。</code></p>
<p>我们可以想象，关联对象就是一个key - value的模型，把对象通过特定的Key链接到相关的实例上。不过由于使用的是C的借口，所以key是一个void指针。同时，我们要需要为这个关联对象设定内存管理策略。相关的内存的管理策略如下:</p>
<pre><code>OBJC_ASSOCIATION_ASSIGN

OBJC_ASSOCIATION_RETAIN_NONATOMIC

OBJC_ASSOCIATION_COPY_NONATOMIC

OBJC_ASSOCIATION_RETAIN

OBJC_ASSOCIATION_COPY
</code></pre><p>对<code>OBJC_ASSOCIATION_ASSIGN</code>的，当关联对象所关联的实例被释放掉后，对象不会被释放掉。而<code>OBJC_ASSOCIATION_RETAIN</code>和<code>OBJC_ASSOCIATION_COPY</code>两个的话，在实例被释放掉同时，关联对象也会被release掉。当我们用同一个key去关联另外的实例对象的时候，也会自动释放掉之前关联的对象。这种情况下，先前的关联对象会被妥善地处理掉，并且新的对象会使用它的内存。</p>
<p>关联对象的的runtime函数如下</p>
<pre><code>// 设置关联对象

void objc_setAssociatedObject ( id object, const void *key, id value, objc_AssociationPolicy policy );



// 获取关联对象

id objc_getAssociatedObject ( id object, const void *key );



// 移除关联对象

void objc_removeAssociatedObjects ( id object );
</code></pre><p>下面就给出在项目中实际遇到的问题给做一个例子。</p>
<p>首先在头文件中定义了以下内容。</p>
<p><img src="/media/14463463210542.jpg" alt=""></p>
<p>可以看到，这个category是为了扩展vc，让vc具有一个弹出系统通讯录的功能。</p>
<p>在.m文件中，如下实现block关联对象</p>
<p><img src="/media/14463464447032.jpg" alt=""></p>
<p>然后就像正常的对象一样操作就行了</p>
<p><img src="/media/14463464914602.jpg" alt=""></p>
<p><img src="/media/14463464837182.jpg" alt=""></p>
<p>在上面看到，我对关联对象使用的key是用了<code>@selector()</code>。那为什么可以使用SEL来代替设定一个固定的key呢？</p>
<h2 id="方法与消息"><a href="#方法与消息" class="headerlink" title="方法与消息"></a>方法与消息</h2><ul>
<li>SEL</li>
</ul>
<p>又叫选择器，是表示一个方法的selector的指针，其定义如下：</p>
<p><code>typedef struct objc_selector *SEL;</code><br>objc_selector结构体的详细定义没有在&lt;objc/runtime.h&gt;头文件中找到。方法的selector用于表示运行时方法的名字。Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。</p>
<ul>
<li>IMP</li>
</ul>
<p>通过SEL找到函数后，就可以获取到该函数的IMP。IMP实际上是一个函数指针，指向方法实现的首地址。其定义如下</p>
<pre><code>id (*IMP)(id, SEL, ...)
</code></pre><p>通过取得IMP，我们可以跳过runtime的消息传递机制，直接通过IMP执行指向的函数实现。这样一来可以提高效率，省去了消息传递中的一系列过程</p>
<pre><code>回答上面的问题

我们知道，在同一个类文件里面，不能存在同一个名字的方法，即使是参数类型不同业不行。同理，同一个类文件里面不能存在同一个名字的对象，所以set方法是唯一的，所以可以使用SEL来获取唯一的整理标识来作为key。
</code></pre><p>##下面是看的一些文章的摘录和自己的一项心得，主要是给自己做一个备忘。</p>
<p>选择器相关的操作函数包括：</p>
<pre><code>// 返回给定选择器指定的方法的名称
const char * sel_getName ( SEL sel );
// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器

SEL sel_registerName ( const char *str );



// 在Objective-C Runtime系统中注册一个方法

SEL sel_getUid ( const char *str );



// 比较两个选择器

BOOL sel_isEqual ( SEL lhs, SEL rhs );
</code></pre><p>方法操作的函数如下</p>
<pre><code>// 调用指定方法的实现
// receiver不能为空
// 比method_getImplementation和method_getName更快

id method_invoke ( id receiver, Method m, ... );



// 调用返回一个数据结构的方法的实现

void method_invoke_stret ( id receiver, Method m, ... );



// 获取方法名
// 返回一个SEL。如果要获取方法名得C字符串，要用sel_getName(method_getName(method))。

SEL method_getName ( Method m );



// 返回方法的实现
// 注意该函数返回值是方法之前的实现。
IMP method_getImplementation ( Method m );



// 获取描述方法参数和返回值类型的字符串

const char * method_getTypeEncoding ( Method m );



// 获取方法的返回值类型的字符串

char * method_copyReturnType ( Method m );



// 获取方法的指定位置参数的类型字符串

char * method_copyArgumentType ( Method m, unsigned int index );



// 通过引用返回方法的返回值类型字符串

void method_getReturnType ( Method m, char *dst, size_t dst_len );



// 返回方法的参数的个数

unsigned int method_getNumberOfArguments ( Method m );



// 通过引用返回方法指定位置参数的类型字符串

void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );



// 返回指定方法的方法描述结构体

struct objc_method_description * method_getDescription ( Method m );



// 设置方法的实现

IMP method_setImplementation ( Method m, IMP imp );



// 交换两个方法的实现

void method_exchangeImplementations ( Method m1, Method m2 );
</code></pre><p>##方法调用流程</p>
<p>在Objective-C中，消息会一直到运行时绑定的方法实现上。我们常用的[receiver message]会被runtime转换为一个函数调用<code>objc_msgSend</code>。如下</p>
<p><code>objc_msgSend(receiver, selector)</code><br>如果消息中还有其它参数，则该方法的形式如下所示：</p>
<p><code>objc_msgSend(receiver, selector, arg1, arg2, ...)</code></p>
<p>这个函数在执行的过程中完成了所有动态绑定的过程。</p>
<ol>
<li>找到SEL对应的方法实现。由于一个方法可能在不同的类有不同的实现，所有我们要依赖于接受者的类来确定确切的实现。</li>
<li>调用方法的实现，将参数传入。</li>
<li>将方法的返回这作为的自己的返回值。</li>
</ol>
<p>一个基本消息的框架</p>
<p><img src="/media/14463917464901.jpg" alt=""></p>
<p>注意到，在<code>objc_msgSend</code>中有两个隐藏参数：</p>
<ol>
<li>消息接受对象</li>
<li>方法的selecor</li>
</ol>
<p>隐藏是以为内在定义的方法中没有申明，是在编译期被插入实现代码的。</p>
<p>##消息转发</p>
<p>当一个对象能接受一个消息的时候，那么一切都会按照我们想得去做，但是如果不能接受消息的时候，会发生什么？一般情况下，如果不能相应[object message],编译期会报错。如果是以perform来调用的，那么在运行时才会确定object是否会接收消息，如果不行的话，就会造成程序崩溃。</p>
<p>当然，我们可以通过<code>respondsToSelector:</code>来判断一下是否会响应这个消息，但是我们要用runtime来搞一搞，所以我们应该从<code>消息转发机制</code>来考虑。</p>
<p>消息转发机制基本分为三个步骤</p>
<ol>
<li>动态方法解析</li>
<li>备用接收者</li>
<li>完成转发</li>
</ol>
<p>###动态方法解析</p>
<p>当当对象接收到位置的消息时，首先会调用类的<code>+resolveInstanceMethod:(实例方法)</code>或者<code>+resolveClassMethod:(类方法)</code>。因此，我们可以去增加一个处理方法。在消息不能被对象接收的时候就运行这个方法，前提是这个方法已经被实现了。</p>
<pre><code>void functionForMethod1(id self, SEL _cmd) {

   NSLog(@&quot;%@, %p&quot;, self, _cmd);

}



+ (BOOL)resolveInstanceMethod:(SEL)sel {



    NSString *selectorString = NSStringFromSelector(sel);



    if ([selectorString isEqualToString:@&quot;method1&quot;]) {

        class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &quot;@:&quot;);

    }



    return [super resolveInstanceMethod:sel];

}
</code></pre><h3 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h3><p>当我们的对象不能处理消息的时候，我们将消息转发到一个备用的对象，只要这个对象的类实现了这个方法<br><code>- (id)forwardingTargetForSelector:(SEL)aSelector</code></p>
<p>如果返回的不是一个nil的话，那么这个对象就会被作为消息的心的接收者。而在外部看来，这个消息仍然被我们的发送的对象处理了。注意，这个方法返回的对象不是self自身，不然就是个无限循环了。</p>
<pre><code>@interface SUTRuntimeMethodHelper : NSObject



- (void)method2;



@end



@implementation SUTRuntimeMethodHelper



- (void)method2 {

    NSLog(@&quot;%@, %p&quot;, self, _cmd);

}



@end



#pragma mark -



@interface SUTRuntimeMethod () {

    SUTRuntimeMethodHelper *_helper;

}



@end



@implementation SUTRuntimeMethod



+ (instancetype)object {

    return [[self alloc] init];

}



- (instancetype)init {

    self = [super init];

    if (self != nil) {

        _helper = [[SUTRuntimeMethodHelper alloc] init];

    }



    return self;

}



- (void)test {

    [self performSelector:@selector(method2)];

}



- (id)forwardingTargetForSelector:(SEL)aSelector {



    NSLog(@&quot;forwardingTargetForSelector&quot;);



    NSString *selectorString = NSStringFromSelector(aSelector);



    // 将消息转发给_helper来处理

    if ([selectorString isEqualToString:@&quot;method2&quot;]) {

        return _helper;

    }



    return [super forwardingTargetForSelector:aSelector];

}



@end
</code></pre><p>###完成的消息转发</p>
<p>如果上述的行为都不能解决的话，runtime在这时候会给对象最后一次机会：</p>
<pre><code>- (void)forwardInvocation:(NSInvocation *)anInvocation
</code></pre><blockquote>
<p>这个时候，消息的所有未处理的内容都被封装到了anInvocation中，包括SEL,target，参数。我们在这里可以选着将消息转发给其他的对象。</p>
<p>forwardInvocation:方法的实现有两个任务：</p>
<p>定位可以响应封装在anInvocation中的消息的对象。这个对象不需要能处理所有未知消息。<br>使用anInvocation作为参数，将消息发送到选中的对象。anInvocation将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。</p>
</blockquote>
<p>对于这一块，还没有具体的实践，毕竟到这一步，用runtime来解决不如好好回去check以下代码吧。</p>
<p>##Method Swizze</p>
<p>Method Swizzling是改变一个selector的实际实现的技术.这样，我们可以在runtime的时候修改类分发的队形的函数，修改对应的实现。</p>
<p>例如，我们想在每一个<code>viewDidAppear</code>增加一个跟踪代码，观察哪个vc被调用了，那么我们就可以通过<code>Method Swizzling</code></p>
<p>###Swizzling 注意事项</p>
<p><code>Swizzling应该总是在+load中执行</code></p>
<p>在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证—事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。</p>
<p>+load在父类，子类，分类的实现都会分别调用，所以+load更适合</p>
<p>###Swizzling应该总是在dispatch_once中执行</p>
<p>与上面相同，因为swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的dispatch_once可以确保这种行为，我们应该将其作为method swizzling的最佳实践。</p>
<p>###特别的地方</p>
<p>&gt;</p>
<ol>
<li>总是调用方法的原始实现(除非有更好的理由不这么做)：API提供了一个输入与输出约定，但其内部实现是一个黑盒。Swizzle一个方法而不调用原始实现可能会打破私有状态底层操作，从而影响到程序的其它部分。</li>
<li>避免冲突：给自定义的分类方法加前缀，从而使其与所依赖的代码库不会存在命名冲突。</li>
<li>明白是怎么回事：简单地拷贝粘贴swizzle代码而不理解它是如何工作的，不仅危险，而且会浪费学习Objective-C运行时的机会。阅读Objective-C Runtime Reference和查看&lt;objc/runtime.h&gt;头文件以了解事件是如何发生的。</li>
<li>小心操作：无论我们对Foundation, UIKit或其它内建框架执行Swizzle操作抱有多大信心，需要知道在下一版本中许多事可能会不一样。</li>
</ol>
<p>##总结</p>
<p>runtime到这里，大概讲了下两个问题，方法转发和关联对象。觉得还是不够，因为很多东西写起来发现自己也不是很了解，暂且做一个笔记。</p>
<p>这里感谢南峰子，写得runtime教程非常详细，给了我很多帮助。</p>
<p>本文参考了大量下面三篇文章的内容。</p>
<p><a href="http://southpeak.github.io/blog/2014/11/06/objective-c-runtime-yun-xing-shi-zhi-si-:method-swizzling/" target="_blank" rel="external"></a></p>
<p><a href="http://southpeak.github.io/blog/2014/11/03/objective-c-runtime-yun-xing-shi-zhi-san-:fang-fa-yu-xiao-xi-zhuan-fa/" target="_blank" rel="external"></a></p>
<p><a href="http://southpeak.github.io/blog/2014/10/30/objective-c-runtime-yun-xing-shi-zhi-er-:cheng-yuan-bian-liang-yu-shu-xing/" target="_blank" rel="external"></a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2015/10/25/list/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/25/list/" itemprop="url">
                  list
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-10-25T23:38:26+08:00">
                2015-10-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="开始内功！"><a href="#开始内功！" class="headerlink" title="开始内功！"></a>开始内功！</h1><p>前几日和前老大谈了谈，总结起来内功不能不练。实习以来有三次想好好复习数据结构和算法，但是最后都半途而废。现在不应该再有任何理由了，不然以后再也没有时间好好去复习这些东西。从现在开始刷好题目，打好基础。</p>
<p>##链表</p>
<p>链表是线性表的一种。</p>
<p>线性表是最简单基础的一种数据结构。线性表中的数据元素之间的关系是一对一的，除了头元素和尾元素之外，其他元素首尾相连。线性表有两种存储方式</p>
<ol>
<li>顺序存储方式</li>
<li>链式存储方式</li>
</ol>
<p>数组是典型的顺序存储方式。链表是典型的链式存储方式。</p>
<p>链式存储结构，指的是相邻的两个元素在内存中可能不是相邻的，每一个元素都有一个指针域，指针域存放的是下一个元素的指针。</p>
<p>链式结构的优缺点：</p>
<ul>
<li><p>优点</p>
<ol>
<li>插入和删除的复杂度为O(1)</li>
<li>不会浪费太多内存，在需要添加元素的时候才会申请内存，删除元素后释放内存。</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>访问元素的时间复杂度最坏为O(N)</li>
</ol>
<p>链表就是链式存储的线性表。根据指针域的不同，链表分为单项链表，双向链表，循环链表等等</p>
<p>一个简单的List定义</p>
<pre><code class="C">struct list {
int ver;
struct list *next;
};
typedef struct list *listLink;
// 插入
void insert_list(listLink *, int);
// 打印
void print_list(listLink *, int);
// 链表长
int list_length(listLink);
// 搜索一个特定的值
listLink search_list(listLink, int);
</code></pre>
</li>
</ul>
<p>四个方法的实现</p>
<p><img src="/media/14459585444278.jpg" alt=""></p>
<p>##指针常出现的问题</p>
<p>###反转链表</p>
<p>反转链表，分为两种情况讨论，单向链表和双向链表</p>
<ul>
<li><p>单向链表</p>
<ul>
<li><p>考虑到访问某个节点的时候，要检查下一个节点是否为空。</p>
</li>
<li><p>要把反转后的最后一个节点（头节点）的指针指向null</p>
</li>
</ul>
</li>
</ul>
<p>实现代码如下</p>
<p><img src="/media/14459590472638.jpg" alt=""></p>
<ul>
<li>双向链表</li>
</ul>
<p>双向链表比较麻烦的地方在于Next和pre要呼唤，需要主要当前节点和上个节点的问题。</p>
<p>###删除节点</p>
<p>删除节点必须要知道被删除节点的前置节点，时间复杂度为O(1)</p>
<p><img src="/media/14459596886157.jpg" alt=""></p>
<p>###循环链表</p>
<p>循环链表表现于尾元素的next指针指向head元素，所以我们可以通过快慢指针去校验。具体的方法会在下面的链表的技巧中提到.</p>
<h2 id="链表的技巧"><a href="#链表的技巧" class="headerlink" title="链表的技巧"></a>链表的技巧</h2><p>###鲁棒性</p>
<ul>
<li>当访问链表中某个节点的next节点的时候，一点要先判断当前节点是否为空。</li>
<li>全部操作结束后，判断是否有环。若有环，则置其中一端为Null;</li>
</ul>
<h3 id="Dummy-Node"><a href="#Dummy-Node" class="headerlink" title="Dummy Node"></a>Dummy Node</h3><p>假节点，伪头节点。Dummy <code>Node</code> 可以认为是一个假的头结点。我们可以构造一个<code>Dummy Node</code> ，使他的next指针指向Head node。使用<code>Dummy Node</code>目的是，在单向链表中，保正head不会再删除操作中丢失。此外，比较特殊的方法是用来进行删除head。</p>
<p>Dummy Node可以处理对于head Node变化的情况。</p>
<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>快慢指针式解决很多链表的问题的关键。快慢指的是指针每次移动的步长。常用的快指针步长为2，慢指针步长为1.快慢指针同时从头结点开始移动陪你过。</p>
<p>快慢指针的应用可以解决以下问题</p>
<ol>
<li>快速找出为止长度的链表的中间节点。我们让快指针的步长是慢指针的两倍。当快指针到达尾节点的时候，慢指针所指向的节点就是中间节点。</li>
<li>判断单向链表是否成环。同样的原理，如果快指针 <code>*fase =NULL</code>的时候，说明链表是NULL结尾的。如果快指针等于慢指针的时候，则说明该链表成环。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2015/10/23/afnetworking-1/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/23/afnetworking-1/" itemprop="url">
                  AFNetworking 学习笔记 1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-10-23T10:31:15+08:00">
                2015-10-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index">
                    <span itemprop="name">Network</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##从3.0开始</p>
<p>一转眼，AF已经更新到了3.0版本。目前cocoapods上的最新版本是3.0 beta1。在3.0的版本里面，AF全面地使用<code>NSURLSession</code>代替了<code>NSURLConnection</code>。之前花了一些时间学习<code>NSURLSession</code>，在这里的学习终于派上了用场。在这里主要学习3.0版本的使用。希望在项目中能够顺利地过度到AFNetwoking 3.0版本。此外，随着Objective-c慢慢被Swift替代，AFNetworking 3.0可能是最后一个大版本更新。本文会一直随着AN的更新继续更新，也是一个不断学习的过程。</p>
<p>##结构</p>
<p>在3.0时代，AFN精简了结构，全面使用了<code>NSURLSession</code>。</p>
<p><img src="/media/14451531667191.jpg" alt=""><br>beta1里面只剩下了当前几个Manager。</p>
<p><code>AFHTTPSessionManager</code>是<code>AFURLSessionManager</code>的子类。</p>
<p>##AFURLSessionManager</p>
<p><code>AFURLSessionManager</code>实现了以下几种<code>NSURLSession</code>的代理方法</p>
<h4 id="NSURLSessionDelegate"><a href="#NSURLSessionDelegate" class="headerlink" title="NSURLSessionDelegate"></a><code>NSURLSessionDelegate</code></h4><ul>
<li><code>URLSession:didBecomeInvalidWithError:</code></li>
<li><code>URLSession:didReceiveChallenge:completionHandler:</code></li>
<li><code>URLSessionDidFinishEventsForBackgroundURLSession:</code></li>
</ul>
<h4 id="NSURLSessionTaskDelegate"><a href="#NSURLSessionTaskDelegate" class="headerlink" title="NSURLSessionTaskDelegate"></a><code>NSURLSessionTaskDelegate</code></h4><ul>
<li><code>URLSession:willPerformHTTPRedirection:newRequest:completionHandler:</code></li>
<li><code>URLSession:task:didReceiveChallenge:completionHandler:</code></li>
<li><code>URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:</code></li>
<li><code>URLSession:task:didCompleteWithError:</code></li>
</ul>
<h4 id="NSURLSessionDataDelegate"><a href="#NSURLSessionDataDelegate" class="headerlink" title="NSURLSessionDataDelegate"></a><code>NSURLSessionDataDelegate</code></h4><ul>
<li><code>URLSession:dataTask:didReceiveResponse:completionHandler:</code></li>
<li><code>URLSession:dataTask:didBecomeDownloadTask:</code></li>
<li><code>URLSession:dataTask:didReceiveData:</code></li>
<li><code>URLSession:dataTask:willCacheResponse:completionHandler:</code></li>
</ul>
<h4 id="NSURLSessionDownloadDelegate"><a href="#NSURLSessionDownloadDelegate" class="headerlink" title="NSURLSessionDownloadDelegate"></a><code>NSURLSessionDownloadDelegate</code></h4><ul>
<li><code>URLSession:downloadTask:didFinishDownloadingToURL:</code></li>
<li><code>URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesWritten:totalBytesExpectedToWrite:</code></li>
<li><code>URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:</code></li>
</ul>
<p>###成员</p>
<p>####属性</p>
<p>在<code>AFURLSessionManager</code>中，主要的三个属性如下</p>
<p><img src="/media/14451544109695.jpg" alt=""></p>
<p><code>session</code>实现了会话，<code>operationQueue</code>是一个操作队列。<code>responseSerializer</code>是实现了<code>AFURLResponseSerialization</code>协议的一个对象。</p>
<hr>
<p>Manager中还包括了安全协议的对象和连通性的对象。这两个类将在后面谈到。</p>
<p><img src="/media/14451545558576.jpg" alt=""></p>
<hr>
<p>下面是Task的内容，包含与当前<code>Session</code>中</p>
<p><img src="/media/14451547233232.jpg" alt=""></p>
<hr>
<p>回调块队列，包括了在主队列和私有队列的两个部分</p>
<p><img src="/media/14451548418504.jpg" alt=""></p>
<p>####方法</p>
<p> 初始化方法</p>
<p> <img src="/media/14455211888103.jpg" alt=""></p>
<hr>
<p>创建一个<code>NSURLSessionDataTask</code>数据性任务</p>
<p><img src="/media/14455212385758.jpg" alt=""></p>
<hr>
<p>创建<code>`NSURLSessionUploadTask</code> 上传任务</p>
<p><img src="/media/14455213126912.jpg" alt=""><br><img src="/media/14455213190110.jpg" alt=""></p>
<hr>
<p>创建<code>NSURLSessionDownloadTask</code> 下载任务</p>
<p><img src="/media/14455213738134.jpg" alt=""><br><img src="/media/14455213826398.jpg" alt=""></p>
<hr>
<p>获得一个特定任务的<code>progress进度</code></p>
<p><img src="/media/14455214651069.jpg" alt=""><br><img src="/media/14455214692883.jpg" alt=""><br><img src="/media/14455214742512.jpg" alt=""></p>
<hr>
<p><code>Session Delegate Callbacks 设置会话代理回调</code></p>
<p><img src="/media/14455217046547.jpg" alt=""><br><img src="/media/14455217113671.jpg" alt=""></p>
<p><code>Task Delegate Callbacks 设置任务代理回调</code></p>
<p>当任务需要一个新的请求体发送给服务器的时候。<br><img src="/media/14455219470133.jpg" alt=""></p>
<p>当HTTP请求回调有重定向的的话设置这个Block<br><img src="/media/14455219533707.jpg" alt=""></p>
<p>当一个请求需要特别的鉴权的时候设置这个challenge<br><img src="/media/14455219599178.jpg" alt=""></p>
<p>设置一个block去追踪上传进度</p>
<p><img src="/media/14455658294340.jpg" alt=""></p>
<p>设置一个block当任务完成后执行<br><img src="/media/14455658635389.jpg" alt=""></p>
<p>####<code>Setting Data Task Delegate Callbacks 设置数据任务代理的回调</code></p>
<p>设置一个在数据任务获得response的时候回调block</p>
<p><img src="/media/14455662011592.jpg" alt=""></p>
<p>设置一个block当数据任务变成下载的任务的时候执行</p>
<p><img src="/media/14455662317310.jpg" alt=""></p>
<p>设置一个block当数据任务获得到数据的时候<br><img src="/media/14455662434172.jpg" alt=""></p>
<p>设置一个block绝对是否缓存数据任务</p>
<p><img src="/media/14455662958106.jpg" alt=""></p>
<p>####<code>Download Task Delegate Callbacks 下载任务代理回调</code></p>
<p>设置block当下载任务完成下载后</p>
<p><img src="/media/14455666105437.jpg" alt=""></p>
<p>设置block去追踪下载任务进度情况</p>
<p><img src="/media/14455666301025.jpg" alt=""></p>
<p>设置block当下载任务执行/恢复的时候 执行</p>
<p><img src="/media/14455666958363.jpg" alt=""></p>
<p>头文件的内容基本就是以上的了。可以看到整个AF的体系非常清晰完整，没有多余的东西，头文件只暴露了应该暴露的东西，值得我们去学习。</p>
<p>##使用的例子</p>
<p>###使用<code>AFURLSessionManager</code></p>
<p>从源码中可以看到，<code>AFURLSessionManager</code>实现了</p>
<pre><code class="Objective-c">NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate, NSSecureCoding, NSCopying
</code></pre>
<p>首先需要设置url和NSURLConfirguration</p>
<p>这里是使用百度API商店的公开API<br><img src="/media/14453928846040.jpg" alt=""></p>
<p>然后初始化Manager<img src="/media/14453929237373.jpg" alt=""></p>
<p>设置ResponseSerializer<br><img src="/media/14453931412125.jpg" alt=""></p>
<p>初始化request<br><img src="/media/14453932169242.jpg" alt=""></p>
<p>对request进行相关设置<br><img src="/media/14453932396509.jpg" alt=""></p>
<p>根据request生成对应的<code>NSURLSessionTask</code>。<br><img src="/media/14453935717679.jpg" alt=""></p>
<p>执行任务<br><img src="/media/14453936154108.jpg" alt=""></p>
<p>来看看执行后的信息</p>
<p><img src="/media/14453937344699.jpg" alt=""></p>
<p>这里由于使用的<code>AFHTTPResponseSerializer</code>(API的问题，仅仅支持text/plain)所以在获取的数据后，我们自己要json序列化。如果是设计好的API,直接使用<code>AFJSONRequestSerializer</code>就可以在回调中获取到json格式的数据了。</p>
<p>可以看到，整个使用还是很方便的。我们可以根据自己的需求配置不同设置。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2015/10/09/other/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/09/other/" itemprop="url">
                  改变，一刻都不能停止
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-10-09T13:36:46+08:00">
                2015-10-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/personal/" itemprop="url" rel="index">
                    <span itemprop="name">personal</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="杂谈，生活，学习"><a href="#杂谈，生活，学习" class="headerlink" title="杂谈，生活，学习"></a>杂谈，生活，学习</h1><p>##从iTunes store说起</p>
<p>9.30号凌晨，在我半睡半醒的时候，准备更新下一些APP。然后就发现了iTunes 提醒我要同意新的协议，当时很困就睡着了，没有想太多。早上起来，发现apple music可以用了！没错！免费三个月，续费十块钱一个月！然后看了下电影。一堆一块钱的正版电影你相信吗？？！。</p>
<p>好吧，为何我那么激动吗，对于很多人是不理解的。相对于一些必须消费的商品。图书，音乐，电影，游戏，软件这些虚拟服务，在许多人眼里就是免费的午餐。从来没想到过我们为何要去为这些东西掏钱。所以，很多人并不看好苹果这次在大陆推行的这些服务。然而我认为，苹果这是以一己之力，将要改变中国人对版权的认识。为什么这么说？价格说明一切。</p>
<p>如今，出去吃顿饭一个人动不动上百，一杯果汁奶茶都几十块钱的时代，却还在为一个优秀APP几十块钱而烦恼。入手新手机后，买了几款APP。其中有一个第三方微博客户端墨客。我家里很不理解为什么有微博客户端我还会去选择掏钱去买。我觉得，仅仅是干净舒适的UI设计就足够我花这个钱，而且再不用看到一大堆乱七八糟的推广，能够最快的看到自己需要的内容，这一切仅仅18块钱，难道不比买一包烟，喝一杯果汁来的值得吗？</p>
<h2 id="新的工作，一样的生活"><a href="#新的工作，一样的生活" class="headerlink" title="新的工作，一样的生活"></a>新的工作，一样的生活</h2><p>国庆第一天，把宿舍几乎所有的东西都带回家了。8号到了新公司报道。在国庆的时候，好好的回顾了下以前的堕落的生活，顺便整理了下自己的学习和工作上的问题。发现自己任然有许多地方的欠缺。牛逼的人，总是有强迫症的。而我，似乎不能称为牛逼的人，就是因为没有强迫症。面对代码，能Copy/Paste的话就做了，没有想到怎么去重构，去思考怎么做的更好。面对重复的东西，总是尽可能去避免。不愿意耐心的去解决的困难的问题，总是想依赖其他的人的经验来解决。不踏过千千万万个坑，怎么能说自己是个出色的工程师？总不能一辈子都在搬砖吧。养成强迫症，才不会总是固守原来的生活。</p>
<p>##深度和广度</p>
<p>在面试的时候，和这家公司的团队老大有一番交流让我感触很深。搞技术的，除了要有深度，还要有广度。对于广度和深度，之前也和某老大谈过。全栈好不好，这个话恐怕只有自己到了那个层次才能谈谈。毕竟现在，哪怕仅仅是一个方面，自己都很难保证能解决多数的问题。如今进入到了这个团队，感受到了身边的牛人还真的很多，许多都是多面手。看来不能仅仅把自己的困在一个方面。多学多用给你才是王道。后面打算整理下自己的技能树，然后根据轻重来设计自己的学习路线。</p>
<p>##让思维和身体都跑起来吧！</p>
<p><img src="/media/14443703278870.jpg" alt=""></p>
<p>坚持跑步已经有了两个月。虽然中间因为各种原因停顿了几次，这个月的跑量一直没上去。然而现在固定了下来，也要恢复到之前的运动模式。身体的运动，也改善了我思考的模式。不再会因为因为小小的事情而去分心。执行力也越来越好，也容易控制自己的情绪了。思维跟随的身体，一起奔跑的感觉，实在是太好不过了。</p>
<p>最后一句话，送给自己。</p>
<p>##一切不变的，就是改变</p>
<p>˙</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2015/09/29/update-self/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/29/update-self/" itemprop="url">
                  个人知识管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-09-29T14:27:00+08:00">
                2015-09-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/personal/" itemprop="url" rel="index">
                    <span itemprop="name">personal</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>9月25号上周五收到了新的iphone6s plus。在折腾了几天后，整理了出自己的一套效率工作系统，目前看来效果良好，不知道未来使用几个月是否会给自己带来不一样的体验。</p>
<p>下面是系统大纲</p>
<p><img src="/media/14435106554403.jpg" alt="大纲"></p>
<p>##效率工具</p>
<p>好的计划是成功的一般。在之前由于国内安卓机无法使用谷歌服务，许多需要谷歌服务框架的软件都用不了，一直以来都没有建立一个体系工具。入手iPhone之后，借助于VPN，能够很好的结合谷歌服务和苹果云服务了。</p>
<ol>
<li>sunrise。我能找到免费的日历里面最好的。能够同步iCloud和谷歌日历。能够跨平台。界面也很美观。能够同步iCloud日历就不用手动在sunrise上面添加行程，只需要在mac或者iPhone上面添加提醒事项就可以了。</li>
<li>Noti:Do 限免入手的。小而美的TODO软件。能够同步到系统的提醒事项。使用简单方便。</li>
<li>apple的提醒事项。系统内置的软件，对比了几个大而全的第三方软件后，我发现提醒事项已经能够满足多数的需求了，能够iCloud同步，非常方便。</li>
<li>SimpleNote。简单好用的第三方笔记软件。没有使用自带note是因为同步出现了一些问题。SimpleNote同步也很方便，能够在web上使用也使得在Windows上也能使用。将一些需要备忘的比如邮箱，账号放入非常好。同时在iPhone上支持使用Touch ID加密，感觉太棒了。</li>
</ol>
<p>##存储</p>
<p>网盘的使用参考了许多，最终选择了国内的坚果云和国外的DropBox</p>
<p>##邮件</p>
<p>在大学的时候，并没有很注意使用邮件，所有要邮件订阅的地方都是一个QQ邮箱就搞定了。后来发现其实邮件用处实在是太大了。不仅可以订阅消息，注册，沟通，还可以做计划，安排，备份（网盘）。</p>
<ol>
<li>GMail。这估计是所有Geek的第一选择。唯一的缺点就是要翻墙。而且我发现GMail的SMTP的服务器在mac上特别不好连接。GMail的账号可以通行所有谷歌服务，而且可以很便捷地登陆国外的网站服务。</li>
<li>QQ。综合来看，现在国内邮箱服务做的最好的就是QQ邮箱了。没什么太大的槽点，后缀稍微low点，但是可以改成foxmail。</li>
<li>apple mail.app 。苹果自带的邮箱软件。在这上面找了几个免费的，感觉都不是很好。许多人也说其实自带的就已经能够满足需求了。嗯，还是原生的好。</li>
</ol>
<p>##资讯</p>
<p>网络时代是信息大爆炸的时代，怎么根据自己的需求去订制整理咨询是很重要的。在辗转了一大咨询类APP以后，发现要么太复杂要么内容单一。最后决定通过RSS订阅来自己调整信息源。</p>
<ol>
<li>微博客户端 Moke。收费的客户端，18元人民币，少数几个花钱的APP。没有广告真的很清爽，有许多手势但是还没有掌握好。</li>
<li>Pocket。对于Pocket，我是作为文档存放整理的地方。好的文章先加入到Pocket中，然后根据内容分类，后面决定每周花时间整理一个分类。</li>
<li>知乎。上了知乎身体一天不如一天了。。。开玩笑的。知乎还是有很多干货，需要自己去挖掘，但是随着用户群体的扩大，感觉回答的质量下降的很厉害，太多的耍机灵简直浪费我生命。。</li>
<li>Feedly。RSS订阅软件。看中的就是他跨平台的能力。缺点是要翻墙。。。而且很多功能必须付费才开通（我想分享我的订阅都要付费。。。）。</li>
</ol>
<h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><ol>
<li>MWeb。又是一个付费应用，而且很不便宜。。9.9刀。但是我感觉物超所值。功能很强大的MarkDown写作软件。现在习惯了用MWeb觉得Word真的。。跟不上他的设计了。</li>
<li>SimpleNote。一些简单的备忘，临时的灵感记录，上面已经讲过了。</li>
</ol>
<p>##为什么要建立个人知识管理系统</p>
<p>在最近几个月的学习中，我发现自己接收了太多的信息而不能很好的吸收，时间安排也太随性浪费了很多时间。既然买了新手机，不能和一般人一样作为一个娱乐工具，也应该去帮助自己提高。所以在做了一番工作后，自己设计了这一个系统，可能不完善，很简单，但也是个开始。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2015/09/25/thread/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/25/thread/" itemprop="url">
                  多线程开发详谈
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-09-25T09:49:52+08:00">
                2015-09-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/base/" itemprop="url" rel="index">
                    <span itemprop="name">base</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>按照计划，这篇文章主要谈iOS下的并发编程。</p>
<p>之前的文章已经谈过了GCD的实现，包括苹果在GCD之上实现的NSOperation。但是在几次面试后发现，仅仅了解API还不够，要去深入的了解整个运行的机制。只有对整个系统有了更深刻的了解，才能不被API给限制住。</p>
<p>##并发</p>
<p>并发，概念就是同时运行多个任务。这些任务可以以分时的方式运行在单核CPU上面，也可以以真正的并发运行在多核CPU上面。</p>
<p>实现并发，不仅可以最大化地利用硬件的性能，也可以提高程序的功能。</p>
<p>###线程</p>
<p><code>线程(thread)</code>是组成进程的子单元，操作系统可以对线程进行单独的调用。在苹果系统上的API都是以线程为单元进行调度的。</p>
<p>多线程运行不仅能够在多核CPU上运行，也可以仅仅运行在单核CPU上。通过CPU分时，系统将极小的时间片分配给不同线程，让用户以为是多任务运行的。但是通过分时的效果不如多线程直接运行在多核CPU上。</p>
<p>通过使用<code>Instruments</code>中的<code>CPU strategy view</code>可以观察代码如何在多核CPU运行的。</p>
<p>##并发变成的API</p>
<p>在之前的文章已经谈过了高层封装的两种，这里的重点不是如何使用API。</p>
<p>在苹果的多线程中，有以下API供我们使用，从底层到高层一次如下:</p>
<ol>
<li>pthread</li>
<li>NSThread, 苹果在pthread上的封装</li>
<li>Grand Central Dispatch（GCD）</li>
<li>Operation Queues</li>
<li>Run Loops</li>
</ol>
<p>这里想重点谈一下Run Loops。</p>
<p><code>Run Loops</code>不同于<code>GCD</code>或者<code>Operation Queues</code>一样的并发机制，因为<code>Run Loops</code>并不能并行执行任务。不过在主dispatch/operation中，Run Loops提供了一种异步执行代码的机制。通过Run Loops，我们不必担心并发中的各种陷阱，就能<code>异步</code>执行任务。</p>
<p>在主线程中，每一个 Cocoa 和 CocoaTouch 程序中，Main run loop都是扮演了最重要的角色。因为是run loop 来处理相关的内核事件的。</p>
<p>线程和run loop是一一对应的。线程在创建的时候并没有run loop，如果不主动获取，那run loop就不会存在。Run Loop的创建在第一次获取的时候，销毁在线程结束的时候。除了主线程外，只能在一个线程的内部获取run loop。</p>
<p>对于run loop的详细，又是一篇很长的文章来说了。这里就不详细说了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2015/09/24/json-and-xml/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/24/json-and-xml/" itemprop="url">
                  json&amp;xml
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-09-24T16:44:36+08:00">
                2015-09-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index">
                    <span itemprop="name">Network</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网络传输格式-JSON-amp-XML"><a href="#网络传输格式-JSON-amp-XML" class="headerlink" title="网络传输格式 JSON &amp; XML"></a>网络传输格式 JSON &amp; XML</h1><p>第一次接触这两个格式还是在学校做一个财务管理系统的时候。在之前变成都是纯粹的单机编程，不设计到网络数据传输的问题。到了这个项目才开始考虑如何在服务器和客户端之间传输数据。项目中使用的是JSON，所以在这里先讲JSON的部分。</p>
<p>##JSON</p>
<p>JSON是一种轻量化的数据格式。他的特点就是方便已用。目前90%的网络传输都是依赖于JSON格式。</p>
<p>首先来看看JSON格式是怎么样的。</p>
<pre><code class="json">
&quot;access_token&quot;: &quot;ACCESS_TOKEN&quot;,

   &quot;expires_in&quot;: 1234,

   &quot;remind_in&quot;:&quot;798114&quot;,

   &quot;uid&quot;:&quot;12341234&quot;
</code></pre>
<p>这是一个常见的JSON格式。比较容易的看出，其实就是一种key-value的形式。</p>
<p>key我们都好了解，是一个string。那么value就会有不一样的值。通过对比OC的对象，我们可以更容易的理解JSON中的数据类型。</p>
<pre><code>            JSON                    OC

            {}                        NSDictionary

            []                        NSArray

            &quot;&quot;                        NSString

           数字                      NSNumber


</code></pre><p>知道了JSON所对应的OC对象，我们就可以通过解析JSON对象，将相关的数据转换成OC对象来存储。在这里，介绍一种能够在本地模拟API的方式，这也是由于自己找不到很好的开发API所以想在本地能够模拟API的方式。</p>
<p>##JSON Server 模拟 API</p>
<p>###第一步 安装</p>
<ul>
<li>安装Homebrew。这个可是个神器，能够管理mac上的第三方的库的工具。据说被作者写不出反转二叉树个谷歌拒了然后去了苹果。</li>
</ul>
<p><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p>
<ul>
<li>安装node.js</li>
</ul>
<p><code>brew install node</code></p>
<ul>
<li>安装json-server</li>
</ul>
<p><code>npm install -g json-server</code></p>
<h2 id="根据需求创建JSON"><a href="#根据需求创建JSON" class="headerlink" title="根据需求创建JSON"></a>根据需求创建JSON</h2><p>安装完毕后，随便找个你喜欢的文件夹，创建一个JSON格式的文件，如下</p>
<pre><code class="JSON">{
  &quot;posts&quot;: [
    { &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; }
  ],
  &quot;comments&quot;: [
    { &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 }
  ],
  &quot;profile&quot;: { &quot;name&quot;: &quot;typicode&quot; }
}
</code></pre>
<p>然后保存。</p>
<p>###启动JSON-Server</p>
<p>通过命令<code>json-server --watch JSON文件的名字.json</code>来启动Server</p>
<p>到这里，我们就相当于在本地创建了一个服务器能够相应我们想对应的请求。</p>
<p>以上面的的JSON文件为例</p>
<p><img src="/media/14430769630713.jpg" alt=""></p>
<p>当然，功能不止这么一点，JSON-Server还有更多方式，详见github<a href="https://github.com/typicode/json-server" target="_blank" rel="external">json-server</a></p>
<p>##OC对象和JSON对象的转换</p>
<ul>
<li>通过<code>NSJSONSerialization</code>来序列化JSON.</li>
</ul>
<pre><code>![](/media/14430773793672.jpg)


</code></pre><p>输出的结果</p>
<p><img src="/media/14430774045308.jpg" alt=""></p>
<p>对比上面的JSON数据，我们可以看出解析的结果是正确的</p>
<ul>
<li>通过第三方库JSONKit来解析</li>
</ul>
<p> 下载地址 <a href="https://github.com/johnezang/JSONKit" target="_blank" rel="external">JSONKit</a></p>
<p> <img src="/media/14430745214364.jpg" alt=""></p>
<ul>
<li>使用Mantle</li>
</ul>
<p>在项目中用的最多的方法，也觉得非常好用</p>
<p>下载地址：<a href="https://github.com/Mantle/Mantle" target="_blank" rel="external">Mantle</a></p>
<p>使用的方法：</p>
<ol>
<li>在本地创建对应的OC类<br><img src="/media/14430784491980.jpg" alt=""></li>
</ol>
<ol>
<li>实现相关的方法</li>
</ol>
<p><img src="/media/14430794069120.jpg" alt=""></p>
<p>第三种是直接将JSON通过一定的方法转成了OC的类对象。在使用的时候感觉更方便。</p>
<p>##XML</p>
<p>虽然JSON在网络传输中有90%的使用率，但是我们依然不能放弃10%的XML是吧。</p>
<p>XML全称是Extensible Markup Language，译作“可扩展标记语言”<br>跟JSON一样，也是常用的一种用于交互的数据格式<br>一般也叫XML文档（XML Document）</p>
<p>下面是一个典型的XML文件的结构</p>
<pre><code>一个元素包括了开始标签和结束标签
拥有元素内容：&lt;city&gt;上海&lt;/city&gt;
没有元素内容：&lt;city&gt;&lt;/city&gt;
没有元素内容的简写：&lt;city/&gt; 

一个元素可以嵌套若干个子元素（不能出现交叉嵌套）
&lt;citys&gt;
    &lt;city&gt;
        &lt;name&gt;上海&lt;/name&gt;
        &lt;weather&gt;大暴雨&lt;/weather&gt;
          &lt;air&gt;舒适&lt;/air&gt;
    &lt;/city&gt;
&lt;/citys&gt;

规范的XML文档最多只有1个根元素，其他元素都是根元素的子孙元素
XML中的所有空格和换行，都会当做具体内容处理

一个元素可以拥有多个属性，属性值必须用 双引号&quot;&quot; 或者 单引号&#39;&#39; 括住。
&lt;city name=&quot;上海&quot; weather=&quot;大暴雨&quot; air=&quot;舒适&quot; /&gt;


属性表示的信息也可以用子元素来表示，比如

   &lt;city&gt;
        &lt;weather&gt;大暴雨&lt;/weather&gt;
          &lt;air&gt;舒适&lt;/air&gt;
    &lt;/city&gt;
</code></pre><p>解析XML有两种方式</p>
<ol>
<li>DOM解析：一次性将整个XML文档加载进内存，比较适合解析小文件</li>
<li>SAX解析：从根元素开始，按顺序一个元素一个元素往下解析，比较适合解析大文件</li>
</ol>
<p>在iOS SDK里面，提供了两种解析的框架</p>
<ol>
<li>NSXMLParser：它是基于objective-c语言的sax解析框架，是ios sdk默认的xml解析框架，不支持dom模式。</li>
<li>libxml2: 它是基于c语言的xml解析器，被苹果整合在ios sdk中，支持sax和dom模式。</li>
</ol>
<p>同样，第三方也有许多解析XML的库。这里不打算讲第三方的，一个XML使用的比较少，一个使用SDK自身的效率往往已经非常好了。</p>
<p>###NSXMLParser</p>
<p>NSXMLParser属于SAX解析，是从上往下依次解析每个元素，在解析到每个元素的时候会通知代理，所以使用NSXMLParser必须遵守他的协议。<br>使用非常简单</p>
<p><img src="/media/14430815879826.jpg" alt=""><br>从当前项目读取XML文件，读出数据，穿件解析器，设置代理，开始解析。</p>
<p>XML文件内容如下</p>
<p><img src="/media/14430816475695.jpg" alt=""><br>设置代理后，我们要实现代理方法，主要有以下方法，直接上图了</p>
<p><img src="/media/14430816906329.jpg" alt=""></p>
<p><img src="/media/14430817012681.jpg" alt=""></p>
<p><img src="/media/14430833160910.jpg" alt=""></p>
<p><img src="/media/14430833236999.jpg" alt=""></p>
<p>###libxml2</p>
<p>重点在于导入libxml2的库</p>
<p><img src="/media/14430836046841.jpg" alt=""></p>
<p><img src="/media/14430836140287.jpg" alt=""></p>
<p><img src="/media/14430836178120.jpg" alt=""></p>
<p><img src="/media/14430836230051.jpg" alt=""></p>
<p><img src="/media/14430836285068.jpg" alt=""></p>
<p>编译项目，通过了就没问题了。</p>
<p>用法参见<a href="https://github.com/neonichu/GDataXML" target="_blank" rel="external"></a></p>
<p>##总结</p>
<p>在实际使用中，还JSON用的更多，所以对于JSON的解析过程要更加了解。对于XML，有一些公司任然会使用，而一些现存的数据也会用XML存储，所有也要有一定的了解。</p>
<p>这篇文章讲解了在网络通信中数据的格式。下一篇的话就进入iOS内如何进行网络通信了。虽然使用AFNetWorking已经有段时间了，但是对内部整个机制并不了解，要好好补课了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2015/09/22/arc/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/22/arc/" itemprop="url">
                  重新认识ARC
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-09-22T17:48:06+08:00">
                2015-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>第一次接触ARC还是在第一次拿到项目的时候。学习OC的时候使用的教材主要是通过MRC来讲解Retain Counting(引用计数)的。后面只是简单的了解了下ARC是编译器在编译的过程中自动去估算对象的生命周期来自动添加retain和realse的。解放了双手，也就没有什么动力去研究了。现在得空了，是时候增强自己的技能树。当前的目标如下</p>
<p>&lt;!--more--&gt;  
</p>
<ol>
<li>增加网络编程的相关知识<ul>
<li>TCP/IP HTTP HTTPS 协议的学习和了解</li>
<li>JSON和XML的解析</li>
<li>iOS自身关于网络请求相关的类和API</li>
<li>第三方库AFNetWorking源码阅读</li>
</ul>
</li>
<li>增加iOS内核方面的知识<ul>
<li>内存基本知识和管理方式</li>
<li>ARC</li>
<li>进程线程</li>
<li>RunTime</li>
</ul>
</li>
</ol>
<p>简单的看是两个大类七个点，但是感觉每一个点都非常多东西。目前暂时把1.1的点给补完了。不过任然需要投入大量的时间去复习。这里打算整合2.1和2.2。</p>
<p>##内存管理<br>学过计算机基础的人对于内存都不陌生，哪怕是没有计算机基础的人也明白内存对于电脑（终端）的重要性。内存管理，就是在程序运行的过程中，申请，使用，释放内存的过程。程序写的好不好，就看你在完成功能的同时是不是使用了尽可能少的内存。</p>
<p><em>堆和栈</em></p>
<p>在内存中，有两个重要的概念，分别是<code>堆和栈</code>。这里不仅仅指代他们的数据结构。我们知道，一个函数执行的时候，他会被压入栈中。栈中的内存单元保存了函数的返回地址，局部变量，传参等数据。当函数被弹出栈的时候，一切数据都会被销毁。而<code>堆</code>上的数据是由开发者自行申请管理的，生命周期由开发者自行掌握。</p>
<p><em>引用计数</em></p>
<p>学过OC的人都知道，在OC中管理内存的方法是<code>引用计数</code>(Retain Counting)。通过对堆和栈的了解，我们可以得出OC上的对象<em>都是在堆上</em>的。</p>
<p>在苹果开发文档里面有一张图很好的说明的通过引用计数来管理对象生命周期的过程。</p>
<p><img src="/media/14429735006902.jpg" alt="引用计数"></p>
<p>同样，引用计数也遵循几大内存管理原则</p>
<ol>
<li>谁申请谁拥有</li>
<li>肯以申请拥有一个存在的对象</li>
<li>当不需要的再拥有对象的时候，申请释放</li>
<li>不能释放不属于自己没有拥有的对象</li>
</ol>
<p>##Automatic Reference Counting (ARC)</p>
<p>在学习iOS开发半年后，ARC给我留下了很深的印象。ARC是苹果在引用计数的基础上改善了编译器实现的功能。要了解ARC，首先要看看在没有ARC之前开发者是怎么去通过引用计数管理的。</p>
<p>在ARC之前，我们统称为<code>MRC（Manual Reference Counting</code>，即手动引用技术。通过调用<code>retain</code>和<code>release</code>来管理对象的生命周期。有了ARC之后，在编译的过程中，编译器可以根据上下文估算对象的生命周期，以此来自动的添加<code>retain</code>和<code>release</code>。</p>
<p>注意，ARC只对OC对象有作用，对于C的类型对象不则按照C的内存管理的方法去管理。</p>
<p>如果在工程中开启了使用ARC，那么就要遵循ARC定义的一些规范</p>
<ol>
<li>不能显示的调用<code>dealloc</code>,<code>ratain</code>,<code>release</code>,<code>retainCount</code>,<code>autoRelease</code>。</li>
<li>如果要复写<code>dealloc</code>方法，不需要显示调用<code>[super dealloc]</code>方法。</li>
<li>不能再使用<code>AutoReleasepool</code></li>
</ol>
<p><em>ARC下的修饰符</em></p>
<p>在@Property 中，有四种修饰符是ARC提供的，他们分别是</p>
<ol>
<li>strong</li>
<li>weak</li>
<li>unsafe_unretained</li>
<li>__autoreleasing</li>
</ol>
<p>其中，重点来谈谈strong和weak</p>
<ul>
<li>strong。我们理解为强引用。当前的对象实际拥有这个对象。默认情况下ARC使用的strong来修饰。</li>
<li>weak。相对于strong的强引用，weak指的是弱引用。当引用的对象被释放掉的时候，当前引用对象会被自动置nil。weak通常被用来解决循环引用的问题。</li>
</ul>
<p><code>__autoreleasing</code>和<code>__unsafe_unretained</code>在实际应用中是很少的。<code>__unsafe_unretained</code>是为了兼容iOS4之前的版本，现在基本上不会使用了，主要是为了实现weak的功能。<code>__autoreleasing</code>是表示在autorelease pool中自动释放对象的引用。</p>
<h2 id="block-在ARC下"><a href="#block-在ARC下" class="headerlink" title="block 在ARC下"></a>block 在ARC下</h2><p>block在之前已经小小的讨论过了，出现的几个问题都有谈论到，这里主要从ARC的角度上再谈一谈。</p>
<p>block在ARC下最特殊的地方就是怎么去解决循环引用。在block的篇章中没有很详细讨论，原因也是没从内存的角度来看。这里详细讲下循环引用产生原因和在ARC下解决循环引用的方法。</p>
<p>&gt;<br>You can use lifetime qualifiers to avoid strong reference cycles. For example, typically if you have a graph of objects arranged in a parent-child hierarchy and parents need to refer to their children and vice versa, then you make the parent-to-child relationship strong and the child-to-parent relationship weak. Other situations may be more subtle, particularly when they involve block objects.<br>&gt;<br>In manual reference counting mode, <strong>block id x; has the effect of not retaining x. In ARC mode, </strong>block id x; defaults to retaining x (just like all other values). To get the manual reference counting mode behavior under ARC, you could use <strong>unsafe_unretained </strong>block id x;. As the name <strong>unsafe_unretained implies, however, having a non-retained variable is dangerous (because it can dangle) and is therefore discouraged. Two better options are to either use </strong>weak (if you don’t need to support iOS 4 or OS X v10.6), or set the __block value to nil to break the retain cycle.<br>&gt;<br>The following code fragment illustrates this issue using a pattern that is sometimes used in manual reference counting.</p>
<p>上面是苹果官方文档对循环引用的解释。通过引用计数，我们了解到，如果有两个对象，对彼此都是强引用的话，双方都无法释放对方，也就无法释放delloc对象，最终就造成了死循环。在iOS5以下的版本里面，我们可以通过手动使用<code>unsafe_unretained</code>来使其中一个变量变成野指针。而在ARC下，我们通过使用weak来修饰其中一个变量，这样在block中就不存在双方强引用的抢矿。</p>
<p>但是，上面的处理方法有个问题。我们不知道weak修饰的对象什么时候会被释放掉了，有可能在执行block里面的对象在之前就已经被释放掉了。在AFNetWorking中，提供了一个非常好的解决思路</p>
<p><img src="/media/14429947239639.jpg" alt=""></p>
<p>上面方法中，在block外先将self用<code>weak</code>引用一个weakSelf，进入block后再使用一个<code>_strong_typeof</code>去创建一个strong引用对象。这样的做法既能避免产生循环引用，也能避免weak对象提前被释放掉。</p>
<p>##ARC与Toll-Free Bridging</p>
<p>Toll-Free Briding保证了在程序中，可以方便和谐的使用Core Foundation类型的对象和Objective-C类型的对象。但是，我们知道，到了ARC的时候，两者的内存管理方法不同了。对于一种对象，我们不能用该两种内存管理方法去管理。所以在进入ARC之后，Toll-Free Bridging也进行了相应的变化。</p>
<p><em>__bridge</em></p>
<p>只是申明了类型转变，并没有改变内存管理方法。</p>
<p><em>__bridge_retained（修饰符） or CFBridgingRetain（函数）</em></p>
<p>表示将指针类型转变的同时，将内存管理的责任由原来的Objective-C交给Core Foundation来处理，也就是，将ARC转变为MRC。</p>
<p><em>__bridge_transfer（修饰符） or CFBridgingRelease（函数）</em></p>
<p>这个修饰符和函数的功能和上面那个__bridge_retained相反，它表示将管理的责任由Core Foundation转交给Objective-C，即将管理方式由MRC转变为ARC。</p>
<p>上面就是要谈的ARC的内容了。其实ARC的坑比起MRC已经少了很多了，对于我们可怜的程序员来说已经是很大的解放了。</p>
<p>这里对于内存管理仅仅是基于OC简单的谈了谈，觉得还是不够深刻，主要是自己在这方面的知识的确很欠缺。读了<br><a href="http://casatwy.com/ccheng-xu-de-nei-cun-guan-li.html" target="_blank" rel="external">C程序的内存管理</a>这篇文章学到了很多，在这里也安利一下。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://csbzhixing.github.io/2015/09/18/title/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="csbzhixing">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://p3.pstatp.com/large/ab000310321818ab99.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="学海无涯">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="学海无涯" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/18/title/" itemprop="url">
                  IP TCP HTTPs 随便谈
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-09-18T16:48:55+08:00">
                2015-09-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index">
                    <span itemprop="name">Network</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="IP-TCP-HTTPs-随便谈"><a href="#IP-TCP-HTTPs-随便谈" class="headerlink" title="IP TCP HTTPs 随便谈"></a>IP TCP HTTPs 随便谈</h1><p>在总结自己的技能书的缺点后，决定优先补充自己在计算机网络上知识的漏洞。现在互联网企业，离开了互联网什么都不是。对互联网，普通人可能停留在概念和使用上，而开发人员应该去深入的了解运行进制，进而去优化自己开发的产品。这篇文章，主要是记录自己最近看的一些资料的笔记。<br>&lt;!--more--&gt;  </p>
<p>##IP 协议</p>
<p>IP协议，是网络协议（Internet Protocol）的缩写。IP协议是互联网众多协议的基础。</p>
<p>IP协议实现了解<code>*分组交换网络*</code>。在协议下，每个机器被称为<code>*主机*</code>，IP协议明确了主机之间数据包的传输方式。</p>
<p>数据包，也就是一段二进制数据，包含了传输源的主机的信息。IP协议的特点是<code>*尽力服务*</code>（best effort），提供有效的服务并尽可能的传输。这说明，在传输过程中，可能会丢失数据包，也可能传输了多个相同的数据包。</p>
<p>IP 网络中的主机都配有自己的地址，被称为<code>*IP 地址*</code>。每个数据包中都包含了源主机和目标主机的 IP 地址。IP 协议负责路径计算，即 IP 数据包在网络中的传输传输时，数据包所经过的每一个主机节点都会读取数据包中的目标主机地址信息，以便选择朝什么地方传送数据包。</p>
<p>##蛋疼的IPv4</p>
<p>如今，多数数据包任然使用的是IPv4（版本4），每一个IP地址都是32位的。比如192.168.1.1就是一个IPV4地址。我们可以算下，IPv4有多少个地址。。嗯，好像很多有43亿吗。。但是呢，到了10年的时候，就已经不到8%的了。。</p>
<p>人们发现IPV4不够用啊，快用完了啊，用完了就不能加主机了啊！！！那怎么办，启用新的协议版本啊，所以除了个IPv6，将地址扩充到128位了。比如<code>2001:0db8:85a3:0042:1000:8a2e:0370:7334</code><br>就是一个IPv6的地址了。</p>
<p>128位就是2的128次方个，据说够地球上每个沙子配一个IP了。但是呢，这个协议转换的很慢，目前基本国内的都是还是使用IPv4协议。。看来也不是很着急么。。</p>
<p>##IP数据包的结构<br>一个IP数据包通常包括一个数据头部（header）和有效数据（payload）。有效数据自然是数据包中要传送的数据。而数据头部就是包含了一些传输数据相关的数据。</p>
<p>####我们先来看个IPv4的头部</p>
<p><img src="/media/Screen%20Shot%202015-09-20%20at%2020.15.59.png" alt="Screen Shot 2015-09-20 at 20.15.59"></p>
<p>可以看到，头部信息包含了当前版本的信息，payload采用的协议。Total Length 表明是有效数据加上头部信息长度的总长度。</p>
<p>####在来看看一个IPv6的报头信息</p>
<p><img src="/media/14427519874258.jpg" alt=""></p>
<p>IPv6的头部长度固定到了40.同时IPv6可以链接下一个头部信息（Next Header）。</p>
<p>##数据传输</p>
<p>我们知道，在数据链路层对对所传输的数据帧数有限制，<code>*（MTU，最大传输单元）*</code>。在IPv4的上，使用<code>*分片*</code>来对数据包进行处理。具体来说，我们可以认为如果数据超过了最大传输单元，那么就会将数据切成几片。当数据到达目标主机后，可以根据分片的信息进行重组。当然，发送源可以选择不进行对数据进行<code>*分片*</code>。如果超过了链路层最大传输单元又不进行<code>*分片*</code>的话，发送源就会收到ICMP（Internet Control Message Protocol，Internet报文控制协议）的数据帧超长报告信息。</p>
<p>在IPv6中，如果数据包超过了长度限制，路由会直接丢弃数据包（好狠）并且向ICMP6报告数据帧过长。然后数据源和目标源会根据这个特性来进行<code>路由发现</code>，就是寻找两端之间最大传输单元的路由。找到最大传输单元的路由后，仅当此时数据包任然超过最大传输单元的时候，IPv6才会进行分片。`对于IPv6下的TCP来说，不会造成什么影响。</p>
<hr>
<p>到此，IP协议就到了一个段落了。IP协议是TCP协议的基础，因此了解是必须的。</p>
<p>##TCP协议</p>
<p>TCP协议是重头戏。TCP协议是重头戏。TCP协议是重头戏。重要的事情要说三遍。</p>
<p>上面说了，IP协议是基于<code>尽可能服务</code>的，那么TCP协议就是要基于IP协议，解决IP协议采用的不可靠传输引起的复杂的问题。因此，下面的重点就是来谈谈TCP连接的三个部分：建立连接，传输数据，断开连接的详细过程</p>
<p>####TCP建立连接</p>
<p>首先，我们要知道TCP连接是全双工的,是建立在两个主机之间的。每个连接都存在两种角色：<code>服务器端，监听连接</code>，<code>客户端，主动连接服务器端</code>。客户端主动连接服务器端被称为<code>active open(主动打开)</code>。而服务器端这种监听连接的行为被称为<code>passive open(被动打开)</code>。</p>
<p><strong>三次握手</strong></p>
<p>TCP建立连接是一个确认和反复确认的过程，我们习惯统称为三次握手。这个地方也是几乎所有面试会问的地方，需要注意了。</p>
<p>三次连接，具体的过程有语言描述为以下的过程。</p>
<blockquote>
<ol>
<li>客服端向服务器端发送SYN包和一个随机序列号X，表示本次的连接的身份。</li>
<li>服务器端收到客服端发送的连接的请求以后，发送一个SYN-ACK包和一个确认ack号X+1(确认序列号X的连接请求确认)。此时服务器还会发送一个随机序列号Y，表示向客户端连接的请求。</li>
<li>客户端收到服务器的回复后，会发送一个ACK包，一个确认号Y+1和序列号X+1给服务器。</li>
</ol>
</blockquote>
<p>SYN包，为<code>synchronize sequence numbers (同步序列号)</code>。用于确认两段传输数据的身份，确保数据包最后都达到了应该到的地方。在建立连接的时候，源和目标都需要确认<code>同步序列号</code>。</p>
<p>ACK包，为<code>acknowledgment (确认)</code>。某一端接到数据后，通过回传序列号来确认收到报文。</p>
<p><img src="/media/14428004882999.jpg" alt="三次握手"></p>
<p>####传输数据</p>
<p>建立连接，就是为了传输数据。发送端发出的报文都会带有一个序列号，与当前已传送的字节总数有关。接受端会根据已经接收的报文给发送端传送确认报文，确认信息同样在头部的缩写带的ACK。</p>
<p><img src="/media/14427976037921.jpg" alt=""></p>
<p>注意的整个过程是双向的。两端都会持续的发送数据。X端发送的数据不会等到Y端发送确认后才发送下一个报文。</p>
<p>TCP协议是可靠的传输协议，所以有一系列复杂的机制来进行具体的的拥塞控制。需要处理的问题如下:<code>丢失报文重发</code>，<code>动态调整发送报文的频率</code></p>
<p><strong>流量控制</strong></p>
<p>流量控制的原则就是发送数据的一方的速度不能比接受数据一方的速度要快。接收方，也就是<code>接收窗口</code>会告诉发送方自身<code>接收窗口</code>数据缓冲区的大小。在tcp包，通过两个两个关键的字段可以得出接收窗口的大小:<code>win -- 窗口大小</code>和<code>wscale -- 窗口发大因子</code> 。如果win=65535 , wscale = 4，那么我们可以计算出接收窗口的大小是 64kB * 4 = 256kB。</p>
<p><strong>拥塞控制</strong></p>
<p>拥塞控制相比于流量控制要复杂一些。拥塞控制就是根据当前网络情况计算出当前网络数据传输的最佳速度。首先我们要认识到，最佳速度不一定就是要最快。一方面，我们希望以更快的速度传输数据。另一方面，由于传输的速度过快，导致大量的数据传入会使处理性能受到影响。在分组交换网络中有一个特点就是<code>超负荷崩溃</code>。当负载过大的时候，数据包之间会产生拥塞，直接导致丢包率上升。</p>
<blockquote>
<p>拥塞控制需要充分考虑对流量的影响。RFC 5681 中对 TCP 拥塞控制有 6,000 字左右的阐述。发送方要时刻关注来自接收方的确认信息。要做到这点并不简单，有的时候还需要一定的妥协。要知道底部 IP 协议数据包是无序传输的，数据包会丢失也会重复。发送方需要评估 RTT 往返时间，然后基于 RTT 去确定是否收到了接收方的确认信息。重发数据包也有很大代价，除了连接延迟问题，网络的负载也会发生明显的波动。导致 TCP 需要不停的去适应当前网络情况。</p>
<p>更重要的是，TCP 连接本身是易变的。除了数据传输，连接的两端还会不时的发送一些提醒和确认信息以便可以适当的调整状态来维持连接。</p>
<p>基于这种一直在相互协调中的连接关系，TCP 连接往往会是短暂而低效的。在建立连接的初期，TCP 协议算法还不能完全了解当前网络状况。而在连接将要结束的时候，反馈给发送方的信息又可能不充分，这样就很难对连接状况做出实时的合理的评估。</p>
</blockquote>
<p><em>四次挥手，断开连接</em></p>
<p>建立连接是通过<code>三次握手</code>，而释放连接是通过<code>四次握手</code>。在最下方有图示解释整个过程。那么为什么需要四次握手才能释放连接呢？</p>
<p>上文提到了，TCP是全双工的，因此每个方向上的连接需要单独关闭。这个原则就是当一方没有数据可以传送的时候，发送FIN来终止这一方的连接，但是另一方向上的数据仍然可以发送。当另一方向也发送了FIN的时候，整个连接才完全的关闭了。无论服务器端还是客户端都可以发送来FIN来主动关闭连接。</p>
<p><img src="/media/14428004433668.jpg" alt="四次挥手"></p>
<p>##HTTPS</p>
<p>之前的博文谈到了HTTP（超文本传输协议）。如今苹果操作系统iOS也升级到了iOS9。在iOS9中强制所有网络传输协议使用HTTPS。看来对HTTPS的了解是势在必行的了。</p>
<p>HTTPS,实际上可以看作HTTP的加密版本。HTTPS将HTTP协议数据包放到SSL/TSL层加密后，在TCP/IP蹭去传输。到了目标源后，在SST/TSL将数据包解密，传递到HTTP层就是普通的HTTP数据包了。</p>
<p>HTTPS = HTTP + SSL/TSL</p>
<p><strong>SSL/TSL</strong></p>
<p>关于SSL/TSL，我们可以参考下面两篇文章：</p>
<p>!<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>
<p>!<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a></p>
<p>简单的来说，通过SSL/TSL四次握手，来解决下面三个问题。</p>
<ol>
<li>数字证书：该证书包含了公钥等信息，一般是由服务器发给客户端，接收方通过验证这个证书是不是由信赖的CA签发，或者与本地的证书相对比，来判断证书是否可信；假如需要双向验证，则服务器和客户端都需要发送数字证书给对方验证；</li>
<li>三个随机数：这三个随机数构成了后续通信过程中用来对数据进行对称加密解密的“对话密钥”。<br>首先客户端先发第一个随机数N1，然后服务器回了第    二个随机数N2（这个过程同时把之前提到的证书发给    客户端），这两个随机数都是明文的；而第三个随机    数N3（这个随机数被称为Premaster secret），    客户端用数字证书的公钥进行非对称加密，发给服务    器；而服务器用只有自己知道的私钥来解密，获取第    三个随机数。这样，服务端和客户端都有了三个随机    数N1+N2+N3，然后两端就使用这三个随机数来生    成“对话密钥”，在此之后的通信都是使用这个“对话    密钥”来进行对称加密解密。因为这个过程中，服务端    的私钥只用来解密第三个随机数，从来没有在网络中    传输过，这样的话，只要私钥没有被泄露，那么数据    就是安全的。</li>
<li>加密通信协议：就是双方商量使用哪一种加密方式，假如两者支持的加密方式不匹配，则无法进行通信；</li>
</ol>
<p>具体的可以参考上面两篇文章的内容，去了解SSL/TSL加密的过程。在这里想重点说的是在iOS中使用HTTPS。</p>
<p>在iOS中，常用的是<code>NSURLConnection</code>支持HTTPS的实现。而常用的第三方库<code>AFNetworking</code>封装了使用<code>NSURLConnection</code>实现的逻辑代码，更加完善。在<code>AFNetworking</code>中使用的方法如下</p>
<pre><code>Objective-C

NSURL * url = [NSURL URLWithString:@&quot;https://www.google.com&quot;];
AFHTTPRequestOperationManager * requestOperationManager = [[AFHTTPRequestOperationManager alloc] initWithBaseURL:url];
dispatch_queue_t requestQueue = dispatch_create_serial_queue_for_name(&quot;kRequestCompletionQueue&quot;);
requestOperationManager.completionQueue = requestQueue;

AFSecurityPolicy * securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];

//allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO
//如果是需要验证自建证书，需要设置为YES
securityPolicy.allowInvalidCertificates = YES;

//validatesDomainName 是否需要验证域名，默认为YES；
//假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。
//置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。
//如置为NO，建议自己添加对应域名的校验逻辑。
securityPolicy.validatesDomainName = YES;

//validatesCertificateChain 是否验证整个证书链，默认为YES
//设置为YES，会将服务器返回的Trust Object上的证书链与本地导入的证书进行对比，这就意味着，假如你的证书链是这样的：
//GeoTrust Global CA 
//    Google Internet Authority G2
//        *.google.com
//那么，除了导入*.google.com之外，还需要导入证书链上所有的CA证书（GeoTrust Global CA, Google Internet Authority G2）；
//如是自建证书的时候，可以设置为YES，增强安全性；假如是信任的CA所签发的证书，则建议关闭该验证，因为整个证书链一一比对是完全没有必要（请查看源代码）；
securityPolicy.validatesCertificateChain = NO;

requestOperationManager.securityPolicy = securityPolicy;
</code></pre><p>##杂谈</p>
<p>关于连接。TCP连接容易在两个地方出问题：初始设置，以及通过连接传输最后一部分的内容。</p>
<hr>
<p>建立连接的时候，TCP由于要进行三次握手，所以在这过程中会有一定的时间损耗。一般一个移动终端向服务发送一个数据包普遍需要250ms, 三次握手的话就是需要750ms。而在HTTPS中则更加夸张。因为HTTPS需要四次握手。。。嗯，在TCP和HTTPS都握手完后，大概需要1750ms.是建立一个HTTP连接的两倍。为了安全，就肯定要牺牲时间效率。</p>
<p>此外，由于TCP需要侦测当前最佳的转发路由，所以在传送大量的数据时，需要不停地去调整以便得到最佳速度。这种算法被称为<code>慢启动</code>。注意到，慢启动在数据链路层传输质量差的网络上表现的更差，无线网络就是典型的例子。(4G说，怪我咯)。</p>
<hr>
<p>通过TCP释放连接的过程，我们也知道可能存在问题</p>
<blockquote>
<p>如果发送方完成数据发送，接受方自然会停止发送 ACK 确认。在最后四个报文传输的过程中，快速重发算法是没有办法处理这四个报文的数据包的丢失问题的（因为不会收到三个相同的确认 ACK，所以不能界定传输丢包）。在常规网络环境下，四个数据包相当于 5.7kB 的数据规模。总之，在这最后 5.7kB 的传输的过程中，快速重发机制是无效的。针对这种情况，TCP 会启用其他机制来侦测丢包问题。对于这种情况，重传操作可能要消耗几秒钟去执行，这并不奇怪</p>
</blockquote>
<hr>
<p><em>超时处理</em></p>
<p>在APP实际处理中，经常发生网络请求超时的现象。许多APP大概在15秒后收不到反馈就会提示超时信息。这种设计其实并不是很友好。我们知道，只有TCP连接还在，TCP都会保证将请求发送出去并会等待响应的返回，只是时间长短的问题。</p>
<p>个人在这里参考了一些APP的做法，觉得应该在每次请求的时候设置一个计时器，当计时器到达倒数完成后，可以提示用户是否继续网络请求，如果取消就将TCP连接断开，如果继续就继续等待网络请求响应。</p>
<p>##最后</p>
<p>了解了IP TCP HTTPS后，接下来想阅读一些文章怎么从这些方面入手去优化网络请求。在互联网时代，数据和网络是承载产品的基础。因此，网络，怎么深入学习都不过分。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://p3.pstatp.com/large/ab000310321818ab99.jpg"
               alt="csbzhixing" />
          <p class="site-author-name" itemprop="name">csbzhixing</p>
          <p class="site-description motion-element" itemprop="description">之行的博客</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">28</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">csbzhixing</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  

  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.0"></script>



</body>
</html>
