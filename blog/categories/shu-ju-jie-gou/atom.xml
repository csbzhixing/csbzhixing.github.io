<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 数据结构 | 之行海涯]]></title>
  <link href="http://csbzhixing.github.io/blog/categories/shu-ju-jie-gou/atom.xml" rel="self"/>
  <link href="http://csbzhixing.github.io/"/>
  <updated>2015-12-03T23:14:50+08:00</updated>
  <id>http://csbzhixing.github.io/</id>
  <author>
    <name><![CDATA[之行]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一周刷题总结 - 2]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/11/13/leetcode2/"/>
    <updated>2015-11-13T22:08:35+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/11/13/leetcode2</id>
    <content type="html"><![CDATA[<p>又到了一周题目总结时间。到现在为止总共完成了三十道题，每天大概做1-3题。感觉这个步骤还是比较适合自己的进度的。</p>

<ul>
<li>leetcode 9</li>
</ul>


<p>给出一个Int值，判断是否是回文数字。</p>

<p>我们可以想到，如果是字符串的话，我们可以通过字符串的处理方式来处理，但这里是一个数字。我们可以从回文的定义知道，如果我们将整个数字反转过来，如果仍然等于原来的数字，那么这个数字就是回文数。</p>

<p>代码如下</p>

<pre><code class="C">bool isPalindrome(int x) {
    if(x&lt;0) return false;
    if(x&lt;10) return true;

    int y=0,temp = x;

    while(temp)
    {
        y = y*10 + (temp%10);
        temp/=10;
    }

    return x==y;
}
</code></pre>

<ul>
<li>leetcode 26</li>
</ul>


<p>移除一个数组中重复的数字。</p>

<p>根据题意，我们只需要将重复的数字不停地移动到数组末尾，然后缩短数组大小就可以了。</p>

<pre><code class="C">int removeDuplicates(int* nums, int numsSize) {

    if(numsSize&lt;2) return numsSize;

    int cur = 0;int temp = nums[0];

    for(int i = 1;i&lt;numsSize;i++)
    {
        if(nums[i] == temp) continue;
        else
        {
            nums[cur+1] = nums[i];
            cur++;
            temp = nums[i];
        }
    }    
    return cur+1;
}
</code></pre>

<ul>
<li>leetcode 136</li>
</ul>


<p>给出一个数组，找出数组中唯一一个只出现了一次的数，其他的数都出现了两次，要求线性时间内完成且不能用额外的空间。</p>

<p>这道题给的难度分类是中等，但是我看了下题目的通过率很高，说明又很巧妙地方法。我自己在开始做得时候想到的都都要用额外的存储空间。在看了别人的方法后才知道原来可以用异或方法，因为异或方法相当于交换了两个数。所以我们要做得就是遍历一次数组，用一个数与每个数组的数异或，最后保留的数就是唯一一个出现了一次的数。</p>

<pre><code class="C">int removeDuplicates(int* nums, int numsSize) {

    if(numsSize&lt;2) return numsSize;

    int cur = 0;int temp = nums[0];

    for(int i = 1;i&lt;numsSize;i++)
    {
        if(nums[i] == temp) continue;
        else
        {
            nums[cur+1] = nums[i];
            cur++;
            temp = nums[i];
        }
    }

    return cur+1;
}
</code></pre>

<p>同样地,leetcode还给出了一道相似的题目，就是</p>

<ul>
<li>leetcode 260</li>
</ul>


<p>这道题目和上面的题目基本一样，唯独不同的是给出的数组中有两个数只出现了一次。</p>

<p>题目中提到了，要在线性时间内完成，我们还是要考虑从上面的题目中怎么改进就可以完成这道题目。</p>

<pre><code class="C">int* singleNumber(int* nums, int numsSize, int* returnSize) {
    int i, *result = calloc(*returnSize = 2, sizeof(int));
    for(i = 0; i &lt; numsSize; result[0] ^= nums[i++]);
    for(i = 0; i &lt; numsSize; i++)
        if(nums[i] &amp; result[0] &amp; -result[0])
            result[1] ^= nums[i];
    result[0] ^= result[1];
    return result;
}
</code></pre>

<p>这个方法，首先找出了一个result[0]，这个是保存了两个出现了一次的的数字的异或结果a xor b;         <br/>
我们知道 如果a != b的话，那么a xor b就会保准他们每个数字的一部分的二进制。
那么第二部我们通过异或就可以刷选出一个结果。
通过 a xor b的结果再异或，就可以得出另一个结果。</p>

<p>通过上面两道题目可以得出，简简单单的异或有时候可是非常强大的。</p>

<h2>小结</h2>

<p>虽然每周做得题目不止这么多，但是受限时间，只能慢慢整理，优先整理我觉得值得思考的题目。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一周刷题总结 - 1]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/11/06/week-code-1/"/>
    <updated>2015-11-06T22:36:06+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/11/06/week-code-1</id>
    <content type="html"><![CDATA[<p>上周开始复习算法和数据结构，一周每天在睡前都拿出不少时间去学习，做了一些题目，想来每周都应该把相关的题目总结一下，才能更好的去学习。</p>

<ul>
<li>237  Delete Node in a Linked List</li>
</ul>


<p>这是上次笔记里面写过的内容，但是我自己写得时候又出现了问题，看来简单的问题业不能去忽略。</p>

<pre><code class="c">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
void deleteNode(struct ListNode* node) {
    if(node == NULL) return;
    struct ListNode *temp = node-&gt;next;
    node-&gt;val = temp-&gt;val;
    node-&gt;next = temp-&gt;next;
    free(temp);
}
</code></pre>

<ul>
<li>171   Excel Sheet Column Number</li>
</ul>


<p>简单的来说就是一个26进制的数，没什么难点</p>

<pre><code class="c">int titleToNumber(char* s) {
    int length = strlen(s);

    int all = 0;

    for(int i=0;i&lt;length;i++)
    {
        all=((s[i]-'A')+1) + all * 26;
    }

    return all;
}
</code></pre>

<ul>
<li>169   Majority Element</li>
</ul>


<p>出现超过n/2的数，通过遍历就可以了</p>

<pre><code class="c">
int majorityElement(int* nums, int numsSize) {
    int time=0,maj;
    for(int i=0;i&lt;numsSize;i++)
    {
        if(time == 0)
        {
            maj = nums[i];
        }
        if(nums[i]==maj) 
        {
            time++;
        }
       else{
         time--;  
       } 
    }
    return maj;
}
</code></pre>

<ul>
<li>206   Reverse Linked List</li>
</ul>


<p>反转链表，基础题目</p>

<pre><code class="c">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* reverseList(struct ListNode* head) {

    struct ListNode* pre = NULL;
    struct ListNode* cur = head;
    struct ListNode* next = NULL;

    while(cur)
    {
        next = cur-&gt;next;
        cur-&gt;next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
</code></pre>

<ul>
<li>263   Ugly Number</li>
</ul>


<p>简单的递归问题</p>

<pre><code class="c">
bool isUgly(int num) {

    if(num&lt;1) return false;

    if(num%2==0)
    {
        num/=2;
        return isUgly(num);
    }

     if(num%3==0)
    {
        num/=3;
        return isUgly(num);
    }

     if(num%5==0)
    {
        num/=5;
        return isUgly(num);
    }

    if(num == 1) return true;

    return false;

}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[list]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/10/25/list/"/>
    <updated>2015-10-25T23:38:26+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/10/25/list</id>
    <content type="html"><![CDATA[<h1>开始内功！</h1>

<p>前几日和前老大谈了谈，总结起来内功不能不练。实习以来有三次想好好复习数据结构和算法，但是最后都半途而废。现在不应该再有任何理由了，不然以后再也没有时间好好去复习这些东西。从现在开始刷好题目，打好基础。</p>

<h2>链表</h2>

<p>链表是线性表的一种。</p>

<p>线性表是最简单基础的一种数据结构。线性表中的数据元素之间的关系是一对一的，除了头元素和尾元素之外，其他元素首尾相连。线性表有两种存储方式</p>

<ol>
<li>顺序存储方式</li>
<li>链式存储方式</li>
</ol>


<p>数组是典型的顺序存储方式。链表是典型的链式存储方式。</p>

<p>链式存储结构，指的是相邻的两个元素在内存中可能不是相邻的，每一个元素都有一个指针域，指针域存放的是下一个元素的指针。</p>

<p>链式结构的优缺点：</p>

<ul>
<li>优点</li>
<li>插入和删除的复杂度为O(1)</li>
<li><p>不会浪费太多内存，在需要添加元素的时候才会申请内存，删除元素后释放内存。</p></li>
<li><p>缺点</p></li>
<li>访问元素的时间复杂度最坏为O(N)</li>
</ul>


<p> 链表就是链式存储的线性表。根据指针域的不同，链表分为单项链表，双向链表，循环链表等等</p>

<p> 一个简单的List定义</p>

<pre><code class="`C">struct list {
    int ver;
    struct list *next;
};
typedef struct list *listLink;
// 插入
void insert_list(listLink *, int);
// 打印
void print_list(listLink *, int);
// 链表长
int list_length(listLink);
// 搜索一个特定的值
listLink search_list(listLink, int);
</code></pre>

<p>四个方法的实现</p>

<p><img src="/media/14459585444278.jpg" alt="" /></p>

<h2>指针常出现的问题</h2>

<h3>反转链表</h3>

<p>反转链表，分为两种情况讨论，单向链表和双向链表</p>

<ul>
<li><p>单向链表</p>

<ul>
<li><p>考虑到访问某个节点的时候，要检查下一个节点是否为空。</p></li>
<li><p>要把反转后的最后一个节点（头节点）的指针指向null</p></li>
</ul>
</li>
</ul>


<p>实现代码如下</p>

<p><img src="/media/14459590472638.jpg" alt="" /></p>

<ul>
<li>双向链表</li>
</ul>


<p>双向链表比较麻烦的地方在于Next和pre要呼唤，需要主要当前节点和上个节点的问题。</p>

<h3>删除节点</h3>

<p>删除节点必须要知道被删除节点的前置节点，时间复杂度为O(1)</p>

<p><img src="/media/14459596886157.jpg" alt="" /></p>

<h3>循环链表</h3>

<p>循环链表表现于尾元素的next指针指向head元素，所以我们可以通过快慢指针去校验。具体的方法会在下面的链表的技巧中提到.</p>

<h2>链表的技巧</h2>

<h3>鲁棒性</h3>

<ul>
<li>当访问链表中某个节点的next节点的时候，一点要先判断当前节点是否为空。</li>
<li>全部操作结束后，判断是否有环。若有环，则置其中一端为Null;</li>
</ul>


<h3>Dummy Node</h3>

<p>假节点，伪头节点。Dummy <code>Node</code> 可以认为是一个假的头结点。我们可以构造一个<code>Dummy Node</code> ，使他的next指针指向Head node。使用<code>Dummy Node</code>目的是，在单向链表中，保正head不会再删除操作中丢失。此外，比较特殊的方法是用来进行删除head。</p>

<p>Dummy Node可以处理对于head Node变化的情况。</p>

<h2>快慢指针</h2>

<p>快慢指针式解决很多链表的问题的关键。快慢指的是指针每次移动的步长。常用的快指针步长为2，慢指针步长为1.快慢指针同时从头结点开始移动陪你过。</p>

<p>快慢指针的应用可以解决以下问题</p>

<ol>
<li>快速找出为止长度的链表的中间节点。我们让快指针的步长是慢指针的两倍。当快指针到达尾节点的时候，慢指针所指向的节点就是中间节点。</li>
<li>判断单向链表是否成环。同样的原理，如果快指针 <code>*fase =NULL</code>的时候，说明链表是NULL结尾的。如果快指针等于慢指针的时候，则说明该链表成环。</li>
</ol>

]]></content>
  </entry>
  
</feed>
