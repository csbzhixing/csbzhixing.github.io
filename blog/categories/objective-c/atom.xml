<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: objective-c | 之行海涯]]></title>
  <link href="http://csbzhixing.github.io/blog/categories/objective-c/atom.xml" rel="self"/>
  <link href="http://csbzhixing.github.io/"/>
  <updated>2015-09-22T09:25:55+08:00</updated>
  <id>http://csbzhixing.github.io/</id>
  <author>
    <name><![CDATA[之行]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GCD小结]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/12/gcd/"/>
    <updated>2015-09-12T21:16:43+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/12/gcd</id>
    <content type="html"><![CDATA[<h1>写在最前面</h1>

<p>最近发现自己学东西的效率好像高了，难道是因为写博客做笔记的原因吗？的确通过写博客来记录自己学习的成果能够加强自己对很多问题的理解。只有能够通过自己的语言将学习到的内容讲出来才是真的理解。所以以后看来要多写写。</p>

<h1>正文</h1>

<h2>GCD是什么鬼</h2>

<p>GCD，简单的来说就是苹果自己出的一套多核运算的解决方案。虽然苹果没有安卓那么多核心，但是并行化运算能够提高流程性是不可争辩的事实。GCD内部自动管理线程 的生命周期，不需要我们自己去手动管理。我们只需要调用对应的API就可以了。GCD是基于C语言开发的，不过由于使用了block，所以使用起来很方便。在了解GCD之前，我们需要了解一点多线程运行的原理。</p>

<h2>基本概念</h2>

<p>GCD中有两个重要的概念：<em>任务</em> 和 <em>队列</em></p>

<ol>
<li>任务。我们可以理解任务就是一个动作，放在GCD中就是一个代码块（block）。执行任务有两种，分别为<em>同步执行</em> 和 <em>异步执行</em>。同步和异步的区别其实很好理解。<code>同步执行</code>既是当前任务执行完前会阻塞当前进程，<code>而异步执行</code>就不会。</li>
<li>队列。队列是用来存放任务的。我们可以理解为任务就是队列中排队等待执行。队列分为<em>串行队列</em>和<em>并行队列</em>。</li>
<li>串行队列，就像排队一样，严格遵守FIFO。</li>
<li>并行队列，同样执行FIFO。不同的是，取出来的任务会根据情况放到别的线程上。由于多个线程出队的时间间隔可能很短，所以容易认为是非FIFO的。不过即使这样，系统也会根据硬件条件来判断，并不一定会所有任务都在同时执行。</li>
</ol>


<hr />

<p>  创建队列的操作如下图所示</p>

<p>  <img src="http://i3.tietuku.com/045e13ec06064ef3.png" alt="queue" /></p>

<hr />

<p>  创建任务如下如图所示</p>

<p>  <img src="http://i3.tietuku.com/b2ef139ced93771f.png" alt="task" /></p>

<h4>队列组</h4>

<p>  对列组就是将多个队列添加到一个组里。这样的方式使我们可以在队列里所有的任务都完成后收到一个通知方法。</p>

<pre><code>  objective-c

  // 创建队列组
    dispatch_group_t group = dispatch_group_create();

    dispatch_group_async(group, globalQueue, ^{
      for (NSInteger i = 0; i &lt; 3; i++)
      {
          NSLog(@"group - queue - %@", [NSThread currentThread]);
      }
    });
</code></pre>

<h2>NSOperation 和 NSOperationQueue</h2>

<p>  NSOperation 和 NSOperationQueue是苹果对GCD的基于面向对象的完全封装，使其更容易理解。操作方式也更简单</p>

<ol>
<li>将要执行的任务封装到一个<code>NSOperation</code>对象中</li>
<li>将任务添加到一个<code>NSOperationQueue</code>中</li>
</ol>


<p>  此后系统将自动在执行任务。</p>

<h3>添加任务</h3>

<p> 由于NSOperation是一个抽象类，所以不能直接封装任务。但是有两个子类用于封装任务：<code>NSInvocationOperation</code> 和 <code>NSBlockOperation</code>。创建一个队列后，需要调动<code>start()</code>方法来启动，<em>默认在当前队列同步执行</em>。同时队列提供<code>cancel()</code>方法在中途取消任务。</p>

<ul>
<li>NSInvocationOperation 传入一个方法名。</li>
<li>NSBlockOperation 传入一个代码块。

<ul>
<li>在NSBlockOperation中，有一个方法<code>addExecutionBlock</code>方法。这个方法使我们可以添加多个block到队列中。<em>这些block将会并发执行**，将在</em>主线程和其他的多个线程``执行任务</li>
</ul>
</li>
</ul>


<h3>添加队列</h3>

<p>   多数时候，我们不希望当前线程被占用，因为会影响到UI的流畅性（UI永远在主线程上）。因此我们需要创建新的队列。只要我们添加任务到队列上，就会自动调用任务的<code>start()</code>方法。如果任务在其他队列上，那么他就会在其他线程上并行执行。</p>

<p>   我们发现，<code>NSOperationQueue</code>并没有设置串行和并行队列的问题，那么<code>NSOperationQueue</code>是怎么确定队列的类型的呢。苹果通过封装巧妙的使调用者不需要特意的去注意队列的性质，只需要设置<code>NSOperationQueue</code>中的<code>maxConcurrentOperationCount</code> &ndash; 最大并发数就可以了。</p>

<h2>总结</h2>

<p>   在上篇block的文章中也谈到了block在gcd的中的应用。通过gcd，我们可以最大化的去使用硬件的性能，避免出现卡顿的现象。多线程用的好不好，也基本上代表了一个开发者的能力水平。虽然多线程编程有许多坑，但只有跨过一个个坑，才能变成大牛，不是吗？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[block]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/07/block/"/>
    <updated>2015-09-07T17:25:40+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/07/block</id>
    <content type="html"><![CDATA[<h2>Block是个什么</h2>

<p>和kvo/kvc一样，block的使用也是我在学习Objective-C的过程中碰到的一个大拦路虎。第一遍过语法的时候并没有太注意这部分的内容。而到了后面阅读各类大神的源码的时候，发现block的应用非常多。而对这块内容的疏忽导致自己一直不能很顺利的阅读各类代码，在项目中也是一知半解的应用，所以在这里想总结下。</p>

<h3>Blcok 是什么</h3>

<p>block是在iOS SDK 4.0引入的黑魔法。从他诞生的时候，Apple就倾注了大量的心血。字面上看，block就是一个代码块。在许多语言中都可以看到相似的语法设计。但是block自身由于可以在内联执行的时候还可以传递参数，同时自身可以作为参数在函数之间来传递，所有有了许多神奇的用法（好吧是我觉得很神奇）</p>

<p>一个典型的block的应用如下</p>

<pre><code> BOOL (^isName)(NSString *) = ^(NSString *name) {
      if ([name isEqualToString:@"csb"])
      {
          return YES;
      }
      else
      {
          return NO;
      }
    };
</code></pre>

<p>定义一个block开头是和函数一样是返回类型，（^）跟着是block的名字，后面跟着是传入的数据类型。括号里面是代码块。</p>

<p>一个完整的例子</p>

<pre><code>
- (void)blockTest
{
    BOOL (^isName)(NSString *) = ^(NSString *name) {
      if ([name isEqualToString:@"csb"])
      {
          return YES;
      }
      else
      {
          return NO;
      }
    };

    self.sark.name = @"csb";
    NSLog(@"is csb ? %@", isName(self.sark.name) ? @"yes" : @"no");
}
</code></pre>

<p>那么block有什么特别之处？前面提到了，block能够使用block外的参数，我们来实验下</p>

<pre><code>- (void)blockTest
{
    NSString *csbName = @"csbzhixing";
    BOOL (^isName)(NSString *) = ^(NSString *name) {
      if ([name isEqualToString:csbName])
      {
          return YES;
      }
      else
      {
          return NO;
      }
    };

    self.sark.name = @"csbzhixing";
    NSLog(@"is csb ? %@", isName(self.sark.name) ? @"yes" : @"no");
}
</code></pre>

<p>输出
<code>
2015-09-07 16:48:25.452 CSBRepository[83032:1549339] is csb ? yes
</code></p>

<p>注意到，定义了block后，修改了block中引用的局部变量，那么block中的局部变量仍然会保持不变。</p>

<p><img src="http://i3.tietuku.com/a60eb087f6bfd358.png" alt="pic1" /></p>

<p>好吧，如果我们的确有这个需求怎么弄呢？使用<code>_block</code>修饰符来修饰局部变量可以解决这个问题</p>

<p><img src="http://i3.tietuku.com/ba1814837f233066.png" alt="pic2" /></p>

<p>block调用实例变量，这个没有好说的。。直接用就是了。</p>

<h2>小小的问题，循环引用</h2>

<p>需要注意的一个问题是block的retain cycle问题，即循环引用。</p>

<p>如果要细究这个问题，要回到老生常谈的引用计数的问题上。有许多很详细的文章解释了为何存在这种问题，在这里我只简单的谈下我的理解。</p>

<p>retain cycle的问题根源在于block和object可能会互相强引用，互相retain了对方，这样就导致了retain cycle的问题。到了最后就发现两者谁也释放不了谁，导致了崩溃。（你不让我，我不让你怎么行）。</p>

<p>解决的方法就是打破这种循环，使用弱引用。这点可以参考最有名的第三方库AFNetworking的源码，在block上afn的写法最值得参考学习。</p>

<h2>Block该用在什么地方</h2>

<p>在项目中，主要应用block的地方有场景之间的数据传输，UI刷新，网络请求等等。在参考官方的建议和大神的博客后，总结了一下几个方面</p>

<ol>
<li>枚举 &ndash; 通过block获取对象和控制枚举进程</li>
<li>View动画 &ndash; 规定动画，参考官方的demo可以很快的了解</li>
<li>通知 &ndash; 事件完成后执行block内的代码，比如网络请求成功后</li>
<li>完成 &ndash; 同上</li>
<li>GCD多线程 &ndash; 这个是下一篇想要去了解学习的内容</li>
<li>错误处理 &ndash; 错误发生的时候执行</li>
<li>排序</li>
</ol>


<p>深入学习block还有很多的内容，比如block是怎么实现，block的类型等等。这里只是我目前学习的一个小结，有机会还要再深入的学习。</p>
]]></content>
  </entry>
  
</feed>
