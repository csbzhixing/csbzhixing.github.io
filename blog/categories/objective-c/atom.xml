<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: objective-c | 之行海涯]]></title>
  <link href="http://csbzhixing.github.io/blog/categories/objective-c/atom.xml" rel="self"/>
  <link href="http://csbzhixing.github.io/"/>
  <updated>2015-10-23T10:37:09+08:00</updated>
  <id>http://csbzhixing.github.io/</id>
  <author>
    <name><![CDATA[之行]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[重新认识ARC]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/22/arc/"/>
    <updated>2015-09-22T17:48:06+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/22/arc</id>
    <content type="html"><![CDATA[<p>第一次接触ARC还是在第一次拿到项目的时候。学习OC的时候使用的教材主要是通过MRC来讲解Retain Counting(引用计数)的。后面只是简单的了解了下ARC是编译器在编译的过程中自动去估算对象的生命周期来自动添加retain和realse的。解放了双手，也就没有什么动力去研究了。现在得空了，是时候增强自己的技能树。当前的目标如下</p>

<!--more-->


<p>
1. 增加网络编程的相关知识
    + TCP/IP HTTP HTTPS 协议的学习和了解
    + JSON和XML的解析
    + iOS自身关于网络请求相关的类和API
    + 第三方库AFNetWorking源码阅读
2. 增加iOS内核方面的知识
    + 内存基本知识和管理方式
    + ARC
    + 进程线程
    + RunTime</p>

<p>简单的看是两个大类七个点，但是感觉每一个点都非常多东西。目前暂时把1.1的点给补完了。不过任然需要投入大量的时间去复习。这里打算整合2.1和2.2。</p>

<h2>内存管理</h2>

<p>学过计算机基础的人对于内存都不陌生，哪怕是没有计算机基础的人也明白内存对于电脑（终端）的重要性。内存管理，就是在程序运行的过程中，申请，使用，释放内存的过程。程序写的好不好，就看你在完成功能的同时是不是使用了尽可能少的内存。</p>

<p><em>堆和栈</em></p>

<p>在内存中，有两个重要的概念，分别是<code>堆和栈</code>。这里不仅仅指代他们的数据结构。我们知道，一个函数执行的时候，他会被压入栈中。栈中的内存单元保存了函数的返回地址，局部变量，传参等数据。当函数被弹出栈的时候，一切数据都会被销毁。而<code>堆</code>上的数据是由开发者自行申请管理的，生命周期由开发者自行掌握。</p>

<p><em>引用计数</em></p>

<p>学过OC的人都知道，在OC中管理内存的方法是<code>引用计数</code>(Retain Counting)。通过对堆和栈的了解，我们可以得出OC上的对象<em>都是在堆上</em>的。</p>

<p>在苹果开发文档里面有一张图很好的说明的通过引用计数来管理对象生命周期的过程。</p>

<p><img src="/media/14429735006902.jpg" alt="引用计数" /></p>

<p>同样，引用计数也遵循几大内存管理原则</p>

<ol>
<li>谁申请谁拥有</li>
<li>肯以申请拥有一个存在的对象</li>
<li>当不需要的再拥有对象的时候，申请释放</li>
<li>不能释放不属于自己没有拥有的对象</li>
</ol>


<h2>Automatic Reference Counting (ARC)</h2>

<p>在学习iOS开发半年后，ARC给我留下了很深的印象。ARC是苹果在引用计数的基础上改善了编译器实现的功能。要了解ARC，首先要看看在没有ARC之前开发者是怎么去通过引用计数管理的。</p>

<p>在ARC之前，我们统称为<code>MRC（Manual Reference Counting</code>，即手动引用技术。通过调用<code>retain</code>和<code>release</code>来管理对象的生命周期。有了ARC之后，在编译的过程中，编译器可以根据上下文估算对象的生命周期，以此来自动的添加<code>retain</code>和<code>release</code>。</p>

<p>注意，ARC只对OC对象有作用，对于C的类型对象不则按照C的内存管理的方法去管理。</p>

<p>如果在工程中开启了使用ARC，那么就要遵循ARC定义的一些规范</p>

<ol>
<li>不能显示的调用<code>dealloc</code>,<code>ratain</code>,<code>release</code>,<code>retainCount</code>,<code>autoRelease</code>。</li>
<li>如果要复写<code>dealloc</code>方法，不需要显示调用<code>[super dealloc]</code>方法。</li>
<li>不能再使用<code>AutoReleasepool</code></li>
</ol>


<p><em>ARC下的修饰符</em></p>

<p>在@Property 中，有四种修饰符是ARC提供的，他们分别是
1. strong
2. weak
3. unsafe_unretained
4. __autoreleasing</p>

<p>其中，重点来谈谈strong和weak</p>

<ul>
<li>strong。我们理解为强引用。当前的对象实际拥有这个对象。默认情况下ARC使用的strong来修饰。</li>
<li>weak。相对于strong的强引用，weak指的是弱引用。当引用的对象被释放掉的时候，当前引用对象会被自动置nil。weak通常被用来解决循环引用的问题。</li>
</ul>


<p><code>__autoreleasing</code>和<code>__unsafe_unretained</code>在实际应用中是很少的。<code>__unsafe_unretained</code>是为了兼容iOS4之前的版本，现在基本上不会使用了，主要是为了实现weak的功能。<code>__autoreleasing</code>是表示在autorelease pool中自动释放对象的引用。</p>

<h2>block 在ARC下</h2>

<p>block在之前已经小小的讨论过了，出现的几个问题都有谈论到，这里主要从ARC的角度上再谈一谈。</p>

<p>block在ARC下最特殊的地方就是怎么去解决循环引用。在block的篇章中没有很详细讨论，原因也是没从内存的角度来看。这里详细讲下循环引用产生原因和在ARC下解决循环引用的方法。</p>

<blockquote><p>You can use lifetime qualifiers to avoid strong reference cycles. For example, typically if you have a graph of objects arranged in a parent-child hierarchy and parents need to refer to their children and vice versa, then you make the parent-to-child relationship strong and the child-to-parent relationship weak. Other situations may be more subtle, particularly when they involve block objects.</p>

<p>In manual reference counting mode, <strong>block id x; has the effect of not retaining x. In ARC mode, </strong>block id x; defaults to retaining x (just like all other values). To get the manual reference counting mode behavior under ARC, you could use <strong>unsafe_unretained </strong>block id x;. As the name <strong>unsafe_unretained implies, however, having a non-retained variable is dangerous (because it can dangle) and is therefore discouraged. Two better options are to either use </strong>weak (if you don’t need to support iOS 4 or OS X v10.6), or set the __block value to nil to break the retain cycle.</p>

<p>The following code fragment illustrates this issue using a pattern that is sometimes used in manual reference counting.</p></blockquote>

<p>上面是苹果官方文档对循环引用的解释。通过引用计数，我们了解到，如果有两个对象，对彼此都是强引用的话，双方都无法释放对方，也就无法释放delloc对象，最终就造成了死循环。在iOS5以下的版本里面，我们可以通过手动使用<code>unsafe_unretained</code>来使其中一个变量变成野指针。而在ARC下，我们通过使用weak来修饰其中一个变量，这样在block中就不存在双方强引用的抢矿。</p>

<p>但是，上面的处理方法有个问题。我们不知道weak修饰的对象什么时候会被释放掉了，有可能在执行block里面的对象在之前就已经被释放掉了。在AFNetWorking中，提供了一个非常好的解决思路</p>

<p><img src="/media/14429947239639.jpg" alt="" /></p>

<p>上面方法中，在block外先将self用<code>weak</code>引用一个weakSelf，进入block后再使用一个<code>_strong_typeof</code>去创建一个strong引用对象。这样的做法既能避免产生循环引用，也能避免weak对象提前被释放掉。</p>

<h2>ARC与Toll-Free Bridging</h2>

<p>Toll-Free Briding保证了在程序中，可以方便和谐的使用Core Foundation类型的对象和Objective-C类型的对象。但是，我们知道，到了ARC的时候，两者的内存管理方法不同了。对于一种对象，我们不能用该两种内存管理方法去管理。所以在进入ARC之后，Toll-Free Bridging也进行了相应的变化。</p>

<p><em>__bridge</em></p>

<p>只是申明了类型转变，并没有改变内存管理方法。</p>

<p><em>__bridge_retained（修饰符） or CFBridgingRetain（函数）</em></p>

<p>表示将指针类型转变的同时，将内存管理的责任由原来的Objective-C交给Core Foundation来处理，也就是，将ARC转变为MRC。</p>

<p><em>__bridge_transfer（修饰符） or CFBridgingRelease（函数）</em></p>

<p>这个修饰符和函数的功能和上面那个__bridge_retained相反，它表示将管理的责任由Core Foundation转交给Objective-C，即将管理方式由MRC转变为ARC。</p>

<p>上面就是要谈的ARC的内容了。其实ARC的坑比起MRC已经少了很多了，对于我们可怜的程序员来说已经是很大的解放了。</p>

<p>这里对于内存管理仅仅是基于OC简单的谈了谈，觉得还是不够深刻，主要是自己在这方面的知识的确很欠缺。读了
<a href="http://casatwy.com/ccheng-xu-de-nei-cun-guan-li.html">C程序的内存管理</a>这篇文章学到了很多，在这里也安利一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GCD小结]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/12/gcd/"/>
    <updated>2015-09-12T21:16:43+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/12/gcd</id>
    <content type="html"><![CDATA[<h1>写在最前面</h1>

<p>最近发现自己学东西的效率好像高了，难道是因为写博客做笔记的原因吗？的确通过写博客来记录自己学习的成果能够加强自己对很多问题的理解。只有能够通过自己的语言将学习到的内容讲出来才是真的理解。所以以后看来要多写写。</p>

<!--more-->


<p></p>

<h1>正文</h1>

<h2>GCD是什么鬼</h2>

<p>GCD，简单的来说就是苹果自己出的一套多核运算的解决方案。虽然苹果没有安卓那么多核心，但是并行化运算能够提高流程性是不可争辩的事实。GCD内部自动管理线程 的生命周期，不需要我们自己去手动管理。我们只需要调用对应的API就可以了。GCD是基于C语言开发的，不过由于使用了block，所以使用起来很方便。在了解GCD之前，我们需要了解一点多线程运行的原理。</p>

<h2>基本概念</h2>

<p>GCD中有两个重要的概念：<em>任务</em> 和 <em>队列</em></p>

<ol>
<li>任务。我们可以理解任务就是一个动作，放在GCD中就是一个代码块（block）。执行任务有两种，分别为<em>同步执行</em> 和 <em>异步执行</em>。同步和异步的区别其实很好理解。<code>同步执行</code>既是当前任务执行完前会阻塞当前进程，<code>而异步执行</code>就不会。</li>
<li>队列。队列是用来存放任务的。我们可以理解为任务就是队列中排队等待执行。队列分为<em>串行队列</em>和<em>并行队列</em>。</li>
<li>串行队列，就像排队一样，严格遵守FIFO。</li>
<li>并行队列，同样执行FIFO。不同的是，取出来的任务会根据情况放到别的线程上。由于多个线程出队的时间间隔可能很短，所以容易认为是非FIFO的。不过即使这样，系统也会根据硬件条件来判断，并不一定会所有任务都在同时执行。</li>
</ol>


<hr />

<p>  创建队列的操作如下图所示</p>

<p>  <img src="http://i3.tietuku.com/045e13ec06064ef3.png" alt="queue" /></p>

<hr />

<p>  创建任务如下如图所示</p>

<p>  <img src="http://i3.tietuku.com/b2ef139ced93771f.png" alt="task" /></p>

<h4>队列组</h4>

<p>  对列组就是将多个队列添加到一个组里。这样的方式使我们可以在队列里所有的任务都完成后收到一个通知方法。</p>

<pre><code>  objective-c

  // 创建队列组
    dispatch_group_t group = dispatch_group_create();

    dispatch_group_async(group, globalQueue, ^{
      for (NSInteger i = 0; i &lt; 3; i++)
      {
          NSLog(@"group - queue - %@", [NSThread currentThread]);
      }
    });
</code></pre>

<h2>NSOperation 和 NSOperationQueue</h2>

<p>  NSOperation 和 NSOperationQueue是苹果对GCD的基于面向对象的完全封装，使其更容易理解。操作方式也更简单</p>

<ol>
<li>将要执行的任务封装到一个<code>NSOperation</code>对象中</li>
<li>将任务添加到一个<code>NSOperationQueue</code>中</li>
</ol>


<p>  此后系统将自动在执行任务。</p>

<h3>添加任务</h3>

<p> 由于NSOperation是一个抽象类，所以不能直接封装任务。但是有两个子类用于封装任务：<code>NSInvocationOperation</code> 和 <code>NSBlockOperation</code>。创建一个队列后，需要调动<code>start()</code>方法来启动，<em>默认在当前队列同步执行</em>。同时队列提供<code>cancel()</code>方法在中途取消任务。</p>

<ul>
<li>NSInvocationOperation 传入一个方法名。</li>
<li>NSBlockOperation 传入一个代码块。

<ul>
<li>在NSBlockOperation中，有一个方法<code>addExecutionBlock</code>方法。这个方法使我们可以添加多个block到队列中。<em>这些block将会并发执行**，将在</em>主线程和其他的多个线程``执行任务</li>
</ul>
</li>
</ul>


<h3>添加队列</h3>

<p>   多数时候，我们不希望当前线程被占用，因为会影响到UI的流畅性（UI永远在主线程上）。因此我们需要创建新的队列。只要我们添加任务到队列上，就会自动调用任务的<code>start()</code>方法。如果任务在其他队列上，那么他就会在其他线程上并行执行。</p>

<p>   我们发现，<code>NSOperationQueue</code>并没有设置串行和并行队列的问题，那么<code>NSOperationQueue</code>是怎么确定队列的类型的呢。苹果通过封装巧妙的使调用者不需要特意的去注意队列的性质，只需要设置<code>NSOperationQueue</code>中的<code>maxConcurrentOperationCount</code> &ndash; 最大并发数就可以了。</p>

<h2>总结</h2>

<p>   在上篇block的文章中也谈到了block在gcd的中的应用。通过gcd，我们可以最大化的去使用硬件的性能，避免出现卡顿的现象。多线程用的好不好，也基本上代表了一个开发者的能力水平。虽然多线程编程有许多坑，但只有跨过一个个坑，才能变成大牛，不是吗？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[block]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/07/block/"/>
    <updated>2015-09-07T17:25:40+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/07/block</id>
    <content type="html"><![CDATA[<h2>Block是个什么</h2>

<p>和kvo/kvc一样，block的使用也是我在学习Objective-C的过程中碰到的一个大拦路虎。第一遍过语法的时候并没有太注意这部分的内容。而到了后面阅读各类大神的源码的时候，发现block的应用非常多。而对这块内容的疏忽导致自己一直不能很顺利的阅读各类代码，在项目中也是一知半解的应用，所以在这里想总结下。</p>

<!--more-->


<p></p>

<h3>Blcok 是什么</h3>

<p>block是在iOS SDK 4.0引入的黑魔法。从他诞生的时候，Apple就倾注了大量的心血。字面上看，block就是一个代码块。在许多语言中都可以看到相似的语法设计。但是block自身由于可以在内联执行的时候还可以传递参数，同时自身可以作为参数在函数之间来传递，所有有了许多神奇的用法（好吧是我觉得很神奇）</p>

<p>一个典型的block的应用如下</p>

<pre><code> BOOL (^isName)(NSString *) = ^(NSString *name) {
      if ([name isEqualToString:@"csb"])
      {
          return YES;
      }
      else
      {
          return NO;
      }
    };
</code></pre>

<p>定义一个block开头是和函数一样是返回类型，（^）跟着是block的名字，后面跟着是传入的数据类型。括号里面是代码块。</p>

<p>一个完整的例子</p>

<pre><code>
- (void)blockTest
{
    BOOL (^isName)(NSString *) = ^(NSString *name) {
      if ([name isEqualToString:@"csb"])
      {
          return YES;
      }
      else
      {
          return NO;
      }
    };

    self.sark.name = @"csb";
    NSLog(@"is csb ? %@", isName(self.sark.name) ? @"yes" : @"no");
}
</code></pre>

<p>那么block有什么特别之处？前面提到了，block能够使用block外的参数，我们来实验下</p>

<pre><code>- (void)blockTest
{
    NSString *csbName = @"csbzhixing";
    BOOL (^isName)(NSString *) = ^(NSString *name) {
      if ([name isEqualToString:csbName])
      {
          return YES;
      }
      else
      {
          return NO;
      }
    };

    self.sark.name = @"csbzhixing";
    NSLog(@"is csb ? %@", isName(self.sark.name) ? @"yes" : @"no");
}
</code></pre>

<p>输出
<code>
2015-09-07 16:48:25.452 CSBRepository[83032:1549339] is csb ? yes
</code></p>

<p>注意到，定义了block后，修改了block中引用的局部变量，那么block中的局部变量仍然会保持不变。</p>

<p><img src="http://i3.tietuku.com/a60eb087f6bfd358.png" alt="pic1" /></p>

<p>好吧，如果我们的确有这个需求怎么弄呢？使用<code>_block</code>修饰符来修饰局部变量可以解决这个问题</p>

<p><img src="http://i3.tietuku.com/ba1814837f233066.png" alt="pic2" /></p>

<p>block调用实例变量，这个没有好说的。。直接用就是了。</p>

<h2>小小的问题，循环引用</h2>

<p>需要注意的一个问题是block的retain cycle问题，即循环引用。</p>

<p>如果要细究这个问题，要回到老生常谈的引用计数的问题上。有许多很详细的文章解释了为何存在这种问题，在这里我只简单的谈下我的理解。</p>

<p>retain cycle的问题根源在于block和object可能会互相强引用，互相retain了对方，这样就导致了retain cycle的问题。到了最后就发现两者谁也释放不了谁，导致了崩溃。（你不让我，我不让你怎么行）。</p>

<p>解决的方法就是打破这种循环，使用弱引用。这点可以参考最有名的第三方库AFNetworking的源码，在block上afn的写法最值得参考学习。</p>

<h2>Block该用在什么地方</h2>

<p>在项目中，主要应用block的地方有场景之间的数据传输，UI刷新，网络请求等等。在参考官方的建议和大神的博客后，总结了一下几个方面</p>

<ol>
<li>枚举 &ndash; 通过block获取对象和控制枚举进程</li>
<li>View动画 &ndash; 规定动画，参考官方的demo可以很快的了解</li>
<li>通知 &ndash; 事件完成后执行block内的代码，比如网络请求成功后</li>
<li>完成 &ndash; 同上</li>
<li>GCD多线程 &ndash; 这个是下一篇想要去了解学习的内容</li>
<li>错误处理 &ndash; 错误发生的时候执行</li>
<li>排序</li>
</ol>


<p>深入学习block还有很多的内容，比如block是怎么实现，block的类型等等。这里只是我目前学习的一个小结，有机会还要再深入的学习。</p>
]]></content>
  </entry>
  
</feed>
