<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: network | 之行海涯]]></title>
  <link href="http://csbzhixing.github.io/blog/categories/network/atom.xml" rel="self"/>
  <link href="http://csbzhixing.github.io/"/>
  <updated>2015-09-15T00:01:40+08:00</updated>
  <id>http://csbzhixing.github.io/</id>
  <author>
    <name><![CDATA[之行]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[socket]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/13/socket/"/>
    <updated>2015-09-13T05:27:26+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/13/socket</id>
    <content type="html"><![CDATA[<h2>写在前面</h2>

<p>最近一直在找更好的实习，发现网络编程是一个优秀的程序员必备的技能。而自己在学校中学到的东西很少（逃。要不是有之前的实习和做个一个小小的项目，对于很多知识可能还只是停留在书本上（其实就是没进脑）。最近有人问我是否了解socket，我顿时语塞。对与socket的认识还是学习java的时候知道可以使用socket进行客户端与服务器端的通信，可是当时并没有去实践。欠下的债都是要还的。</p>

<p>此外为什么我每篇博文的开头都写点自己的感受。我觉得博客不仅仅是记录自己的技术积累，也是抒发自己心情的一个途经，所以我会在每篇文章前面写一点点自己在写博文的时候的心情。</p>

<h2>正文</h2>

<p>socket，套接字，是基于TCP/IP协议族下的一种网络通信方式。我们知道，在本地，进程之间有多种方法去通信。在网络中，我们同样可以使用socket进行通信。接下来一步步来看socket是如何使网络上的进程相互通信的。</p>

<p>我们知道，要像让进程通信，首先必须确认进程的身份。如同我们只有知道了和自己谈话的是谁，我们才知道谈什么。在本地，进程拥有唯一的标识PID。在网络上，基于TCP/IP协议，通过<em>IP，协议，端口号</em>，我们可以确认一个进程的唯一身份。</p>

<p>使用TCP/IP协议的应用程序通常采用应用编程接口，有本文讲到的socket（套接字）和TIL（被淘汰了）。目前而言，绝多大数的应用程序都是基于socket进行网络通信的，所以了解socket是一个程序员必备的。</p>

<h2>scocket 究竟是什么</h2>

<p>socket起源于UNIX。我们知道UNIX的设计原理就是<em>一切皆文件</em>，操作都是<em>open -> read/write -> close</em>。所以说，我们可以认为socket也是一个文件，是基于上述设计原理的实现。socket函数就是专门来完成相应操作的。</p>

<h2>socket 操作</h2>

<p>在上面我们知道了socket是一个文件，那么socket自然有对应的操作方法，下面是基于TCP的几个基本操作。
(注，本文的方法是使用Objective-C写的，其实socket在任何语言都是差不多的)</p>

<pre><code class="objective-c">
// 创建并初始化socket，返回socket的文件描述符，如果返回值为-1则创建失败
int socket(int addresFamily, int type, int protocol)

// 关闭socket
int close(int socketFileDescriptor)

// 将socket与特定的IP地址和端口号绑定，成功返回0，失败返回-1
int bind(int socketFileDescriptor, sockadd *addressToBind)

// 接受客户端的请求并且将客户端的网络地址信息存入clientAddress
// 当客户端的连接请求被接受后，双方的通信链路就建立好了，两者就可以开始通信了。

int accept(int socketFileDescriptor, sockaddr *clientAddress, int clientAddressStructLength)

// 客户端向特定的IP的服务器发送连接请求，成功返回0，失败返回-1
// 当服务器建立好后，客户端就可以通过这个函数与服务器端建立连接。
// 对于UDP来说，该接口是可选的，如果调用了这个接口表明设置了UDP socket默认的网络地址.
// 对于TCP来说，这里就是三次握手发生的地方

int connect(int socketFileDescriptor, sockaddr *serverAddress, int serverAddressLength)

// 通过DNS查找特定的IP，如果找不到返回NULL
hostent *gethostbyname(char *hostname)

// 发送数据，发送成功后返回成功发送的字节数，否则返回-1
int send(int socketFileDescriptor,char *buffer, int flags)

// 接收数据，成功后返回成功读取的字节数，否则返回-1
int receive(int socketFileDesciptor,char *buffer,int flags)

// 下面两个方法是UDP的方法

// UDP发送,返回状态同上
int sendto(int socketFileDesciptor, char *buffer, int bufferLength, int flags, sockaddr *destinationAddress, int destinationAddressLength)

// UDP读取，返回状态同上
int recvfrom(int socketFileDesciptor, char *buffer, int bufferLength, int flags, sockaddr *fromAddress, int fromAddressLength)
</code></pre>

<p>通过观察方法，我们发现socket其实就是<em>确认目标 ->建立连接 -> 传送/读取 -> 断开</em> 的过程</p>

<p>我们再来看看TCP和UDP下socket操作的不同的地方</p>

<h4>TCP</h4>

<p><img src="http://www.coderyi.com//qiniu/429/image/5269612b25e6df1b3ee5ab8352b2c3b6.jpg" alt="TCP" /></p>

<h4>UDP</h4>

<p><img src="http://www.coderyi.com//qiniu/429/image/cd6d1690d3d6eefd300987e590c1483f.jpg" alt="UDP" /></p>

<h2>最后</h2>

<p>到此，对于socket编程的概念有了个一个初步的认识了。在实际开发中，我们一般不会直接调用这些底层的API。借助于一些开源的第三方库更有利于项目的开发运行。不过，对于基本的理论知识还是必须要掌握的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP学习]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/10/http/"/>
    <updated>2015-09-10T23:46:08+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/10/http</id>
    <content type="html"><![CDATA[<h1>HTTP学习</h1>

<p>HTTP协议是网络中最广泛的协议之一，对HTTP协议的了解应该是每一个和网络打交道的程序员必须具备的技能。很多公司面试都要求对网络知识有一定的了解，一个是TCP/IP协议，一个就是HTTP协议，HTTP协议应用层的协议，内容比较少，这周花时间去总结了一下，做一个备忘。</p>

<h2>HTTP简单分析</h2>

<p>HTTP是一个基于请求/响应模式的、无状态的协议。即，浏览器与服务端连接之后，浏览器向服务器发送一个请求，服务器返回响应信息之后，双方的链接就被关闭。</p>

<p>HTTP1.0是典型的请求/响应模式。</p>

<p>HTTP1.1在1.0的基础上进行了改进，加入了“持续连接”的机制。通过这种机制，客户端发送请求得到响应后，连接不会马上关闭，可以继续发送请求，还可以流水线发送多个请求、而不用等待每一个响应的到来。</p>

<ul>
<li><p>URI和URL + URL我们应该是很熟悉的了，全名是统一资源定位符，包含了需要查找的信息的资源。 + 而URI是URL的父集，纯粹是一个WEB的资源符号</p>

<h2>HTTP请求</h2></li>
</ul>


<p><img src="http://i3.tietuku.com/2c834f74cd465d7e.png" alt="HTTP Request" /></p>

<p>简单的来说 HTTP请求可以分为三部分</p>

<ol>
<li><p>请求行</p></li>
<li><p>消息报头</p></li>
<li><p>请求正文</p></li>
</ol>


<h3>请求行</h3>

<hr />

<p>请求行主要的内容是是请求方法和请求的位置（URL）</p>

<p>请求方法主要有以下几种方法（注意方法都是全部字母大写）</p>

<p><img src="http://i3.tietuku.com/05fa7108f6959f91.png" alt="HTTP Request method" /></p>

<p>在APP中，最多用的到的就是POST 和 GET 两种方法。许多地方都要求区别两者的区别，所以在这里做一下重点笔记对比两者方法的不同</p>

<p>（在这里小小的吐槽，在学校计算机网络的学习中，POST和GET的区别基本就是一句话：POST比GET更好更安全。其实在查阅了许多资料后，发现并没有那么简单）</p>

<hr />

<h4>POST</h4>

<ul>
<li><p>根据HTTP规范，POST表示可能修改服务器上的资源的请求，比如提交表格，注册等等都是常用POST</p></li>
<li><p>POST将请求的正文包在HTTP包体中</p></li>
<li><p>POST没有大小限制</p></li>
</ul>


<hr />

<h4>GET</h4>

<ul>
<li>GET操作，根据HTTP规范，仅仅用于信息获取，而且是应该是安全的幂等。</li>
<li><p>GET操作会将请求的数据附在URL后面，参数之间以&amp;相连（这就是为什么很多人认为GET不安全了）</p></li>
<li><p>GET的数据限制，由于浏览器或者服务器可能会对URL存在长度限制，所以有可能会产生影响</p></li>
</ul>


<p> 通过对比，我们发现常见的误区有两个</p>

<ol>
<li><p>POST比GET更安全。通过上面对比，我们发现，虽然POST没有将参数直接放在URL中，但是通过抓包的手段，我们依然可以获得HTTP包体中的参数。由此看来，想依靠POST就简单保证安全是不可能的。</p></li>
<li><p>POST能比GET传输更多。通过上面的叙述也可以得知，其实HTTP协议本身没有进行限制，POST和GET都没有大小限制，而是第三方的浏览器和服务器造成了差别</p></li>
</ol>


<p>什么时候用POST，什么时候用GET，我们要依据不同的使用场景来区分。如果有缓存的需求，那自然就不能用POST方法。如果必须要用表格，GET也不行了。</p>

<h2>HTTP响应</h2>

<p>请求响应类似与请求。如图所示</p>

<p>可以看到，HTTP响应的第一行叫状态行，包含了HTTP版本，状态码，状态描述信息。</p>

<p>状态码是判断请求状态的重要标志，由三位数字组成，有五种定义：</p>

<ol>
<li>1XX &mdash;- 请示信息，表示请求已经接受，可以继续处理</li>
<li>2XX &mdash;- 成功状态，表示请求被服务器接受</li>
<li>3XX &mdash;- 重定向，要完成请求的话需要更进一步的操作</li>
<li>4XX &mdash;- 客户端错误，请求错误或者请求无法被实现</li>
<li>5XX &mdash;- 服务器端错误，服务器未能完成合法的请求</li>
</ol>


<p>全部取值如下：</p>

<blockquote><pre><code>   100——客户必须继续发出请求
   101——客户要求服务器根据请求转换HTTP协议版本


    200——交易成功
    201——提示知道新文件的URL
    202——接受和处理、但处理未完成
    203——返回信息不确定或不完整
    204——请求收到，但返回信息为空
    205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
    206——服务器已经完成了部分用户的GET请求

    300——请求的资源可在多处得到
    301——删除请求数据
    302——在其他地址发现了请求数据
    303——建议客户访问其他URL或访问方式
    304——客户端已经执行了GET，但文件未变化
    305——请求的资源必须从服务器指定的地址得到
    306——前一版本HTTP中使用的代码，现行版本中不再使用
    307——申明请求的资源临时性删除

    400——错误请求，如语法错误
    401——请求授权失败
    402——保留有效ChargeTo头响应
    403——请求不允许
    404——没有发现文件、查询或URl
    405——用户在Request-Line字段定义的方法不允许
    406——根据用户发送的Accept拖，请求资源不可访问
    407——类似401，用户必须首先在代理服务器上得到授权
    408——客户端没有在用户指定的饿时间内完成请求
    409——对当前资源状态，请求不能完成
    410——服务器上不再有此资源且无进一步的参考地址
    411——服务器拒绝用户定义的Content-Length属性请求
    412——一个或多个请求头字段在当前请求中错误
    413——请求的资源大于服务器允许的大小
    414——请求的资源URL长于服务器允许的长度
    415——请求资源不支持请求项目格式
    416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段
    417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求

    500——服务器产生内部错误
    501——服务器不支持请求的函数
    502——服务器暂时不可用，有时是为了防止发生系统过载
    503——服务器过载或暂停维修
    504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长
    505——服务器不支持或拒绝支请求头中指定的HTTP版本
</code></pre></blockquote>

<p> 常见的错误主要有400 404 403 500 503等等</p>

<p>相应正文，包含了请求获得的资源，有HTML文件，JSON格式数据，文件的URL等等</p>

<h3>消息报头</h3>

<hr />

<p>HTTP请求和HTTP响应都有消息报头。而消息报头是由众多报头域组成。每一个报头域都由名字＋“：”＋空格组成，消息报头域的名字是大小写无关的。</p>

<p>HTTP消息报头包括普通报头、请求报头、响应报头和实体报头。</p>

<hr />

<h4>普通报头：</h4>

<p>在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。</p>

<p>常见的普通报头：</p>

<p>1）Cache-Control</p>

<pre><code>Cache-Control用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。

请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;
响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.
</code></pre>

<p>2）Date</p>

<pre><code>Date普通报头域表示消息产生的日期和时间
</code></pre>

<p>3）Connection</p>

<pre><code>Connection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接
</code></pre>

<hr />

<h4>请求报头</h4>

<p>请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。
（在APP中，一些身份验证的信息可能需要在header中添加）</p>

<p>常见的请求报头：</p>

<p>1)Accept</p>

<pre><code>Accept请求报头域用于指定客户端接受哪些类型的信息。
</code></pre>

<p>2)Accept-Charset</p>

<pre><code>Accept-Charset请求报头域用于指定客户端接受的字符集。如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。
</code></pre>

<p>3）Accept-Encoding</p>

<pre><code>Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。
</code></pre>

<p>4）Accept-Language</p>

<pre><code>Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。
</code></pre>

<p>5）Authorization</p>

<pre><code>Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。
</code></pre>

<p>6）Host</p>

<pre><code>发送请求时，该报头域是必需的。Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。
</code></pre>

<p>7）User-Agent</p>

<pre><code>User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。
</code></pre>

<hr />

<h4>响应报头</h4>

<p>响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。</p>

<p>常见的实体报头：</p>

<p>1）Location</p>

<pre><code>Location响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。
</code></pre>

<p>2）Server</p>

<pre><code>Server响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。
</code></pre>

<p>3）WWW-Authenticate</p>

<pre><code>WWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。
</code></pre>

<hr />

<h4>实体报头</h4>

<p>请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。</p>

<p>实体报头包括：</p>

<p>常见的实体报头：</p>

<p>1）Content-Encoding</p>

<pre><code>Content-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding主要用于记录文档的压缩方法。
</code></pre>

<p>2）Content-Language</p>

<pre><code>Content-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言
</code></pre>

<p>阅读者。</p>

<p>3）Content-Length</p>

<pre><code>Content-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。即一个数字字符占一个字节，用其对应的ASCII码来存储传输。
</code></pre>

<p>4）Content-Type</p>

<pre><code>Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。
</code></pre>

<p>5）Expires</p>

<pre><code>Expires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。
</code></pre>

<p>6）Last-Modified</p>

<pre><code>Last-Modified实体报头域用于指示资源的最后修改日期和时间。
</code></pre>

<h2>总结</h2>

<p>HTTP协议的内容不是多，常用的内容就几个，但是需要非常熟悉，因为HTTP协议是网络交互重要的协议之一。</p>

<p>接下来花一些时间去回顾TCP/IP协议，内容多就会有几篇文章来记录学习的一些笔记心得。</p>
]]></content>
  </entry>
  
</feed>
