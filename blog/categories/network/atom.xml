<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: network | 之行海涯]]></title>
  <link href="http://csbzhixing.github.io/blog/categories/network/atom.xml" rel="self"/>
  <link href="http://csbzhixing.github.io/"/>
  <updated>2015-12-03T23:14:50+08:00</updated>
  <id>http://csbzhixing.github.io/</id>
  <author>
    <name><![CDATA[之行]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AFNetworking 学习笔记 1]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/10/23/afnetworking-1/"/>
    <updated>2015-10-23T10:31:15+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/10/23/afnetworking-1</id>
    <content type="html"><![CDATA[<h2>从3.0开始</h2>

<p>一转眼，AF已经更新到了3.0版本。目前cocoapods上的最新版本是3.0 beta1。在3.0的版本里面，AF全面地使用<code>NSURLSession</code>代替了<code>NSURLConnection</code>。之前花了一些时间学习<code>NSURLSession</code>，在这里的学习终于派上了用场。在这里主要学习3.0版本的使用。希望在项目中能够顺利地过度到AFNetwoking 3.0版本。此外，随着Objective-c慢慢被Swift替代，AFNetworking 3.0可能是最后一个大版本更新。本文会一直随着AN的更新继续更新，也是一个不断学习的过程。</p>

<h2>结构</h2>

<p>在3.0时代，AFN精简了结构，全面使用了<code>NSURLSession</code>。</p>

<p><img src="/media/14451531667191.jpg" alt="" />
beta1里面只剩下了当前几个Manager。</p>

<p><code>AFHTTPSessionManager</code>是<code>AFURLSessionManager</code>的子类。</p>

<h2>AFURLSessionManager</h2>

<p><code>AFURLSessionManager</code>实现了以下几种<code>NSURLSession</code>的代理方法</p>

<h4><code>NSURLSessionDelegate</code></h4>

<ul>
<li><code>URLSession:didBecomeInvalidWithError:</code></li>
<li><code>URLSession:didReceiveChallenge:completionHandler:</code></li>
<li><code>URLSessionDidFinishEventsForBackgroundURLSession:</code></li>
</ul>


<h4><code>NSURLSessionTaskDelegate</code></h4>

<ul>
<li><code>URLSession:willPerformHTTPRedirection:newRequest:completionHandler:</code></li>
<li><code>URLSession:task:didReceiveChallenge:completionHandler:</code></li>
<li><code>URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:</code></li>
<li><code>URLSession:task:didCompleteWithError:</code></li>
</ul>


<h4><code>NSURLSessionDataDelegate</code></h4>

<ul>
<li><code>URLSession:dataTask:didReceiveResponse:completionHandler:</code></li>
<li><code>URLSession:dataTask:didBecomeDownloadTask:</code></li>
<li><code>URLSession:dataTask:didReceiveData:</code></li>
<li><code>URLSession:dataTask:willCacheResponse:completionHandler:</code></li>
</ul>


<h4><code>NSURLSessionDownloadDelegate</code></h4>

<ul>
<li><code>URLSession:downloadTask:didFinishDownloadingToURL:</code></li>
<li><code>URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesWritten:totalBytesExpectedToWrite:</code></li>
<li><code>URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:</code></li>
</ul>


<h3>成员</h3>

<h4>属性</h4>

<p>在<code>AFURLSessionManager</code>中，主要的三个属性如下</p>

<p><img src="/media/14451544109695.jpg" alt="" /></p>

<p><code>session</code>实现了会话，<code>operationQueue</code>是一个操作队列。<code>responseSerializer</code>是实现了<code>AFURLResponseSerialization</code>协议的一个对象。</p>

<hr />

<p>Manager中还包括了安全协议的对象和连通性的对象。这两个类将在后面谈到。</p>

<p><img src="/media/14451545558576.jpg" alt="" /></p>

<hr />

<p>下面是Task的内容，包含与当前<code>Session</code>中</p>

<p><img src="/media/14451547233232.jpg" alt="" /></p>

<hr />

<p>回调块队列，包括了在主队列和私有队列的两个部分</p>

<p><img src="/media/14451548418504.jpg" alt="" /></p>

<h4>方法</h4>

<p> 初始化方法</p>

<p> <img src="/media/14455211888103.jpg" alt="" /></p>

<hr />

<p>创建一个<code>NSURLSessionDataTask</code>数据性任务</p>

<p><img src="/media/14455212385758.jpg" alt="" /></p>

<hr />

<p>创建<code>`NSURLSessionUploadTask</code> 上传任务</p>

<p><img src="/media/14455213126912.jpg" alt="" />
<img src="/media/14455213190110.jpg" alt="" /></p>

<hr />

<p>创建<code>NSURLSessionDownloadTask</code> 下载任务</p>

<p><img src="/media/14455213738134.jpg" alt="" />
<img src="/media/14455213826398.jpg" alt="" /></p>

<hr />

<p>获得一个特定任务的<code>progress进度</code></p>

<p><img src="/media/14455214651069.jpg" alt="" />
<img src="/media/14455214692883.jpg" alt="" />
<img src="/media/14455214742512.jpg" alt="" /></p>

<hr />

<p><code>Session Delegate Callbacks 设置会话代理回调</code></p>

<p><img src="/media/14455217046547.jpg" alt="" />
<img src="/media/14455217113671.jpg" alt="" /></p>

<p><code>Task Delegate Callbacks 设置任务代理回调</code></p>

<p>当任务需要一个新的请求体发送给服务器的时候。
<img src="/media/14455219470133.jpg" alt="" /></p>

<p>当HTTP请求回调有重定向的的话设置这个Block
<img src="/media/14455219533707.jpg" alt="" /></p>

<p>当一个请求需要特别的鉴权的时候设置这个challenge
<img src="/media/14455219599178.jpg" alt="" /></p>

<p>设置一个block去追踪上传进度</p>

<p><img src="/media/14455658294340.jpg" alt="" /></p>

<p>设置一个block当任务完成后执行
<img src="/media/14455658635389.jpg" alt="" /></p>

<h4><code>Setting Data Task Delegate Callbacks 设置数据任务代理的回调</code></h4>

<p>设置一个在数据任务获得response的时候回调block</p>

<p><img src="/media/14455662011592.jpg" alt="" /></p>

<p>设置一个block当数据任务变成下载的任务的时候执行</p>

<p><img src="/media/14455662317310.jpg" alt="" /></p>

<p>设置一个block当数据任务获得到数据的时候
<img src="/media/14455662434172.jpg" alt="" /></p>

<p>设置一个block绝对是否缓存数据任务</p>

<p><img src="/media/14455662958106.jpg" alt="" /></p>

<h4><code>Download Task Delegate Callbacks 下载任务代理回调</code></h4>

<p>设置block当下载任务完成下载后</p>

<p><img src="/media/14455666105437.jpg" alt="" /></p>

<p>设置block去追踪下载任务进度情况</p>

<p><img src="/media/14455666301025.jpg" alt="" /></p>

<p>设置block当下载任务执行/恢复的时候 执行</p>

<p><img src="/media/14455666958363.jpg" alt="" /></p>

<p>头文件的内容基本就是以上的了。可以看到整个AF的体系非常清晰完整，没有多余的东西，头文件只暴露了应该暴露的东西，值得我们去学习。</p>

<h2>使用的例子</h2>

<h3>使用<code>AFURLSessionManager</code></h3>

<p>从源码中可以看到，<code>AFURLSessionManager</code>实现了</p>

<pre><code class="Objective-c">NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate, NSSecureCoding, NSCopying
</code></pre>

<p>首先需要设置url和NSURLConfirguration</p>

<p>这里是使用百度API商店的公开API
<img src="/media/14453928846040.jpg" alt="" /></p>

<p>然后初始化Manager<img src="/media/14453929237373.jpg" alt="" /></p>

<p>设置ResponseSerializer
<img src="/media/14453931412125.jpg" alt="" /></p>

<p>初始化request
<img src="/media/14453932169242.jpg" alt="" /></p>

<p>对request进行相关设置
<img src="/media/14453932396509.jpg" alt="" /></p>

<p>根据request生成对应的<code>NSURLSessionTask</code>。
<img src="/media/14453935717679.jpg" alt="" /></p>

<p>执行任务
<img src="/media/14453936154108.jpg" alt="" /></p>

<p>来看看执行后的信息</p>

<p><img src="/media/14453937344699.jpg" alt="" /></p>

<p>这里由于使用的<code>AFHTTPResponseSerializer</code>(API的问题，仅仅支持text/plain)所以在获取的数据后，我们自己要json序列化。如果是设计好的API,直接使用<code>AFJSONRequestSerializer</code>就可以在回调中获取到json格式的数据了。</p>

<p>可以看到，整个使用还是很方便的。我们可以根据自己的需求配置不同设置。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[json&amp;xml]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/24/json-and-xml/"/>
    <updated>2015-09-24T16:44:36+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/24/json-and-xml</id>
    <content type="html"><![CDATA[<h1>网络传输格式 JSON &amp; XML</h1>

<p>第一次接触这两个格式还是在学校做一个财务管理系统的时候。在之前变成都是纯粹的单机编程，不设计到网络数据传输的问题。到了这个项目才开始考虑如何在服务器和客户端之间传输数据。项目中使用的是JSON，所以在这里先讲JSON的部分。</p>

<h2>JSON</h2>

<p>JSON是一种轻量化的数据格式。他的特点就是方便已用。目前90%的网络传输都是依赖于JSON格式。</p>

<p>首先来看看JSON格式是怎么样的。</p>

<pre><code class="json">
"access_token": "ACCESS_TOKEN",

   "expires_in": 1234,

   "remind_in":"798114",

   "uid":"12341234"
</code></pre>

<p>这是一个常见的JSON格式。比较容易的看出，其实就是一种key-value的形式。</p>

<p>key我们都好了解，是一个string。那么value就会有不一样的值。通过对比OC的对象，我们可以更容易的理解JSON中的数据类型。</p>

<pre><code>            JSON                    OC

            {}                      NSDictionary

            []                      NSArray

            ""                      NSString

           数字                     NSNumber
</code></pre>

<p>知道了JSON所对应的OC对象，我们就可以通过解析JSON对象，将相关的数据转换成OC对象来存储。在这里，介绍一种能够在本地模拟API的方式，这也是由于自己找不到很好的开发API所以想在本地能够模拟API的方式。</p>

<h2>JSON Server 模拟 API</h2>

<h3>第一步 安装</h3>

<ul>
<li>安装Homebrew。这个可是个神器，能够管理mac上的第三方的库的工具。据说被作者写不出反转二叉树个谷歌拒了然后去了苹果。</li>
</ul>


<p><code>ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</code></p>

<ul>
<li>安装node.js</li>
</ul>


<p><code>brew install node</code></p>

<ul>
<li>安装json-server</li>
</ul>


<p><code>npm install -g json-server  
</code></p>

<h2>根据需求创建JSON</h2>

<p>安装完毕后，随便找个你喜欢的文件夹，创建一个JSON格式的文件，如下
<code>JSON
{
  "posts": [
    { "id": 1, "title": "json-server", "author": "typicode" }
  ],
  "comments": [
    { "id": 1, "body": "some comment", "postId": 1 }
  ],
  "profile": { "name": "typicode" }
}
</code></p>

<p>然后保存。</p>

<h3>启动JSON-Server</h3>

<p>通过命令<code>json-server --watch JSON文件的名字.json</code>来启动Server</p>

<p>到这里，我们就相当于在本地创建了一个服务器能够相应我们想对应的请求。</p>

<p>以上面的的JSON文件为例</p>

<p><img src="/media/14430769630713.jpg" alt="" /></p>

<p>当然，功能不止这么一点，JSON-Server还有更多方式，详见github<a href="https://github.com/typicode/json-server">json-server</a></p>

<h2>OC对象和JSON对象的转换</h2>

<ul>
<li><p>通过<code>NSJSONSerialization</code>来序列化JSON.</p>

<p>  <img src="/media/14430773793672.jpg" alt="" /></p></li>
</ul>


<p>输出的结果</p>

<p><img src="/media/14430774045308.jpg" alt="" /></p>

<p>对比上面的JSON数据，我们可以看出解析的结果是正确的</p>

<ul>
<li>通过第三方库JSONKit来解析</li>
</ul>


<p> 下载地址 <a href="https://github.com/johnezang/JSONKit">JSONKit</a></p>

<p> <img src="/media/14430745214364.jpg" alt="" /></p>

<ul>
<li>使用Mantle</li>
</ul>


<p>在项目中用的最多的方法，也觉得非常好用</p>

<p>下载地址：<a href="https://github.com/Mantle/Mantle">Mantle</a></p>

<p>使用的方法：</p>

<ol>
<li><p>在本地创建对应的OC类
<img src="/media/14430784491980.jpg" alt="" /></p></li>
<li><p>实现相关的方法</p></li>
</ol>


<p><img src="/media/14430794069120.jpg" alt="" /></p>

<p>第三种是直接将JSON通过一定的方法转成了OC的类对象。在使用的时候感觉更方便。</p>

<h2>XML</h2>

<p>虽然JSON在网络传输中有90%的使用率，但是我们依然不能放弃10%的XML是吧。</p>

<p>XML全称是Extensible Markup Language，译作“可扩展标记语言”
跟JSON一样，也是常用的一种用于交互的数据格式
一般也叫XML文档（XML Document）</p>

<p>下面是一个典型的XML文件的结构</p>

<pre><code>一个元素包括了开始标签和结束标签
拥有元素内容：&lt;city&gt;上海&lt;/city&gt;
没有元素内容：&lt;city&gt;&lt;/city&gt;
没有元素内容的简写：&lt;city/&gt; 

一个元素可以嵌套若干个子元素（不能出现交叉嵌套）
&lt;citys&gt;
    &lt;city&gt;
        &lt;name&gt;上海&lt;/name&gt;
        &lt;weather&gt;大暴雨&lt;/weather&gt;
          &lt;air&gt;舒适&lt;/air&gt;
    &lt;/city&gt;
&lt;/citys&gt;

规范的XML文档最多只有1个根元素，其他元素都是根元素的子孙元素
XML中的所有空格和换行，都会当做具体内容处理

一个元素可以拥有多个属性，属性值必须用 双引号"" 或者 单引号'' 括住。
&lt;city name="上海" weather="大暴雨" air="舒适" /&gt;


属性表示的信息也可以用子元素来表示，比如

   &lt;city&gt;
        &lt;weather&gt;大暴雨&lt;/weather&gt;
          &lt;air&gt;舒适&lt;/air&gt;
    &lt;/city&gt;
</code></pre>

<p>解析XML有两种方式</p>

<ol>
<li>DOM解析：一次性将整个XML文档加载进内存，比较适合解析小文件</li>
<li>SAX解析：从根元素开始，按顺序一个元素一个元素往下解析，比较适合解析大文件</li>
</ol>


<p>在iOS SDK里面，提供了两种解析的框架</p>

<ol>
<li>NSXMLParser：它是基于objective-c语言的sax解析框架，是ios sdk默认的xml解析框架，不支持dom模式。</li>
<li>libxml2: 它是基于c语言的xml解析器，被苹果整合在ios sdk中，支持sax和dom模式。</li>
</ol>


<p>同样，第三方也有许多解析XML的库。这里不打算讲第三方的，一个XML使用的比较少，一个使用SDK自身的效率往往已经非常好了。</p>

<h3>NSXMLParser</h3>

<p>NSXMLParser属于SAX解析，是从上往下依次解析每个元素，在解析到每个元素的时候会通知代理，所以使用NSXMLParser必须遵守他的协议。
使用非常简单</p>

<p><img src="/media/14430815879826.jpg" alt="" />
从当前项目读取XML文件，读出数据，穿件解析器，设置代理，开始解析。</p>

<p>XML文件内容如下</p>

<p><img src="/media/14430816475695.jpg" alt="" />
设置代理后，我们要实现代理方法，主要有以下方法，直接上图了</p>

<p><img src="/media/14430816906329.jpg" alt="" /></p>

<p><img src="/media/14430817012681.jpg" alt="" /></p>

<p><img src="/media/14430833160910.jpg" alt="" /></p>

<p><img src="/media/14430833236999.jpg" alt="" /></p>

<h3>libxml2</h3>

<p>重点在于导入libxml2的库</p>

<p><img src="/media/14430836046841.jpg" alt="" /></p>

<p><img src="/media/14430836140287.jpg" alt="" /></p>

<p><img src="/media/14430836178120.jpg" alt="" /></p>

<p><img src="/media/14430836230051.jpg" alt="" /></p>

<p><img src="/media/14430836285068.jpg" alt="" /></p>

<p>编译项目，通过了就没问题了。</p>

<p>用法参见<a href="https://github.com/neonichu/GDataXML"></a></p>

<h2>总结</h2>

<p>在实际使用中，还JSON用的更多，所以对于JSON的解析过程要更加了解。对于XML，有一些公司任然会使用，而一些现存的数据也会用XML存储，所有也要有一定的了解。</p>

<p>这篇文章讲解了在网络通信中数据的格式。下一篇的话就进入iOS内如何进行网络通信了。虽然使用AFNetWorking已经有段时间了，但是对内部整个机制并不了解，要好好补课了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IP TCP HTTPs 随便谈]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/18/title/"/>
    <updated>2015-09-18T16:48:55+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/18/title</id>
    <content type="html"><![CDATA[<h1>IP TCP HTTPs 随便谈</h1>

<p>在总结自己的技能书的缺点后，决定优先补充自己在计算机网络上知识的漏洞。现在互联网企业，离开了互联网什么都不是。对互联网，普通人可能停留在概念和使用上，而开发人员应该去深入的了解运行进制，进而去优化自己开发的产品。这篇文章，主要是记录自己最近看的一些资料的笔记。</p>

<!--more-->


<p></p>

<h2>IP 协议</h2>

<p>IP协议，是网络协议（Internet Protocol）的缩写。IP协议是互联网众多协议的基础。</p>

<p>IP协议实现了解<code>*分组交换网络*</code>。在协议下，每个机器被称为<code>*主机*</code>，IP协议明确了主机之间数据包的传输方式。</p>

<p>数据包，也就是一段二进制数据，包含了传输源的主机的信息。IP协议的特点是<code>*尽力服务*</code>（best effort），提供有效的服务并尽可能的传输。这说明，在传输过程中，可能会丢失数据包，也可能传输了多个相同的数据包。</p>

<p>IP 网络中的主机都配有自己的地址，被称为<code>*IP 地址*</code>。每个数据包中都包含了源主机和目标主机的 IP 地址。IP 协议负责路径计算，即 IP 数据包在网络中的传输传输时，数据包所经过的每一个主机节点都会读取数据包中的目标主机地址信息，以便选择朝什么地方传送数据包。</p>

<h2>蛋疼的IPv4</h2>

<p>如今，多数数据包任然使用的是IPv4（版本4），每一个IP地址都是32位的。比如192.168.1.1就是一个IPV4地址。我们可以算下，IPv4有多少个地址。。嗯，好像很多有43亿吗。。但是呢，到了10年的时候，就已经不到8%的了。。</p>

<p>人们发现IPV4不够用啊，快用完了啊，用完了就不能加主机了啊！！！那怎么办，启用新的协议版本啊，所以除了个IPv6，将地址扩充到128位了。比如<code>2001:0db8:85a3:0042:1000:8a2e:0370:7334</code>
就是一个IPv6的地址了。</p>

<p>128位就是2的128次方个，据说够地球上每个沙子配一个IP了。但是呢，这个协议转换的很慢，目前基本国内的都是还是使用IPv4协议。。看来也不是很着急么。。</p>

<h2>IP数据包的结构</h2>

<p>一个IP数据包通常包括一个数据头部（header）和有效数据（payload）。有效数据自然是数据包中要传送的数据。而数据头部就是包含了一些传输数据相关的数据。</p>

<h4>我们先来看个IPv4的头部</h4>

<p><img src="/media/Screen%20Shot%202015-09-20%20at%2020.15.59.png" alt="Screen Shot 2015-09-20 at 20.15.59" /></p>

<p>可以看到，头部信息包含了当前版本的信息，payload采用的协议。Total Length 表明是有效数据加上头部信息长度的总长度。</p>

<h4>在来看看一个IPv6的报头信息</h4>

<p><img src="/media/14427519874258.jpg" alt="" /></p>

<p>IPv6的头部长度固定到了40.同时IPv6可以链接下一个头部信息（Next Header）。</p>

<h2>数据传输</h2>

<p>我们知道，在数据链路层对对所传输的数据帧数有限制，<code>*（MTU，最大传输单元）*</code>。在IPv4的上，使用<code>*分片*</code>来对数据包进行处理。具体来说，我们可以认为如果数据超过了最大传输单元，那么就会将数据切成几片。当数据到达目标主机后，可以根据分片的信息进行重组。当然，发送源可以选择不进行对数据进行<code>*分片*</code>。如果超过了链路层最大传输单元又不进行<code>*分片*</code>的话，发送源就会收到ICMP（Internet Control Message Protocol，Internet报文控制协议）的数据帧超长报告信息。</p>

<p>在IPv6中，如果数据包超过了长度限制，路由会直接丢弃数据包（好狠）并且向ICMP6报告数据帧过长。然后数据源和目标源会根据这个特性来进行<code>路由发现</code>，就是寻找两端之间最大传输单元的路由。找到最大传输单元的路由后，仅当此时数据包任然超过最大传输单元的时候，IPv6才会进行分片。`对于IPv6下的TCP来说，不会造成什么影响。</p>

<hr />

<p>到此，IP协议就到了一个段落了。IP协议是TCP协议的基础，因此了解是必须的。</p>

<h2>TCP协议</h2>

<p>TCP协议是重头戏。TCP协议是重头戏。TCP协议是重头戏。重要的事情要说三遍。</p>

<p>上面说了，IP协议是基于<code>尽可能服务</code>的，那么TCP协议就是要基于IP协议，解决IP协议采用的不可靠传输引起的复杂的问题。因此，下面的重点就是来谈谈TCP连接的三个部分：建立连接，传输数据，断开连接的详细过程</p>

<h4>TCP建立连接</h4>

<p>首先，我们要知道TCP连接是全双工的,是建立在两个主机之间的。每个连接都存在两种角色：<code>服务器端，监听连接</code>，<code>客户端，主动连接服务器端</code>。客户端主动连接服务器端被称为<code>active open(主动打开)</code>。而服务器端这种监听连接的行为被称为<code>passive open(被动打开)</code>。</p>

<p><strong>三次握手</strong></p>

<p>TCP建立连接是一个确认和反复确认的过程，我们习惯统称为三次握手。这个地方也是几乎所有面试会问的地方，需要注意了。</p>

<p>三次连接，具体的过程有语言描述为以下的过程。</p>

<blockquote><ol>
<li>客服端向服务器端发送SYN包和一个随机序列号X，表示本次的连接的身份。</li>
<li>服务器端收到客服端发送的连接的请求以后，发送一个SYN-ACK包和一个确认ack号X+1(确认序列号X的连接请求确认)。此时服务器还会发送一个随机序列号Y，表示向客户端连接的请求。</li>
<li>客户端收到服务器的回复后，会发送一个ACK包，一个确认号Y+1和序列号X+1给服务器。</li>
</ol>
</blockquote>

<p>SYN包，为<code>synchronize sequence numbers (同步序列号)</code>。用于确认两段传输数据的身份，确保数据包最后都达到了应该到的地方。在建立连接的时候，源和目标都需要确认<code>同步序列号</code>。</p>

<p>ACK包，为<code>acknowledgment (确认)</code>。某一端接到数据后，通过回传序列号来确认收到报文。</p>

<p><img src="/media/14428004882999.jpg" alt="三次握手" /></p>

<h4>传输数据</h4>

<p>建立连接，就是为了传输数据。发送端发出的报文都会带有一个序列号，与当前已传送的字节总数有关。接受端会根据已经接收的报文给发送端传送确认报文，确认信息同样在头部的缩写带的ACK。</p>

<p><img src="/media/14427976037921.jpg" alt="" /></p>

<p>注意的整个过程是双向的。两端都会持续的发送数据。X端发送的数据不会等到Y端发送确认后才发送下一个报文。</p>

<p>TCP协议是可靠的传输协议，所以有一系列复杂的机制来进行具体的的拥塞控制。需要处理的问题如下:<code>丢失报文重发</code>，<code>动态调整发送报文的频率</code></p>

<p><strong>流量控制</strong></p>

<p>流量控制的原则就是发送数据的一方的速度不能比接受数据一方的速度要快。接收方，也就是<code>接收窗口</code>会告诉发送方自身<code>接收窗口</code>数据缓冲区的大小。在tcp包，通过两个两个关键的字段可以得出接收窗口的大小:<code>win -- 窗口大小</code>和<code>wscale -- 窗口发大因子</code> 。如果win=65535 , wscale = 4，那么我们可以计算出接收窗口的大小是 64kB * 4 = 256kB。</p>

<p><strong>拥塞控制</strong></p>

<p>拥塞控制相比于流量控制要复杂一些。拥塞控制就是根据当前网络情况计算出当前网络数据传输的最佳速度。首先我们要认识到，最佳速度不一定就是要最快。一方面，我们希望以更快的速度传输数据。另一方面，由于传输的速度过快，导致大量的数据传入会使处理性能受到影响。在分组交换网络中有一个特点就是<code>超负荷崩溃</code>。当负载过大的时候，数据包之间会产生拥塞，直接导致丢包率上升。</p>

<blockquote><p>拥塞控制需要充分考虑对流量的影响。RFC 5681 中对 TCP 拥塞控制有 6,000 字左右的阐述。发送方要时刻关注来自接收方的确认信息。要做到这点并不简单，有的时候还需要一定的妥协。要知道底部 IP 协议数据包是无序传输的，数据包会丢失也会重复。发送方需要评估 RTT 往返时间，然后基于 RTT 去确定是否收到了接收方的确认信息。重发数据包也有很大代价，除了连接延迟问题，网络的负载也会发生明显的波动。导致 TCP 需要不停的去适应当前网络情况。</p>

<p>更重要的是，TCP 连接本身是易变的。除了数据传输，连接的两端还会不时的发送一些提醒和确认信息以便可以适当的调整状态来维持连接。</p>

<p>基于这种一直在相互协调中的连接关系，TCP 连接往往会是短暂而低效的。在建立连接的初期，TCP 协议算法还不能完全了解当前网络状况。而在连接将要结束的时候，反馈给发送方的信息又可能不充分，这样就很难对连接状况做出实时的合理的评估。</p></blockquote>

<p><em>四次挥手，断开连接</em></p>

<p>建立连接是通过<code>三次握手</code>，而释放连接是通过<code>四次握手</code>。在最下方有图示解释整个过程。那么为什么需要四次握手才能释放连接呢？</p>

<p>上文提到了，TCP是全双工的，因此每个方向上的连接需要单独关闭。这个原则就是当一方没有数据可以传送的时候，发送FIN来终止这一方的连接，但是另一方向上的数据仍然可以发送。当另一方向也发送了FIN的时候，整个连接才完全的关闭了。无论服务器端还是客户端都可以发送来FIN来主动关闭连接。</p>

<p><img src="/media/14428004433668.jpg" alt="四次挥手" /></p>

<h2>HTTPS</h2>

<p>之前的博文谈到了HTTP（超文本传输协议）。如今苹果操作系统iOS也升级到了iOS9。在iOS9中强制所有网络传输协议使用HTTPS。看来对HTTPS的了解是势在必行的了。</p>

<p>HTTPS,实际上可以看作HTTP的加密版本。HTTPS将HTTP协议数据包放到SSL/TSL层加密后，在TCP/IP蹭去传输。到了目标源后，在SST/TSL将数据包解密，传递到HTTP层就是普通的HTTP数据包了。</p>

<p>HTTPS = HTTP + SSL/TSL</p>

<p><strong>SSL/TSL</strong></p>

<p>关于SSL/TSL，我们可以参考下面两篇文章：</p>

<p>!<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>

<p>!<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a></p>

<p>简单的来说，通过SSL/TSL四次握手，来解决下面三个问题。</p>

<ol>
<li>数字证书：该证书包含了公钥等信息，一般是由服务器发给客户端，接收方通过验证这个证书是不是由信赖的CA签发，或者与本地的证书相对比，来判断证书是否可信；假如需要双向验证，则服务器和客户端都需要发送数字证书给对方验证；</li>
<li>三个随机数：这三个随机数构成了后续通信过程中用来对数据进行对称加密解密的“对话密钥”。
 首先客户端先发第一个随机数N1，然后服务器回了第    二个随机数N2（这个过程同时把之前提到的证书发给    客户端），这两个随机数都是明文的；而第三个随机   数N3（这个随机数被称为Premaster secret），  客户端用数字证书的公钥进行非对称加密，发给服务   器；而服务器用只有自己知道的私钥来解密，获取第   三个随机数。这样，服务端和客户端都有了三个随机   数N1+N2+N3，然后两端就使用这三个随机数来生 成“对话密钥”，在此之后的通信都是使用这个“对话    密钥”来进行对称加密解密。因为这个过程中，服务端    的私钥只用来解密第三个随机数，从来没有在网络中   传输过，这样的话，只要私钥没有被泄露，那么数据   就是安全的。</li>
<li>加密通信协议：就是双方商量使用哪一种加密方式，假如两者支持的加密方式不匹配，则无法进行通信；</li>
</ol>


<p>具体的可以参考上面两篇文章的内容，去了解SSL/TSL加密的过程。在这里想重点说的是在iOS中使用HTTPS。</p>

<p>在iOS中，常用的是<code>NSURLConnection</code>支持HTTPS的实现。而常用的第三方库<code>AFNetworking</code>封装了使用<code>NSURLConnection</code>实现的逻辑代码，更加完善。在<code>AFNetworking</code>中使用的方法如下</p>

<pre><code>Objective-C

NSURL * url = [NSURL URLWithString:@"https://www.google.com"];
AFHTTPRequestOperationManager * requestOperationManager = [[AFHTTPRequestOperationManager alloc] initWithBaseURL:url];
dispatch_queue_t requestQueue = dispatch_create_serial_queue_for_name("kRequestCompletionQueue");
requestOperationManager.completionQueue = requestQueue;

AFSecurityPolicy * securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];

//allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO
//如果是需要验证自建证书，需要设置为YES
securityPolicy.allowInvalidCertificates = YES;

//validatesDomainName 是否需要验证域名，默认为YES；
//假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。
//置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。
//如置为NO，建议自己添加对应域名的校验逻辑。
securityPolicy.validatesDomainName = YES;

//validatesCertificateChain 是否验证整个证书链，默认为YES
//设置为YES，会将服务器返回的Trust Object上的证书链与本地导入的证书进行对比，这就意味着，假如你的证书链是这样的：
//GeoTrust Global CA 
//    Google Internet Authority G2
//        *.google.com
//那么，除了导入*.google.com之外，还需要导入证书链上所有的CA证书（GeoTrust Global CA, Google Internet Authority G2）；
//如是自建证书的时候，可以设置为YES，增强安全性；假如是信任的CA所签发的证书，则建议关闭该验证，因为整个证书链一一比对是完全没有必要（请查看源代码）；
securityPolicy.validatesCertificateChain = NO;

requestOperationManager.securityPolicy = securityPolicy;
</code></pre>

<h2>杂谈</h2>

<p>关于连接。TCP连接容易在两个地方出问题：初始设置，以及通过连接传输最后一部分的内容。</p>

<hr />

<p>建立连接的时候，TCP由于要进行三次握手，所以在这过程中会有一定的时间损耗。一般一个移动终端向服务发送一个数据包普遍需要250ms, 三次握手的话就是需要750ms。而在HTTPS中则更加夸张。因为HTTPS需要四次握手。。。嗯，在TCP和HTTPS都握手完后，大概需要1750ms.是建立一个HTTP连接的两倍。为了安全，就肯定要牺牲时间效率。</p>

<p>此外，由于TCP需要侦测当前最佳的转发路由，所以在传送大量的数据时，需要不停地去调整以便得到最佳速度。这种算法被称为<code>慢启动</code>。注意到，慢启动在数据链路层传输质量差的网络上表现的更差，无线网络就是典型的例子。(4G说，怪我咯)。</p>

<hr />

<p>通过TCP释放连接的过程，我们也知道可能存在问题</p>

<blockquote><p>如果发送方完成数据发送，接受方自然会停止发送 ACK 确认。在最后四个报文传输的过程中，快速重发算法是没有办法处理这四个报文的数据包的丢失问题的（因为不会收到三个相同的确认 ACK，所以不能界定传输丢包）。在常规网络环境下，四个数据包相当于 5.7kB 的数据规模。总之，在这最后 5.7kB 的传输的过程中，快速重发机制是无效的。针对这种情况，TCP 会启用其他机制来侦测丢包问题。对于这种情况，重传操作可能要消耗几秒钟去执行，这并不奇怪</p></blockquote>

<hr />

<p><em>超时处理</em></p>

<p>在APP实际处理中，经常发生网络请求超时的现象。许多APP大概在15秒后收不到反馈就会提示超时信息。这种设计其实并不是很友好。我们知道，只有TCP连接还在，TCP都会保证将请求发送出去并会等待响应的返回，只是时间长短的问题。</p>

<p>个人在这里参考了一些APP的做法，觉得应该在每次请求的时候设置一个计时器，当计时器到达倒数完成后，可以提示用户是否继续网络请求，如果取消就将TCP连接断开，如果继续就继续等待网络请求响应。</p>

<h2>最后</h2>

<p>了解了IP TCP HTTPS后，接下来想阅读一些文章怎么从这些方面入手去优化网络请求。在互联网时代，数据和网络是承载产品的基础。因此，网络，怎么深入学习都不过分。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[socket]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/13/socket/"/>
    <updated>2015-09-13T05:27:26+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/13/socket</id>
    <content type="html"><![CDATA[<h2>写在前面</h2>

<p>最近一直在找更好的实习，发现网络编程是一个优秀的程序员必备的技能。而自己在学校中学到的东西很少（逃。要不是有之前的实习和做个一个小小的项目，对于很多知识可能还只是停留在书本上（其实就是没进脑）。最近有人问我是否了解socket，我顿时语塞。对与socket的认识还是学习java的时候知道可以使用socket进行客户端与服务器端的通信，可是当时并没有去实践。欠下的债都是要还的。</p>

<p>此外为什么我每篇博文的开头都写点自己的感受。我觉得博客不仅仅是记录自己的技术积累，也是抒发自己心情的一个途经，所以我会在每篇文章前面写一点点自己在写博文的时候的心情。</p>

<!--more-->


<p></p>

<h2>正文</h2>

<p>socket，套接字，是基于TCP/IP协议族下的一种网络通信方式。我们知道，在本地，进程之间有多种方法去通信。在网络中，我们同样可以使用socket进行通信。接下来一步步来看socket是如何使网络上的进程相互通信的。</p>

<p>我们知道，要像让进程通信，首先必须确认进程的身份。如同我们只有知道了和自己谈话的是谁，我们才知道谈什么。在本地，进程拥有唯一的标识PID。在网络上，基于TCP/IP协议，通过<em>IP，协议，端口号</em>，我们可以确认一个进程的唯一身份。</p>

<p>使用TCP/IP协议的应用程序通常采用应用编程接口，有本文讲到的socket（套接字）和TIL（被淘汰了）。目前而言，绝多大数的应用程序都是基于socket进行网络通信的，所以了解socket是一个程序员必备的。</p>

<h2>scocket 究竟是什么</h2>

<p>socket起源于UNIX。我们知道UNIX的设计原理就是<em>一切皆文件</em>，操作都是<em>open -> read/write -> close</em>。所以说，我们可以认为socket也是一个文件，是基于上述设计原理的实现。socket函数就是专门来完成相应操作的。</p>

<h2>socket 操作</h2>

<p>在上面我们知道了socket是一个文件，那么socket自然有对应的操作方法，下面是基于TCP的几个基本操作。
(注，本文的方法是使用Objective-C写的，其实socket在任何语言都是差不多的)</p>

<pre><code class="objective-c">
// 创建并初始化socket，返回socket的文件描述符，如果返回值为-1则创建失败
int socket(int addresFamily, int type, int protocol)

// 关闭socket
int close(int socketFileDescriptor)

// 将socket与特定的IP地址和端口号绑定，成功返回0，失败返回-1
int bind(int socketFileDescriptor, sockadd *addressToBind)

// 接受客户端的请求并且将客户端的网络地址信息存入clientAddress
// 当客户端的连接请求被接受后，双方的通信链路就建立好了，两者就可以开始通信了。

int accept(int socketFileDescriptor, sockaddr *clientAddress, int clientAddressStructLength)

// 客户端向特定的IP的服务器发送连接请求，成功返回0，失败返回-1
// 当服务器建立好后，客户端就可以通过这个函数与服务器端建立连接。
// 对于UDP来说，该接口是可选的，如果调用了这个接口表明设置了UDP socket默认的网络地址.
// 对于TCP来说，这里就是三次握手发生的地方

int connect(int socketFileDescriptor, sockaddr *serverAddress, int serverAddressLength)

// 通过DNS查找特定的IP，如果找不到返回NULL
hostent *gethostbyname(char *hostname)

// 发送数据，发送成功后返回成功发送的字节数，否则返回-1
int send(int socketFileDescriptor,char *buffer, int flags)

// 接收数据，成功后返回成功读取的字节数，否则返回-1
int receive(int socketFileDesciptor,char *buffer,int flags)

// 下面两个方法是UDP的方法

// UDP发送,返回状态同上
int sendto(int socketFileDesciptor, char *buffer, int bufferLength, int flags, sockaddr *destinationAddress, int destinationAddressLength)

// UDP读取，返回状态同上
int recvfrom(int socketFileDesciptor, char *buffer, int bufferLength, int flags, sockaddr *fromAddress, int fromAddressLength)
</code></pre>

<p>通过观察方法，我们发现socket其实就是<em>确认目标 ->建立连接 -> 传送/读取 -> 断开</em> 的过程</p>

<p>我们再来看看TCP和UDP下socket操作的不同的地方</p>

<h4>TCP</h4>

<p><img src="http://www.coderyi.com//qiniu/429/image/5269612b25e6df1b3ee5ab8352b2c3b6.jpg" alt="TCP" /></p>

<h4>UDP</h4>

<p><img src="http://www.coderyi.com//qiniu/429/image/cd6d1690d3d6eefd300987e590c1483f.jpg" alt="UDP" /></p>

<h2>最后</h2>

<p>到此，对于socket编程的概念有了个一个初步的认识了。在实际开发中，我们一般不会直接调用这些底层的API。借助于一些开源的第三方库更有利于项目的开发运行。不过，对于基本的理论知识还是必须要掌握的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP学习]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/10/http/"/>
    <updated>2015-09-10T23:46:08+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/10/http</id>
    <content type="html"><![CDATA[<h1>HTTP学习</h1>

<p>HTTP协议是网络中最广泛的协议之一，对HTTP协议的了解应该是每一个和网络打交道的程序员必须具备的技能。很多公司面试都要求对网络知识有一定的了解，一个是TCP/IP协议，一个就是HTTP协议，HTTP协议应用层的协议，内容比较少，这周花时间去总结了一下，做一个备忘。</p>

<!--more-->


<p>  ##HTTP简单分析
HTTP是一个基于请求/响应模式的、无状态的协议。即，浏览器与服务端连接之后，浏览器向服务器发送一个请求，服务器返回响应信息之后，双方的链接就被关闭。</p>

<p>HTTP1.0是典型的请求/响应模式。</p>

<p>HTTP1.1在1.0的基础上进行了改进，加入了“持续连接”的机制。通过这种机制，客户端发送请求得到响应后，连接不会马上关闭，可以继续发送请求，还可以流水线发送多个请求、而不用等待每一个响应的到来。</p>

<ul>
<li><p>URI和URL + URL我们应该是很熟悉的了，全名是统一资源定位符，包含了需要查找的信息的资源。 + 而URI是URL的父集，纯粹是一个WEB的资源符号</p>

<h2>HTTP请求</h2></li>
</ul>


<p><img src="http://i3.tietuku.com/2c834f74cd465d7e.png" alt="HTTP Request" /></p>

<p>简单的来说 HTTP请求可以分为三部分</p>

<ol>
<li><p>请求行</p></li>
<li><p>消息报头</p></li>
<li><p>请求正文</p></li>
</ol>


<h3>请求行</h3>

<hr />

<p>请求行主要的内容是是请求方法和请求的位置（URL）</p>

<p>请求方法主要有以下几种方法（注意方法都是全部字母大写）</p>

<p><img src="http://i3.tietuku.com/05fa7108f6959f91.png" alt="HTTP Request method" /></p>

<p>在APP中，最多用的到的就是POST 和 GET 两种方法。许多地方都要求区别两者的区别，所以在这里做一下重点笔记对比两者方法的不同</p>

<p>（在这里小小的吐槽，在学校计算机网络的学习中，POST和GET的区别基本就是一句话：POST比GET更好更安全。其实在查阅了许多资料后，发现并没有那么简单）</p>

<hr />

<h4>POST</h4>

<ul>
<li><p>根据HTTP规范，POST表示可能修改服务器上的资源的请求，比如提交表格，注册等等都是常用POST</p></li>
<li><p>POST将请求的正文包在HTTP包体中</p></li>
<li><p>POST没有大小限制</p></li>
</ul>


<hr />

<h4>GET</h4>

<ul>
<li>GET操作，根据HTTP规范，仅仅用于信息获取，而且是应该是安全的幂等。</li>
<li><p>GET操作会将请求的数据附在URL后面，参数之间以&amp;相连（这就是为什么很多人认为GET不安全了）</p></li>
<li><p>GET的数据限制，由于浏览器或者服务器可能会对URL存在长度限制，所以有可能会产生影响</p></li>
</ul>


<p> 通过对比，我们发现常见的误区有两个</p>

<ol>
<li><p>POST比GET更安全。通过上面对比，我们发现，虽然POST没有将参数直接放在URL中，但是通过抓包的手段，我们依然可以获得HTTP包体中的参数。由此看来，想依靠POST就简单保证安全是不可能的。</p></li>
<li><p>POST能比GET传输更多。通过上面的叙述也可以得知，其实HTTP协议本身没有进行限制，POST和GET都没有大小限制，而是第三方的浏览器和服务器造成了差别</p></li>
</ol>


<p>什么时候用POST，什么时候用GET，我们要依据不同的使用场景来区分。如果有缓存的需求，那自然就不能用POST方法。如果必须要用表格，GET也不行了。</p>

<h2>HTTP响应</h2>

<p>请求响应类似与请求。如图所示</p>

<p>可以看到，HTTP响应的第一行叫状态行，包含了HTTP版本，状态码，状态描述信息。</p>

<p>状态码是判断请求状态的重要标志，由三位数字组成，有五种定义：</p>

<ol>
<li>1XX &mdash;- 请示信息，表示请求已经接受，可以继续处理</li>
<li>2XX &mdash;- 成功状态，表示请求被服务器接受</li>
<li>3XX &mdash;- 重定向，要完成请求的话需要更进一步的操作</li>
<li>4XX &mdash;- 客户端错误，请求错误或者请求无法被实现</li>
<li>5XX &mdash;- 服务器端错误，服务器未能完成合法的请求</li>
</ol>


<p>全部取值如下：</p>

<blockquote><pre><code>   100——客户必须继续发出请求
   101——客户要求服务器根据请求转换HTTP协议版本


    200——交易成功
    201——提示知道新文件的URL
    202——接受和处理、但处理未完成
    203——返回信息不确定或不完整
    204——请求收到，但返回信息为空
    205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
    206——服务器已经完成了部分用户的GET请求

    300——请求的资源可在多处得到
    301——删除请求数据
    302——在其他地址发现了请求数据
    303——建议客户访问其他URL或访问方式
    304——客户端已经执行了GET，但文件未变化
    305——请求的资源必须从服务器指定的地址得到
    306——前一版本HTTP中使用的代码，现行版本中不再使用
    307——申明请求的资源临时性删除

    400——错误请求，如语法错误
    401——请求授权失败
    402——保留有效ChargeTo头响应
    403——请求不允许
    404——没有发现文件、查询或URl
    405——用户在Request-Line字段定义的方法不允许
    406——根据用户发送的Accept拖，请求资源不可访问
    407——类似401，用户必须首先在代理服务器上得到授权
    408——客户端没有在用户指定的饿时间内完成请求
    409——对当前资源状态，请求不能完成
    410——服务器上不再有此资源且无进一步的参考地址
    411——服务器拒绝用户定义的Content-Length属性请求
    412——一个或多个请求头字段在当前请求中错误
    413——请求的资源大于服务器允许的大小
    414——请求的资源URL长于服务器允许的长度
    415——请求资源不支持请求项目格式
    416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段
    417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求

    500——服务器产生内部错误
    501——服务器不支持请求的函数
    502——服务器暂时不可用，有时是为了防止发生系统过载
    503——服务器过载或暂停维修
    504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长
    505——服务器不支持或拒绝支请求头中指定的HTTP版本
</code></pre></blockquote>

<p> 常见的错误主要有400 404 403 500 503等等</p>

<p>相应正文，包含了请求获得的资源，有HTML文件，JSON格式数据，文件的URL等等</p>

<h3>消息报头</h3>

<hr />

<p>HTTP请求和HTTP响应都有消息报头。而消息报头是由众多报头域组成。每一个报头域都由名字＋“：”＋空格组成，消息报头域的名字是大小写无关的。</p>

<p>HTTP消息报头包括普通报头、请求报头、响应报头和实体报头。</p>

<hr />

<h4>普通报头：</h4>

<p>在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。</p>

<p>常见的普通报头：</p>

<p>1）Cache-Control</p>

<pre><code>Cache-Control用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。

请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;
响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.
</code></pre>

<p>2）Date</p>

<pre><code>Date普通报头域表示消息产生的日期和时间
</code></pre>

<p>3）Connection</p>

<pre><code>Connection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接
</code></pre>

<hr />

<h4>请求报头</h4>

<p>请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。
（在APP中，一些身份验证的信息可能需要在header中添加）</p>

<p>常见的请求报头：</p>

<p>1)Accept</p>

<pre><code>Accept请求报头域用于指定客户端接受哪些类型的信息。
</code></pre>

<p>2)Accept-Charset</p>

<pre><code>Accept-Charset请求报头域用于指定客户端接受的字符集。如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。
</code></pre>

<p>3）Accept-Encoding</p>

<pre><code>Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。
</code></pre>

<p>4）Accept-Language</p>

<pre><code>Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。
</code></pre>

<p>5）Authorization</p>

<pre><code>Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。
</code></pre>

<p>6）Host</p>

<pre><code>发送请求时，该报头域是必需的。Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。
</code></pre>

<p>7）User-Agent</p>

<pre><code>User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。
</code></pre>

<hr />

<h4>响应报头</h4>

<p>响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。</p>

<p>常见的实体报头：</p>

<p>1）Location</p>

<pre><code>Location响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。
</code></pre>

<p>2）Server</p>

<pre><code>Server响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。
</code></pre>

<p>3）WWW-Authenticate</p>

<pre><code>WWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。
</code></pre>

<hr />

<h4>实体报头</h4>

<p>请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。</p>

<p>实体报头包括：</p>

<p>常见的实体报头：</p>

<p>1）Content-Encoding</p>

<pre><code>Content-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding主要用于记录文档的压缩方法。
</code></pre>

<p>2）Content-Language</p>

<pre><code>Content-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言
</code></pre>

<p>阅读者。</p>

<p>3）Content-Length</p>

<pre><code>Content-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。即一个数字字符占一个字节，用其对应的ASCII码来存储传输。
</code></pre>

<p>4）Content-Type</p>

<pre><code>Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。
</code></pre>

<p>5）Expires</p>

<pre><code>Expires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。
</code></pre>

<p>6）Last-Modified</p>

<pre><code>Last-Modified实体报头域用于指示资源的最后修改日期和时间。
</code></pre>

<h2>总结</h2>

<p>HTTP协议的内容不是多，常用的内容就几个，但是需要非常熟悉，因为HTTP协议是网络交互重要的协议之一。</p>

<p>接下来花一些时间去回顾TCP/IP协议，内容多就会有几篇文章来记录学习的一些笔记心得。</p>
]]></content>
  </entry>
  
</feed>
