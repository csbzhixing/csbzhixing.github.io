<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>学海无涯</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://csbzhixing.github.io/"/>
  <updated>2016-08-14T16:07:37.000Z</updated>
  <id>http://csbzhixing.github.io/</id>
  
  <author>
    <name>之行</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用GCD来实现个Timer</title>
    <link href="http://csbzhixing.github.io/2016/08/15/%E7%94%A8GCD%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%B8%AATimer/"/>
    <id>http://csbzhixing.github.io/2016/08/15/用GCD来实现个Timer/</id>
    <published>2016-08-14T16:04:39.000Z</published>
    <updated>2016-08-14T16:07:37.000Z</updated>
    
    <content type="html">&lt;p&gt;##少用NSTimer&lt;/p&gt;
&lt;p&gt;在iOS中开发中，定时器是经常用到的工具。一般情况下，我们都会去使用&lt;code&gt;NSTimer&lt;/code&gt;这个类。然而，这个类一旦使用不当的话，会给我们造成很多无法预见的坑。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSTimer&lt;/code&gt;有哪些坑，一个个来数一数&lt;/p&gt;
&lt;h3 id=&quot;Timer必须作用在一个运行中的runloop&quot;&gt;&lt;a href=&quot;#Timer必须作用在一个运行中的runloop&quot; class=&quot;headerlink&quot; title=&quot;Timer必须作用在一个运行中的runloop&quot;&gt;&lt;/a&gt;Timer必须作用在一个运行中的&lt;code&gt;runloop&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;用过&lt;code&gt;NSTimer&lt;/code&gt;的都知道，在创建了&lt;code&gt;NSTimer&lt;/code&gt;之后，必须将NSTimer加入到runloop中。如果是在主线程的还好，因为主线程默认是有runLoop的（实际上一般很少会在主线程开timer）。如果是在子线程，那么就要手动激活runLoop先，不然就调用时无效的。&lt;/p&gt;
&lt;h3 id=&quot;操作必须在同一个线程中&quot;&gt;&lt;a href=&quot;#操作必须在同一个线程中&quot; class=&quot;headerlink&quot; title=&quot;操作必须在同一个线程中&quot;&gt;&lt;/a&gt;操作必须在同一个线程中&lt;/h3&gt;&lt;p&gt;NSTimer的创建与撤销必须在同一个线程操作、performSelector的创建与撤销必须在同一个线程操作&lt;/p&gt;
&lt;h3 id=&quot;内存泄漏&quot;&gt;&lt;a href=&quot;#内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏&quot;&gt;&lt;/a&gt;内存泄漏&lt;/h3&gt;&lt;p&gt;一般用NSTimer最容易出现的问题。首先来分析为什么会出现这个情况。&lt;/p&gt;
&lt;p&gt;通常，我们创建一个&lt;code&gt;NSTimer&lt;/code&gt;的方法是调用以下的API：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;
+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;

- (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)ti target:(id)t selector:(SEL)s userInfo:(nullable id)ui repeats:(BOOL)rep NS_DESIGNATED_INITIALIZER;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个时候，target会被timer持有，引用计数+1。&lt;/p&gt;
&lt;p&gt;此时，如果直接销毁target，即使在target的deallco里面调用了[timer invaild]也无用。因为timer和target相关，因此必须提前调用[timer invaild]。这种BUG最常见的的就是一个&lt;code&gt;UIViewController&lt;/code&gt;pop的时候，timer没有被invaild，结果&lt;code&gt;UIViewController&lt;/code&gt;没有被销毁，导致了内存泄漏。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This method is the only way to remove a timer from an NSRunLoop object. The NSRunLoop object removes its strong reference to the timer, either just before the invalidate method returns or at some later point.&lt;/p&gt;
&lt;p&gt;If it was configured with target and user info objects, the receiver removes its strong references to those objects as well.&lt;br&gt;You must send this message from the thread on which the timer was installed. If you send this message from another thread, the input source associated with the timer may not be removed from its run loop, which could prevent the thread from exiting properly.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意到官方文档中提到，runLoop会持有NSTimer的引用，因此除了调用&lt;code&gt;invaild&lt;/code&gt;方法外，没有别的方法.&lt;/p&gt;
&lt;p&gt;##用GCD代替NSTimer&lt;/p&gt;
&lt;p&gt;用过GCD的都说好，可以说把GCD玩的很溜的话，很多异步并行问题都能解决，在这里我们就要去解决NSTimer的坑的问题。这里用三个开源库来抛砖引玉，讲讲不同的实现由什么优缺点。&lt;/p&gt;
&lt;p&gt;###RNTimer&lt;/p&gt;
&lt;p&gt;这个库很老了，12年后就没有更新了，内容也很简单，只有两个文件，因为代码很少，直接上源码了&lt;/p&gt;
&lt;h4 id=&quot;源码摘要&quot;&gt;&lt;a href=&quot;#源码摘要&quot; class=&quot;headerlink&quot; title=&quot;源码摘要&quot;&gt;&lt;/a&gt;源码摘要&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;Objective-C&quot;&gt;
@interface RNTimer : NSObject

/**---------------------------------------------------------------------------------------
 @name Creating a Timer
 -----------------------------------------------------------------------------------------
*/

/** Creates and returns a new repeating RNTimer object and starts running it

 After `seconds` seconds have elapsed, the timer fires, executing the block.
 You will generally need to use a weakSelf pointer to avoid a retain loop.
 The timer is attached to the main GCD queue.

 @param seconds The number of seconds between firings of the timer. Must be greater than 0.
 @param block Block to execute. Must be non-nil

 @return A new RNTimer object, configured according to the specified parameters.
*/
+ (RNTimer *)repeatingTimerWithTimeInterval:(NSTimeInterval)seconds block:(dispatch_block_t)block;


/**---------------------------------------------------------------------------------------
 @name Firing a Timer
 -----------------------------------------------------------------------------------------
*/

/** Causes the block to be executed.

 This does not modify the timer. It will still fire on schedule.
*/
- (void)fire;


/**---------------------------------------------------------------------------------------
 @name Stopping a Timer
 -----------------------------------------------------------------------------------------
*/

/** Stops the receiver from ever firing again

 Once invalidated, a timer cannot be reused.

*/


@interface RNTimer ()
@property (nonatomic, readwrite, copy) dispatch_block_t block;
@property (nonatomic, readwrite, assign) dispatch_source_t source;
@end

@implementation RNTimer
@synthesize block = _block;
@synthesize source = _source;

+ (RNTimer *)repeatingTimerWithTimeInterval:(NSTimeInterval)seconds
                                                                            block:(void (^)(void))block {
    NSParameterAssert(seconds);
    NSParameterAssert(block);

    RNTimer *timer = [[self alloc] init];
    timer.block = block;
    timer.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,
                                                                                0, 0,
                                                                                dispatch_get_main_queue());
    uint64_t nsec = (uint64_t)(seconds * NSEC_PER_SEC);
    dispatch_source_set_timer(timer.source,
                                                        dispatch_time(DISPATCH_TIME_NOW, nsec),
                                                        nsec, 0);
    dispatch_source_set_event_handler(timer.source, block);
    dispatch_resume(timer.source);
    return timer;
}

- (void)invalidate {
    if (self.source) {
        dispatch_source_cancel(self.source);
        dispatch_release(self.source);
        self.source = nil;
    }
    self.block = nil;
}

- (void)dealloc {
    [self invalidate];
}

- (void)fire {
    self.block();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;实现分析&quot;&gt;&lt;a href=&quot;#实现分析&quot; class=&quot;headerlink&quot; title=&quot;实现分析&quot;&gt;&lt;/a&gt;实现分析&lt;/h4&gt;&lt;p&gt;实现很简单，用的是最基本的方法，即创建了一个&lt;code&gt;dispatch_source_t&lt;/code&gt;，传入&lt;code&gt;block&lt;/code&gt;，然后通过&lt;code&gt;dispatch_source_set_timer&lt;/code&gt;将timer添加到&lt;code&gt;dispatch_source&lt;/code&gt;，设置事件处理为传入的block,然后执行timer。&lt;/p&gt;
&lt;p&gt;提供两个和&lt;code&gt;NSTimer&lt;/code&gt;一样的方法，&lt;code&gt;invalidate&lt;/code&gt;和&lt;code&gt;fire&lt;/code&gt;。&lt;code&gt;fire&lt;/code&gt;会立即执行block，但是不会使timer失效，依然会按照预定计划执行。&lt;/p&gt;
&lt;p&gt;在API定义上，保持了和&lt;code&gt;NSTimer&lt;/code&gt;一样的定义，所以切换起来没有压力。但是简单也以为这功能不完善。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无法暂停挂起timer&lt;/li&gt;
&lt;li&gt;无法指定线程&lt;/li&gt;
&lt;li&gt;无法添加新的任务到timer中&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;MSWeakTimer&quot;&gt;&lt;a href=&quot;#MSWeakTimer&quot; class=&quot;headerlink&quot; title=&quot;MSWeakTimer&quot;&gt;&lt;/a&gt;MSWeakTimer&lt;/h3&gt;&lt;p&gt;&lt;code&gt;MSWeakTimer&lt;/code&gt;的API设计成和&lt;code&gt;NSTimer&lt;/code&gt;一样，调用的方法也一致，直接使用并没有什么副作用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Objective-C&quot;&gt;
- (id)initWithTimeInterval:(NSTimeInterval)timeInterval
                                        target:(id)target
                                    selector:(SEL)selector
                                    userInfo:(id)userInfo
                                     repeats:(BOOL)repeats
                         dispatchQueue:(dispatch_queue_t)dispatchQueue;

                         /**
 * Creates an `MSWeakTimer` object and schedules it to start ticking inmediately.
 */
+ (instancetype)scheduledTimerWithTimeInterval:(NSTimeInterval)timeInterval
                                                                                target:(id)target
                                                                            selector:(SEL)selector
                                                                            userInfo:(id)userInfo
                                                                             repeats:(BOOL)repeats
                                                                 dispatchQueue:(dispatch_queue_t)dispatchQueue;

                                                                 /**
 * Starts the timer if it hadn&amp;#39;t been schedule yet.
 * @warning calling this method on an already scheduled timer results in undefined behavior.
 */
- (void)schedule;

/**
 * Sets the amount of time after the scheduled fire date that the timer may fire to the given interval.
 * @discussion Setting a tolerance for a timer allows it to fire later than the scheduled fire date, improving the ability of the system to optimize for increased power savings and responsiveness. The timer may fire at any time between its scheduled fire date and the scheduled fire date plus the tolerance. The timer will not fire before the scheduled fire date. For repeating timers, the next fire date is calculated from the original fire date regardless of tolerance applied at individual fire times, to avoid drift. The default value is zero, which means no additional tolerance is applied. The system reserves the right to apply a small amount of tolerance to certain timers regardless of the value of this property.
 As the user of the timer, you will have the best idea of what an appropriate tolerance for a timer may be. A general rule of thumb, though, is to set the tolerance to at least 10% of the interval, for a repeating timer. Even a small amount of tolerance will have a significant positive impact on the power usage of your application. The system may put a maximum value of the tolerance.
 */
@property (atomic, assign) NSTimeInterval tolerance;

/**
 * Causes the timer to be fired synchronously manually on the queue from which you call this method.
 * You can use this method to fire a repeating timer without interrupting its regular firing schedule.
 * If the timer is non-repeating, it is automatically invalidated after firing, even if its scheduled fire date has not arrived.
 */
- (void)fire;

/**
 * You can call this method on repeatable timers in order to stop it from running and trying
 * to call the delegate method.
 * @note `MSWeakTimer` won&amp;#39;t invoke the `selector` on `target` again after calling this method.
 * You can call this method from any queue, it doesn&amp;#39;t have to be the queue from where you scheduled it.
 * Since it doesn&amp;#39;t retain the delegate, unlike a regular `NSTimer`, your `dealloc` method will actually be called
 * and it&amp;#39;s easier to place the `invalidate` call there, instead of figuring out a safe place to do it.
 */
- (void)invalidate;

- (id)userInfo;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现&lt;/h4&gt;&lt;p&gt;先来看初始化方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (id)initWithTimeInterval:(NSTimeInterval)timeInterval
                                        target:(id)target
                                    selector:(SEL)selector
                                    userInfo:(id)userInfo
                                     repeats:(BOOL)repeats
                         dispatchQueue:(dispatch_queue_t)dispatchQueue
{
        NSParameterAssert(target);
        NSParameterAssert(selector);
        NSParameterAssert(dispatchQueue);

        if ((self = [super init]))
        {
                self.timeInterval = timeInterval;
                self.target = target;
                self.selector = selector;
                self.userInfo = userInfo;
                self.repeats = repeats;

                NSString *privateQueueName = [NSString stringWithFormat:@&amp;quot;com.mindsnacks.msweaktimer.%p&amp;quot;, self];
                self.privateSerialQueue = dispatch_queue_create([privateQueueName cStringUsingEncoding:NSASCIIStringEncoding], DISPATCH_QUEUE_SERIAL);
                dispatch_set_target_queue(self.privateSerialQueue, dispatchQueue);

                self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,
                                                                                        0,
                                                                                        0,
                                                                                        self.privateSerialQueue);
        }

        return self;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将传入的参数复制给当前类的属性，然后初始化&lt;code&gt;privateSerialQueue&lt;/code&gt;，&lt;code&gt;privateSerialQueue&lt;/code&gt;的名称是&lt;code&gt;privateQueueName&lt;/code&gt;，可变参数为当前对象的内存地址。调用&lt;code&gt;dispatch_set_target_queue&lt;/code&gt;将传参的&lt;code&gt;dispatchQueue&lt;/code&gt;优先级赋给&lt;code&gt;privateSerialQueue&lt;/code&gt;。最后，初始化&lt;code&gt;timer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后看执行函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)schedule
{
        [self resetTimerProperties];

        __weak MSWeakTimer *weakSelf = self;

        dispatch_source_set_event_handler(self.timer, ^{
                [weakSelf timerFired];
        });

        dispatch_resume(self.timer);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先调用了&lt;code&gt;resetTimerProperties&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)resetTimerProperties
{
        int64_t intervalInNanoseconds = (int64_t)(self.timeInterval * NSEC_PER_SEC);
        int64_t toleranceInNanoseconds = (int64_t)(self.tolerance * NSEC_PER_SEC);

        dispatch_source_set_timer(self.timer,
                                                            dispatch_time(DISPATCH_TIME_NOW, intervalInNanoseconds),
                                                            (uint64_t)intervalInNanoseconds,
                                                            toleranceInNanoseconds
                                                            );
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;resetTimerProperties&lt;/code&gt;重置&lt;code&gt;timer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;intervalInNanoseconds&lt;/code&gt;和&lt;code&gt;toleranceInNanoseconds&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;充当&lt;code&gt;interval&lt;/code&gt;和&lt;code&gt;leeway&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在执行完&lt;code&gt;resetTimerProperties&lt;/code&gt;后，&lt;code&gt;dispatch_source_set_event_handler&lt;/code&gt;一个block到&lt;code&gt;timer&lt;/code&gt;，执行&lt;code&gt;timerFired&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)timerFired
{
        // Checking attomatically if the timer has already been invalidated.
        if (OSAtomicAnd32OrigBarrier(1, &amp;amp;_timerFlags.timerIsInvalidated))
        {
                return;
        }

        // We&amp;#39;re not worried about this warning because the selector we&amp;#39;re calling doesn&amp;#39;t return a +1 object.
        #pragma clang diagnostic push
        #pragma clang diagnostic ignored &amp;quot;-Warc-performSelector-leaks&amp;quot;
                [self.target performSelector:self.selector withObject:self];
        #pragma clang diagnostic pop

        if (!self.repeats)
        {
                [self invalidate];
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里&lt;code&gt;OSAtomicAnd32OrigBarrier&lt;/code&gt;是个值得关注的函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OSAtomicAnd32OrigBarrier&lt;/code&gt;是一个原子操作的布尔与运算，且带有内存屏障。&lt;code&gt;OSAtomicAnd32OrigBarrier&lt;/code&gt;保证了在与操作之前数据结构的存储结构发生改变。&lt;/p&gt;
&lt;p&gt;详细的只是可以参考下面这篇文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;&quot;&gt;http://southpeak.github.io/blog/2014/10/17/osatomicyuan-zi-cao-zuo/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这里，&lt;code&gt;_timerFlags.timerIsInvalidated&lt;/code&gt;与1做与操作，如果返回return 则返回，如果不是，执行.&lt;/p&gt;
&lt;p&gt;这里如果不加入&lt;code&gt;invalidate&lt;/code&gt;的话，恐怕说不清楚为什么这里要做这个判断&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)invalidate
{
        // We check with an atomic operation if it has already been invalidated. Ideally we would synchronize this on the private queue,
        // but since we can&amp;#39;t know the context from which this method will be called, dispatch_sync might cause a deadlock.
        if (!OSAtomicTestAndSetBarrier(7, &amp;amp;_timerFlags.timerIsInvalidated))
        {
                dispatch_source_t timer = self.timer;
                dispatch_async(self.privateSerialQueue, ^{
                        dispatch_source_cancel(timer);
                        ms_release_gcd_object(timer);
                });
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;    if (!OSAtomicTestAndSetBarrier(7, &amp;amp;_timerFlags.timerIsInvalidated))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;OSAtomicTestAndSetBarrier&lt;/code&gt;和&lt;code&gt;OSAtomicAnd32OrigBarrier&lt;/code&gt;正好可以作为一个相对操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OSAtomicTestAndSetBarrier(7, &amp;amp;_timerFlags.timerIsInvalidated)&lt;/code&gt;会指定变量中的一个bit，把它设置为‘1’并返回旧值。如果要指定32bit integer最低位，n应该是7。因此如果第一次调用&lt;code&gt;OSAtomicTestAndSetBarrier&lt;/code&gt;的话，返回false同时话将&lt;code&gt;timerIsInvalidated&lt;/code&gt;置成1.由于原子操作和内存屏障，这个方法不会和&lt;code&gt;OSAtomicAnd32OrigBarrier&lt;/code&gt;一同执行。如果执行到&lt;code&gt;timerFired&lt;/code&gt;的时候，&lt;code&gt;OSAtomicAnd32OrigBarrier(1, &amp;amp;_timerFlags.timerIsInvalidated)&lt;/code&gt;返回true，就会返回了。通过这个方法保证了在调用&lt;code&gt;invalidate&lt;/code&gt;后将timer失效。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;timerFired&lt;/code&gt;如果能执行，则通过&lt;code&gt;performSelector&lt;/code&gt;来调用对用的&lt;code&gt;SEL&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;invalidate&lt;/code&gt;中，如果需要释放，需要调用&lt;code&gt;dispatch_async&lt;/code&gt;。原因是我们虽然通过原子操作保证了&lt;code&gt;invalidated&lt;/code&gt;，但是我们无法确定当前的上下文情况，使用&lt;code&gt;dispatch_async&lt;/code&gt;可能会造成死锁。&lt;/p&gt;
&lt;p&gt;主流程分析就是如此，&lt;code&gt;MSWeakTimer&lt;/code&gt;最值得关注的就是上面讲解决线程同步的方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MSWeakTimer&lt;/code&gt;解决了前面提到的问题中无法添加指定线程（实际上也不是添加到那个线程，而是新开了一个线程）。由于模仿的是&lt;code&gt;NSTimer&lt;/code&gt;的API，所以另外两个方法也没有解决。&lt;/p&gt;
&lt;h2 id=&quot;我的实现-–-ZXGCDTimer&quot;&gt;&lt;a href=&quot;#我的实现-–-ZXGCDTimer&quot; class=&quot;headerlink&quot; title=&quot;我的实现 – ZXGCDTimer&quot;&gt;&lt;/a&gt;我的实现 – ZXGCDTimer&lt;/h2&gt;&lt;p&gt;在参考了上面的两个开源库后，自己动手撸了一个简单的基于GCD的Timer。基本解决了上面提到了三个问题。&lt;/p&gt;
&lt;p&gt;代码地址：&lt;a href=&quot;&quot;&gt;https://github.com/csbzhixing/ZXGCDTimer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;思路是，通过&lt;code&gt;ZXGCDTimerManager&lt;/code&gt;提供对外操作包括创建，执行，取消，挂起，回复功能。每个timer通过&lt;code&gt;ZXGCDTimer&lt;/code&gt;为单位去管理，以&lt;code&gt;timerName&lt;/code&gt;去区分不同的timer。支持自定义线程，支持新增Action。&lt;/p&gt;
&lt;p&gt;由于是自己处于研究目的写的，可能存在各种问题，也欢迎大家提出批评和指正。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##少用NSTimer&lt;/p&gt;
&lt;p&gt;在iOS中开发中，定时器是经常用到的工具。一般情况下，我们都会去使用&lt;code&gt;NSTimer&lt;/code&gt;这个类。然而，这个类一旦使用不当的话，会给我们造成很多无法预见的坑。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSTimer&lt;/code&gt;有哪
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一年</title>
    <link href="http://csbzhixing.github.io/2016/04/07/post/"/>
    <id>http://csbzhixing.github.io/2016/04/07/post/</id>
    <published>2016-04-06T16:03:44.000Z</published>
    <updated>2016-04-06T16:04:24.000Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;转眼间，我已经实习一年了。
转眼间，要大学毕业了。

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果不看日历，不去想时间，似乎和一年前的这个时候也没有什么不同。一样的担心，一样的焦虑。&lt;br&gt;一年前，因为自己陷入了学习的盲区，不知道如何去提升自己，只好想办法找个实习，想说自己找找自己的学习的方向。这么一做，就是一年过去了。&lt;/p&gt;
&lt;p&gt;实习的一年，可以说很辛苦，也很充实。辛苦是因为不仅仅要完成自己学习上的东西，还要去完成工作上的事情，这点对我来说的确是不小的挑战。大学的前两年里面，每天白天上上课，晚上搞下作业，然后就可以快乐的玩耍了。然而到了实习，白天的工作就足以让自己心力交瘁，晚上回到学校后还有许多课业要补习。即使如此，我也没有后悔。如果不是实习，我现在可能还在盲目不知道怎么去找工作；如果不是实习，自己可能现在还在纠结自己未来在哪个方向前进；如果不是实习，可能现在还有改不掉的一堆学生气。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;时间不会让人成长，只有痛苦可以


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;还记得刚开始实习的时候特别痛苦。用学校那套学习方法进入工作肯定是行不通的。所以开始的一个月，在iOS上并没有什么长进。硬生生的啃了几本书也然并卵。到了第二个月，接触了项目，有了目标，一点点的去实现一个个目标，结合原理，才真正有了一点点突破。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;知识永远学不完，钱永远赚不完，找到自己的路就行


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;十月份换了个实习，回到了深圳。一个原因是原来的公司人员变动，自己也觉得平台太小已经没法接触更多的东西了，除此外回到深圳也可以解放自己更多时间来学习。于是乎很幸运的来到了现在的公司。在这里，从头开发了多个APP，接触了React Native。从一个辅助慢慢成为一个独立的开发。这个时候，很多同学已经确定下来了Offer.看着同学一个个比较自己的offer的时候，自己的心态也有点小小的波动。但是，最后，还是决定扎下来。现有的平台对于自己来说是足够的。一方面身边有足够厉害的人能够提携自己，一方面在项目和时间上能够让自己去深入学习和提高。比较1K,2k这点差距，技术积累和做人的学习恐怕才是最重要的。    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;一年后


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然前不久才写完新年总结，之后也好久没有更新什么技术文章，这个总结也算另开一个头。已经从毕设中解放的我有更多时间去深入iOS和js了。希望在一年后的今天，能够在两个技术栈上都有不小的成就。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;转眼间，我已经实习一年了。
转眼间，要大学毕业了。

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果不看日历，不去想时间，似乎和一年前的这个时候也没有什么不同。一样的担心，一样的焦虑。&lt;br&gt;一年前，因为自己陷入了学习的盲区，不知道如何去提升自己，只好想办法找个实习，
    
    </summary>
    
    
      <category term="心得" scheme="http://csbzhixing.github.io/tags/%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>2016</title>
    <link href="http://csbzhixing.github.io/2016/01/02/2016/"/>
    <id>http://csbzhixing.github.io/2016/01/02/2016/</id>
    <published>2016-01-01T16:51:17.000Z</published>
    <updated>2016-01-01T16:51:28.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Hello-2016-Goodbye-2015&quot;&gt;&lt;a href=&quot;#Hello-2016-Goodbye-2015&quot; class=&quot;headerlink&quot; title=&quot;Hello 2016, Goodbye 2015&quot;&gt;&lt;/a&gt;Hello 2016, Goodbye 2015&lt;/h1&gt;&lt;p&gt;转眼就一年过去了。感觉2015过的飞快。过年的时候去阳江好像就再前不久，如今已经是2016年。想起来今天过得特别快，大概是因为自己已经开始工作了吧。&lt;/p&gt;
&lt;p&gt;在三月份，也就是大三下学期的时候，发现自己学习进入了一个瓶颈。对待很多技术都感到很好奇，也感觉自己有想法在这个行业做下去，但是却找不到一个方向去深入地学习。于是乎，在妹子的鼓励下，决定找公司去实习，通过对实际商业生产的了解，调整自己的技术学习方向。然而就这么误打误撞地进入了iOS开发。在广州业速的六个月里面，我从一个只是听闻iOS开发和觉得macbook最牛逼的一个乡下人（好吧我承认这个是自嘲）到一个基本熟悉iOS的初级开发。在这过程中，得益于likid的指导和帮助，收获了许多学习上的心得。在之前自己的学习都是浅尝即止，并没有深入到技术的本质，所以导致了自己好像很多东西都知道，但是说起来却又好像什么都不太懂的样子。在学习iOS开发的过程中，也矫正了自己很多不良的习惯。其中是懂了baidu都是呵呵呵，要查资料还是谷歌大法好（好吧其实我学校不能翻墙，怎么去一个不存在的网站搜东西）。然后是github和stackoverflow两个社区了解也算知道了真正学技术应该去啥地方学习T T,原来我之前三年基本都白过了，还好知道的不晚。&lt;/p&gt;
&lt;p&gt;在十月的时候，在鹅厂无望后（主要是自己太水），决定回到深圳，来到了现在的这家公司。新公司给我最大的感受就是身边的大神特别多。其中最让我收益一个是charge对我在iOS开发上的指导，一个是春哥对我技术思考上的指导。在新公司里面，我不再把自己仅仅当做一个完成任务就好的实习生，而是更多地去作为一个团队的一份子。在这过程中，解决了之前很多从来都没思考也没有遇到过的问题，慢慢地能够更加独立地解决问题。虽然在新公司，加班的次数比起在广州多了不少，然而并没有让我觉得上班很无聊，似乎看来我还是适合干这行的，哈哈。在12月，新项目决定上React Native，这又给我了一个非常好的学习机会。在一周的时间学习了ES6和React Native的语法，写了几个简陋的组件，也算碰到了门槛。说不定2016年也会接触下安卓和前端开发。作为一个技术人，千万不能把自己限死在一个固定的平台上。掌握了基本的原则和思想，就应该能在所有的平台上都有所作为。学习能力和执行力永远是技术人的核心竞争力。&lt;/p&gt;
&lt;p&gt;得益于今年自己的实习有了一些小小的外快和大牛市一波行情。今年买了特别多得东西。从一堆耳机，几部手机，macbook和新台式，音响。虽然买了很多东西，但是基本上没有靠父母出什么钱。在消费观念上，一年里面也是波动了很多，从舍不得花钱，到乱花钱，到有目的的花钱。新一年里面，如果能顺利拿到offer，也要为未来考虑下了。虽然比起别人不用在外面租房省下了不少的开支，但不意味着自己能够乱花钱。希望能够在10年内尽早的完全独立。&lt;/p&gt;
&lt;p&gt;2015年，最大的收获就是想明白了，读书和锻炼这两样是绝对地收益终身的事情。于是乎，购入了kindle，买了跑鞋，开始了自己的精神和肉体的锻炼。这一年，读了杂七杂八的很多书，跑了快两百公里，感觉很不错，想在2016能够继续。只有保持健康的身体和清醒地大脑才能保持每天都能快乐地生活。&lt;/p&gt;
&lt;p&gt;2016年，是自己大学的最后一年。不出意外的话应该是在实习的过程中国不知不觉的结束自己的大学生涯。对于大学，对我个人而言，收获恐怕不多，唯有明白了自己没有选错自己未来从事的行业。想来，大学也算玩过，开心过，也不枉自己最后任性的青春。即将踏上社会，再也没有借口给自己找退路，只能和一切困难斗争下去。2016，应该是会是个值得纪念的年份。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hello-2016-Goodbye-2015&quot;&gt;&lt;a href=&quot;#Hello-2016-Goodbye-2015&quot; class=&quot;headerlink&quot; title=&quot;Hello 2016, Goodbye 2015&quot;&gt;&lt;/a&gt;Hello 2016, Good
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>让Xcode的控制台更给力点</title>
    <link href="http://csbzhixing.github.io/2015/12/03/xcode-color/"/>
    <id>http://csbzhixing.github.io/2015/12/03/xcode-color/</id>
    <published>2015-12-03T15:23:35.000Z</published>
    <updated>2016-04-04T06:10:25.000Z</updated>
    
    <content type="html">&lt;p&gt;用过Xcode的人都知道，Log是有多难堪多难堪，控制台各种蛋疼各种无语，看到APPCode的控制台后我时对xcode彻底无爱了。经过各种折腾，决定在当前的项目试验下增强log的功能，使用CocoaLumberjack和XcodeColors来使我们的控制台达到能看的效果。&lt;/p&gt;
&lt;p&gt;首先 打开CocoaLumberjack的github地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CocoaLumberjack/CocoaLumberjack&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/CocoaLumberjack/CocoaLumberjack&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用cocospod 安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;platform :ios, &amp;#39;8.0&amp;#39;
pod &amp;#39;CocoaLumberjack&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在自己工程文件下.pch下加入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define LOG_LEVEL_DEF ddLogLevel
#import &amp;lt;CocoaLumberjack/CocoaLumberjack.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在APPDelegate里面初始化log&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)initLogger
{

    // Standard lumberjack initialization
    [DDLog addLogger:[DDTTYLogger sharedInstance]];

    // And we also enable colors
    [[DDTTYLogger sharedInstance] setColorsEnabled:YES];

    [DDTTYLogger sharedInstance].logFormatter = [[DFCustomFormatter alloc] init];

    DDFileLogger *fileLogger = [[DDFileLogger alloc] init]; // File Logger
    fileLogger.rollingFrequency = 60 * 60 * 24; // 24 hour rolling
    fileLogger.logFileManager.maximumNumberOfLogFiles = 7;
    [DDLog addLogger:fileLogger];

    [self setConsoleColor];


}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到这里就完成了ddlog的初始化，但是到这里还没结束，因为这样仅仅是让框架运行起来，还没有到我们要的效果。&lt;/p&gt;
&lt;p&gt;我们想要的，应该是达到以下的目的&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;能够打印Log的发生位置，方法，时间&lt;/li&gt;
&lt;li&gt;能够根据不同Log级别有不同的颜色对应&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;完成第一点很简单，我们只需要实现自己的formatter就可以了&lt;/p&gt;
&lt;p&gt;实现&lt;code&gt;DDLogFormatter&lt;/code&gt;的协议&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;
#import &amp;quot;DDLog.h&amp;quot;

@interface DFCustomFormatter : NSObject &amp;lt;DDLogFormatter&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;@implementation DFCustomFormatter

- (NSString *)formatLogMessage:(DDLogMessage *)logMessage {
    NSString *logLevel;
    switch (logMessage-&amp;gt;_flag) {
        case DDLogFlagError    : logLevel = @&amp;quot;E&amp;quot;; break;
        case DDLogFlagWarning  : logLevel = @&amp;quot;W&amp;quot;; break;
        case DDLogFlagInfo     : logLevel = @&amp;quot;I&amp;quot;; break;
        case DDLogFlagDebug    : logLevel = @&amp;quot;D&amp;quot;; break;
        default                : logLevel = @&amp;quot;V&amp;quot;; break;
    }

    NSString *formatStr = [NSString stringWithFormat:@&amp;quot;[%@ %@][line %lu] %@&amp;quot;,
                            logMessage.fileName, logMessage-&amp;gt;_function,
                           (unsigned long)logMessage-&amp;gt;_line, logMessage-&amp;gt;_message];
    return formatStr;

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样我们就打印了需要的信息，更多的方法可以到DDLogMessage里面看提供了什么属性。&lt;/p&gt;
&lt;p&gt;完成第二点，就要借助XcodeColors&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://github.com/robbiehanson/XcodeColors&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/robbiehanson/XcodeColors&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装后，在APPDelegate中初始化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 打开颜色支持
[[DDTTYLogger sharedInstance] setColorsEnabled:YES];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后我们可以根据自己的喜好设置不同级别的Log的颜色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)setConsoleColor
{
#if TARGET_OS_IPHONE
    UIColor *pink = [UIColor colorWithRed:(255/255.0) green:(58/255.0) blue:(159/255.0) alpha:1.0];

#else
    NSColor *pink = [NSColor colorWithCalibratedRed:(255/255.0) green:(58/255.0) blue:(159/255.0) alpha:1.0];
#endif

    [[DDTTYLogger sharedInstance] setForegroundColor:pink backgroundColor:nil forFlag:DDLogFlagInfo];
    [[DDTTYLogger sharedInstance] setForegroundColor:[UIColor redColor] backgroundColor:nil forFlag:DDLogFlagError];
    [[DDTTYLogger sharedInstance] setForegroundColor:[UIColor orangeColor] backgroundColor:nil forFlag:DDLogFlagWarning];


}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到这里，还不能让控制台显示出颜色，要设置对应schema&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14491562929176.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;添加后，就可以让xcode的控制显示我们要的效果了。&lt;/p&gt;
&lt;p&gt;如果自己的项目本身有对应的log方法，可以用宏直接替换&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;用过Xcode的人都知道，Log是有多难堪多难堪，控制台各种蛋疼各种无语，看到APPCode的控制台后我时对xcode彻底无爱了。经过各种折腾，决定在当前的项目试验下增强log的功能，使用CocoaLumberjack和XcodeColors来使我们的控制台达到能看的效果。
    
    </summary>
    
      <category term="Xcode" scheme="http://csbzhixing.github.io/categories/Xcode/"/>
    
    
  </entry>
  
  <entry>
    <title>一周刷题总结 - 2</title>
    <link href="http://csbzhixing.github.io/2015/11/13/leetcode2/"/>
    <id>http://csbzhixing.github.io/2015/11/13/leetcode2/</id>
    <published>2015-11-13T14:08:35.000Z</published>
    <updated>2015-11-13T16:03:13.000Z</updated>
    
    <content type="html">&lt;p&gt;又到了一周题目总结时间。到现在为止总共完成了三十道题，每天大概做1-3题。感觉这个步骤还是比较适合自己的进度的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;leetcode 9&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给出一个Int值，判断是否是回文数字。&lt;/p&gt;
&lt;p&gt;我们可以想到，如果是字符串的话，我们可以通过字符串的处理方式来处理，但这里是一个数字。我们可以从回文的定义知道，如果我们将整个数字反转过来，如果仍然等于原来的数字，那么这个数字就是回文数。&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;bool isPalindrome(int x) {
    if(x&amp;lt;0) return false;
    if(x&amp;lt;10) return true;

    int y=0,temp = x;

    while(temp)
    {
        y = y*10 + (temp%10);
        temp/=10;
    }

    return x==y;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;leetcode 26&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;移除一个数组中重复的数字。&lt;/p&gt;
&lt;p&gt;根据题意，我们只需要将重复的数字不停地移动到数组末尾，然后缩短数组大小就可以了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;int removeDuplicates(int* nums, int numsSize) {

    if(numsSize&amp;lt;2) return numsSize;

    int cur = 0;int temp = nums[0];

    for(int i = 1;i&amp;lt;numsSize;i++)
    {
        if(nums[i] == temp) continue;
        else
        {
            nums[cur+1] = nums[i];
            cur++;
            temp = nums[i];
        }
    }    
    return cur+1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;leetcode 136&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给出一个数组，找出数组中唯一一个只出现了一次的数，其他的数都出现了两次，要求线性时间内完成且不能用额外的空间。&lt;/p&gt;
&lt;p&gt;这道题给的难度分类是中等，但是我看了下题目的通过率很高，说明又很巧妙地方法。我自己在开始做得时候想到的都都要用额外的存储空间。在看了别人的方法后才知道原来可以用异或方法，因为异或方法相当于交换了两个数。所以我们要做得就是遍历一次数组，用一个数与每个数组的数异或，最后保留的数就是唯一一个出现了一次的数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;int removeDuplicates(int* nums, int numsSize) {

    if(numsSize&amp;lt;2) return numsSize;

    int cur = 0;int temp = nums[0];

    for(int i = 1;i&amp;lt;numsSize;i++)
    {
        if(nums[i] == temp) continue;
        else
        {
            nums[cur+1] = nums[i];
            cur++;
            temp = nums[i];
        }
    }

    return cur+1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样地,leetcode还给出了一道相似的题目，就是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;leetcode 260&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这道题目和上面的题目基本一样，唯独不同的是给出的数组中有两个数只出现了一次。&lt;/p&gt;
&lt;p&gt;题目中提到了，要在线性时间内完成，我们还是要考虑从上面的题目中怎么改进就可以完成这道题目。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;int* singleNumber(int* nums, int numsSize, int* returnSize) {
    int i, *result = calloc(*returnSize = 2, sizeof(int));
    for(i = 0; i &amp;lt; numsSize; result[0] ^= nums[i++]);
    for(i = 0; i &amp;lt; numsSize; i++)
        if(nums[i] &amp;amp; result[0] &amp;amp; -result[0])
            result[1] ^= nums[i];
    result[0] ^= result[1];
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个方法，首先找出了一个result[0]，这个是保存了两个出现了一次的的数字的异或结果a xor b;&lt;br&gt;我们知道 如果a != b的话，那么a xor b就会保准他们每个数字的一部分的二进制。&lt;br&gt;那么第二部我们通过异或就可以刷选出一个结果。&lt;br&gt;通过 a xor b的结果再异或，就可以得出另一个结果。&lt;/p&gt;
&lt;p&gt;通过上面两道题目可以得出，简简单单的异或有时候可是非常强大的。&lt;/p&gt;
&lt;p&gt;##小结&lt;/p&gt;
&lt;p&gt;虽然每周做得题目不止这么多，但是受限时间，只能慢慢整理，优先整理我觉得值得思考的题目。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;又到了一周题目总结时间。到现在为止总共完成了三十道题，每天大概做1-3题。感觉这个步骤还是比较适合自己的进度的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;leetcode 9&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给出一个Int值，判断是否是回文数字。&lt;/p&gt;
&lt;p&gt;我们可以想到，如果是字符串的话
    
    </summary>
    
      <category term="数据结构" scheme="http://csbzhixing.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>rac</title>
    <link href="http://csbzhixing.github.io/2015/11/10/rac/"/>
    <id>http://csbzhixing.github.io/2015/11/10/rac/</id>
    <published>2015-11-09T16:39:45.000Z</published>
    <updated>2015-11-09T16:46:26.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;RAC学习&quot;&gt;&lt;a href=&quot;#RAC学习&quot; class=&quot;headerlink&quot; title=&quot;RAC学习&quot;&gt;&lt;/a&gt;RAC学习&lt;/h1&gt;&lt;p&gt;RAC，ReactiveCocoa,是github上一个非常有名的开源库，实习了在iOS上的函数式编程。在2.x版本之前库是使用Objective-C 实现的，在3.x版本之后使用swift实现。目前最新的版本是4.04;&lt;/p&gt;
&lt;p&gt;##RAC的改变&lt;/p&gt;
&lt;p&gt;RAC通过信号将不同的部分联系在了一起。&lt;/p&gt;
&lt;p&gt;RAC统一了对KVO、UI Event、Network request、Async work的处理，因为它们本质上都是值的变化(Values over time)。&lt;/p&gt;
&lt;p&gt;###KVO&lt;/p&gt;
&lt;p&gt;RAC通过监测属性的值的改变来做相关的操作。不过使用的是block。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Objective-C&quot;&gt;[RACAble(self.username) subscribeNext:^(NSString *newName) {
    NSLog(@&amp;quot;%@&amp;quot;, newName);
}];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看起来比KVO要容易的多，我们不用关注去创建和释放KVO。同时，我们还可以将信号串联起来，达成更多的目的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Objective-C&quot;&gt;// 只有当名字以&amp;#39;j&amp;#39;开头，才会被记录
[[RACAble(self.username)
   filter:^(NSString *newName) {
       return [newName hasPrefix:@&amp;quot;j&amp;quot;];
   }]
   subscribeNext:^(NSString *newName) {
       NSLog(@&amp;quot;%@&amp;quot;, newName);
   }];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###UI Event&lt;/p&gt;
&lt;p&gt;根据UI发生的改变做相应的处理，如果不用RAC的话，我们可能需要有很多步骤。比如检查输入框中的输入是否合法的时候，我们可以通过添加action，当键入的时候就讲输入框的值拿出来检查。这里我们只需要很简单的一段block就可以了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Objective-C&quot;&gt;RAC(self.logInButton, enabled) = [RACSignal
        combineLatest:@[
            self.usernameTextField.rac_textSignal,
            self.passwordTextField.rac_textSignal,
            RACObserve(LoginManager.sharedManager, loggingIn),
            RACObserve(self, loggedIn)
        ] reduce:^(NSString *username, NSString *password, NSNumber *loggingIn, NSNumber *loggedIn) {
            return @(username.length &amp;gt; 0 &amp;amp;&amp;amp; password.length &amp;gt; 0 &amp;amp;&amp;amp; !loggingIn.boolValue &amp;amp;&amp;amp; !loggedIn.boolValue);
        }];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每次当text的值改变的时候，自动向数据流中添加新的数据。如果有subscriber订阅者的时候，就会自动触发。&lt;/p&gt;
&lt;p&gt;###网络异步&lt;/p&gt;
&lt;p&gt;当我们有需求的时候，可以自己创建&lt;code&gt;RACSubject&lt;/code&gt;类型。我们可以认为&lt;code&gt;RACSubject&lt;/code&gt;是一个具有高度自定义的信号(是RACSignal的子类)；&lt;/p&gt;
&lt;p&gt;当我们要进行一个网络请求的时候，可以通过创建信号的方式，让相关的成员订阅该信号，就可以在请求返回的时候执行相关的方法了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Objective-C&quot;&gt;
- (void)doTest
{
    RACSubject *subject = [self doRequest];

    [subject subscribeNext:^(NSString *value){
        NSLog(@&amp;quot;value:%@&amp;quot;, value);
    }];
}

- (RACSubject *)doRequest
{
    RACSubject *subject = [RACSubject subject];
    // 模拟2秒后得到请求内容
    // 只触发1次
    // 尽管subscribeNext什么也没做，但如果没有的话map是不会执行的
    // subscribeNext就是定义了一个接收体
    [[[[RACSignal interval:2] take:1] map:^id(id _){
        // the value is from url request
        NSString *value = @&amp;quot;content fetched from web&amp;quot;;
        [subject sendNext:value];
        return nil;
    }] subscribeNext:^(id _){}];
    return subject;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##常见的概念&lt;/p&gt;
&lt;p&gt;###Signal and Subscriber&lt;/p&gt;
&lt;p&gt;在RAC中，最重要的概念就是信号和订阅者。信号必须有了订阅者才会被获取到（热信号），如果不是，则是处于冷藏状态（冷信号）。&lt;/p&gt;
&lt;p&gt;当信号获得了相关数据后，就会执行订阅者的&lt;code&gt;sendNext, sendComplete, sendError&lt;/code&gt;方法。订阅者也有相关的方法来获取相关的数据，比如&lt;code&gt;[signal subscribeNext:error:completed]&lt;/code&gt;。这个时候只要没有&lt;code&gt;sendError&lt;/code&gt;和&lt;code&gt;sendComplete&lt;/code&gt;传过来，就会有源源不断的数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Objective-C&quot;&gt;[RACObserve(self, username) subscribeNext: ^(NSString *newName){
    NSLog(@&amp;quot;newName:%@&amp;quot;, newName);
}];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;RACObserve使用了KVO来监听property的变化，只要username被自己或外部改变，block就会被执行。但不是所有的property都可以被RACObserve，该property必须支持KVO，比如NSURLCache的currentDiskUsage就不能被RACObserve。&lt;/p&gt;
&lt;p&gt;信号是可以被处理的，通常有以下几种处理信号的方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;map 修改&lt;/li&gt;
&lt;li&gt;filter 过滤&lt;/li&gt;
&lt;li&gt;combine 组合&lt;/li&gt;
&lt;li&gt;chain 串联&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;Objective-C&quot;&gt;
RAC(self.logInButton, enabled) = [RACSignal
        combineLatest:@[
            self.usernameTextField.rac_textSignal,
            self.passwordTextField.rac_textSignal,
            RACObserve(LoginManager.sharedManager, loggingIn),
            RACObserve(self, loggedIn)
        ] reduce:^(NSString *username, NSString *password, NSNumber *loggingIn, NSNumber *loggedIn) {
            return @(username.length &amp;gt; 0 &amp;amp;&amp;amp; password.length &amp;gt; 0 &amp;amp;&amp;amp; !loggingIn.boolValue &amp;amp;&amp;amp; !loggedIn.boolValue);
        }];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面这个例子就是通过组合了四个信号来处理一个复杂的兴矿。&lt;/p&gt;
&lt;p&gt;###冷信号和热信号&lt;/p&gt;
&lt;p&gt;上面提到过冷热信号的问题，简单的来说就是一个信号是否有订阅者的关系。&lt;/p&gt;
&lt;p&gt;注意，如果一个信号有多个订阅者的时候，signal里面的block会被执行多次，要控制的话就要通过replay的方法去控制。&lt;/p&gt;
&lt;p&gt;###UI Category&lt;/p&gt;
&lt;p&gt;RAC提供了很多category的方法来为我们增加了便利，比如上文的rac_textSignal就是对label的一个方法。具体的可以通过自己在实践中摸索，这里有两个要特别注意的。&lt;/p&gt;
&lt;p&gt;我们知道常用的组件当中，最麻烦的就是tableview 的应用。在RAC中，我们可以通过跟踪&lt;code&gt;NSArray&lt;/code&gt;来跟踪数据源，这样在新的数据增加的时候或者旧的数据被移除的时候我们就可以更新tableview。&lt;/p&gt;
&lt;p&gt;还有个很特殊的情况就是cell在重载时候。RAC提供了一个方法&lt;code&gt;rac_prepareForReuseSignal&lt;/code&gt;，它的作用是在cell即将被重用的时候，告诉cell。我们可以想多，如果每个cell上面都有多个button，每次重载的时候都要去addTarget,被重用的时候又要去移除这些target，下面是我看到的一个实例代码，可以很好地解决这个问题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Objective-C&quot;&gt;[[[self.cancelButton
    rac_signalForControlEvents:UIControlEventTouchUpInside]
    takeUntil:self.rac_prepareForReuseSignal]
    subscribeNext:^(UIButton *x) {
    // do other things
}];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有个很常用的地方就是button。我们知道button的点击可能会根据不同的状态有不同的行为。RAC提供了一个category，有一个方法&lt;code&gt;rac_command&lt;/code&gt;。这样每次button按下后都是返回一个信号，这样我们可以更灵活地处理这个button的状态。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Objective-C&quot;&gt;
voteButton.rac_command = [[RACCommand alloc] initWithEnabled:self.viewModel.voteCommand.enabled signalBlock:^RACSignal *(id input) {
    // Assume that we&amp;#39;re logged in at first. We&amp;#39;ll replace this signal later if not.
    RACSignal *authSignal = [RACSignal empty];

    if ([[PXRequest apiHelper] authMode] == PXAPIHelperModeNoAuth) {
        // Not logged in. Replace signal.
        authSignal = [[RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
            @strongify(self);

            FRPLoginViewController *viewController = [[FRPLoginViewController alloc] initWithNibName:@&amp;quot;FRPLoginViewController&amp;quot; bundle:nil];
            UINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:viewController];

            [self presentViewController:navigationController animated:YES completion:^{
                [subscriber sendCompleted];
            }];

            return nil;
        }]];
    }

    return [authSignal then:^RACSignal *{
        @strongify(self);
        return [[self.viewModel.voteCommand execute:nil] ignoreValues];
    }];
}];
[voteButton.rac_command.errors subscribeNext:^(id x) {
    [x subscribeNext:^(NSError *error) {
        [SVProgressHUD showErrorWithStatus:[error localizedDescription]];
    }];
}];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的这段代码提供了一个投票的按钮的事件处理。首先判断是否已经登录了，如果没有登录，则弹出登陆框。如果登录了，就发送HTTP请求。&lt;/p&gt;
&lt;p&gt;对于数据结构，通知中心，NSObject都有不同的category。不过我还没研究那么深，所以有心得的时候会再来说说。&lt;/p&gt;
&lt;p&gt;##小结&lt;br&gt;由于刚好要做毕设，本来大家的建议最好是拿以前的项目来提交，这样的话比较省事，但是我觉得这个是一个机会，能够让自己去研究一些新的技术，也可以让自己去接触一些可能在公司中接触的不到的方面。通过一周的学习，对RAC已经有了一点点心得，接下来会在毕设项目中大量使用。&lt;/p&gt;
&lt;p&gt;后面可能还是想结合网络请求来看看怎么使用RAC，毕竟多数的业务都是网络请求-&amp;gt;数据组织-&amp;gt;页面展示-&amp;gt;交互的过程。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RAC学习&quot;&gt;&lt;a href=&quot;#RAC学习&quot; class=&quot;headerlink&quot; title=&quot;RAC学习&quot;&gt;&lt;/a&gt;RAC学习&lt;/h1&gt;&lt;p&gt;RAC，ReactiveCocoa,是github上一个非常有名的开源库，实习了在iOS上的函数式编程。在2.x版本
    
    </summary>
    
      <category term="Objective-C" scheme="http://csbzhixing.github.io/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>一周刷题总结 - 1</title>
    <link href="http://csbzhixing.github.io/2015/11/06/week-code-1/"/>
    <id>http://csbzhixing.github.io/2015/11/06/week-code-1/</id>
    <published>2015-11-06T14:36:06.000Z</published>
    <updated>2015-11-06T14:36:56.000Z</updated>
    
    <content type="html">&lt;p&gt;上周开始复习算法和数据结构，一周每天在睡前都拿出不少时间去学习，做了一些题目，想来每周都应该把相关的题目总结一下，才能更好的去学习。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;237    Delete Node in a Linked List&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是上次笔记里面写过的内容，但是我自己写得时候又出现了问题，看来简单的问题业不能去忽略。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
void deleteNode(struct ListNode* node) {
    if(node == NULL) return;
    struct ListNode *temp = node-&amp;gt;next;
    node-&amp;gt;val = temp-&amp;gt;val;
    node-&amp;gt;next = temp-&amp;gt;next;
    free(temp);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;171    Excel Sheet Column Number&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单的来说就是一个26进制的数，没什么难点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int titleToNumber(char* s) {
    int length = strlen(s);

    int all = 0;

    for(int i=0;i&amp;lt;length;i++)
    {
        all=((s[i]-&amp;#39;A&amp;#39;)+1) + all * 26;
    }

    return all;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;169    Majority Element&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;出现超过n/2的数，通过遍历就可以了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;
int majorityElement(int* nums, int numsSize) {
    int time=0,maj;
    for(int i=0;i&amp;lt;numsSize;i++)
    {
        if(time == 0)
        {
            maj = nums[i];
        }
        if(nums[i]==maj) 
        {
            time++;
        }
       else{
         time--;  
       } 
    }
    return maj;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;206    Reverse Linked List&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;反转链表，基础题目&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* reverseList(struct ListNode* head) {

    struct ListNode* pre = NULL;
    struct ListNode* cur = head;
    struct ListNode* next = NULL;

    while(cur)
    {
        next = cur-&amp;gt;next;
        cur-&amp;gt;next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;263    Ugly Number&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单的递归问题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;
bool isUgly(int num) {

    if(num&amp;lt;1) return false;

    if(num%2==0)
    {
        num/=2;
        return isUgly(num);
    }

     if(num%3==0)
    {
        num/=3;
        return isUgly(num);
    }

     if(num%5==0)
    {
        num/=5;
        return isUgly(num);
    }

    if(num == 1) return true;

    return false;

}
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;上周开始复习算法和数据结构，一周每天在睡前都拿出不少时间去学习，做了一些题目，想来每周都应该把相关的题目总结一下，才能更好的去学习。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;237    Delete Node in a Linked List&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是上次笔记里
    
    </summary>
    
      <category term="数据结构" scheme="http://csbzhixing.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>runtime</title>
    <link href="http://csbzhixing.github.io/2015/11/01/runtime/"/>
    <id>http://csbzhixing.github.io/2015/11/01/runtime/</id>
    <published>2015-11-01T02:07:27.000Z</published>
    <updated>2015-11-01T16:57:36.000Z</updated>
    
    <content type="html">&lt;p&gt;从开始写博客的时候，就由一个准备把Runtime好好研究整理出来。后来发现写runtime得文章太多了，而且自己研究的也算不上有多么深入，写出来估计很多错误- —–（因为主要是给自己看得）。最近在项目中，第一次用到了runtime解决了一个实际问题，这启发我，我的文章应该从怎么利用runtime去解决实际的问题，给自己提供一个解决问题的新思路。&lt;/p&gt;
&lt;p&gt;##runtime 关联对象&lt;/p&gt;
&lt;p&gt;从关联对象说起，是因为在最近的项目中用到了这个方法。当时的场景是，我需要创建一个category，里面需要一个block对象。然而我们知道，我们不能在category中添加成员变量。如果我们尝试添加的话，编译器会报错。当然，使用全局变量能解决这个问题，但明显是一个很优雅的方法，也很容易造成错误。Objective-C针对这一中问题，提供了一个解决方案，就是&lt;code&gt;关联对象(Associated Object)。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们可以想象，关联对象就是一个key - value的模型，把对象通过特定的Key链接到相关的实例上。不过由于使用的是C的借口，所以key是一个void指针。同时，我们要需要为这个关联对象设定内存管理策略。相关的内存的管理策略如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;OBJC_ASSOCIATION_ASSIGN

OBJC_ASSOCIATION_RETAIN_NONATOMIC

OBJC_ASSOCIATION_COPY_NONATOMIC

OBJC_ASSOCIATION_RETAIN

OBJC_ASSOCIATION_COPY
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对&lt;code&gt;OBJC_ASSOCIATION_ASSIGN&lt;/code&gt;的，当关联对象所关联的实例被释放掉后，对象不会被释放掉。而&lt;code&gt;OBJC_ASSOCIATION_RETAIN&lt;/code&gt;和&lt;code&gt;OBJC_ASSOCIATION_COPY&lt;/code&gt;两个的话，在实例被释放掉同时，关联对象也会被release掉。当我们用同一个key去关联另外的实例对象的时候，也会自动释放掉之前关联的对象。这种情况下，先前的关联对象会被妥善地处理掉，并且新的对象会使用它的内存。&lt;/p&gt;
&lt;p&gt;关联对象的的runtime函数如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 设置关联对象

void objc_setAssociatedObject ( id object, const void *key, id value, objc_AssociationPolicy policy );



// 获取关联对象

id objc_getAssociatedObject ( id object, const void *key );



// 移除关联对象

void objc_removeAssociatedObjects ( id object );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面就给出在项目中实际遇到的问题给做一个例子。&lt;/p&gt;
&lt;p&gt;首先在头文件中定义了以下内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14463463210542.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，这个category是为了扩展vc，让vc具有一个弹出系统通讯录的功能。&lt;/p&gt;
&lt;p&gt;在.m文件中，如下实现block关联对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14463464447032.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后就像正常的对象一样操作就行了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14463464914602.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14463464837182.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上面看到，我对关联对象使用的key是用了&lt;code&gt;@selector()&lt;/code&gt;。那为什么可以使用SEL来代替设定一个固定的key呢？&lt;/p&gt;
&lt;h2 id=&quot;方法与消息&quot;&gt;&lt;a href=&quot;#方法与消息&quot; class=&quot;headerlink&quot; title=&quot;方法与消息&quot;&gt;&lt;/a&gt;方法与消息&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SEL&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;又叫选择器，是表示一个方法的selector的指针，其定义如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;typedef struct objc_selector *SEL;&lt;/code&gt;&lt;br&gt;objc_selector结构体的详细定义没有在&amp;lt;objc/runtime.h&amp;gt;头文件中找到。方法的selector用于表示运行时方法的名字。Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IMP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过SEL找到函数后，就可以获取到该函数的IMP。IMP实际上是一个函数指针，指向方法实现的首地址。其定义如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;id (*IMP)(id, SEL, ...)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过取得IMP，我们可以跳过runtime的消息传递机制，直接通过IMP执行指向的函数实现。这样一来可以提高效率，省去了消息传递中的一系列过程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;回答上面的问题

我们知道，在同一个类文件里面，不能存在同一个名字的方法，即使是参数类型不同业不行。同理，同一个类文件里面不能存在同一个名字的对象，所以set方法是唯一的，所以可以使用SEL来获取唯一的整理标识来作为key。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##下面是看的一些文章的摘录和自己的一项心得，主要是给自己做一个备忘。&lt;/p&gt;
&lt;p&gt;选择器相关的操作函数包括：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回给定选择器指定的方法的名称
const char * sel_getName ( SEL sel );
// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器

SEL sel_registerName ( const char *str );



// 在Objective-C Runtime系统中注册一个方法

SEL sel_getUid ( const char *str );



// 比较两个选择器

BOOL sel_isEqual ( SEL lhs, SEL rhs );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法操作的函数如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 调用指定方法的实现
// receiver不能为空
// 比method_getImplementation和method_getName更快

id method_invoke ( id receiver, Method m, ... );



// 调用返回一个数据结构的方法的实现

void method_invoke_stret ( id receiver, Method m, ... );



// 获取方法名
// 返回一个SEL。如果要获取方法名得C字符串，要用sel_getName(method_getName(method))。

SEL method_getName ( Method m );



// 返回方法的实现
// 注意该函数返回值是方法之前的实现。
IMP method_getImplementation ( Method m );



// 获取描述方法参数和返回值类型的字符串

const char * method_getTypeEncoding ( Method m );



// 获取方法的返回值类型的字符串

char * method_copyReturnType ( Method m );



// 获取方法的指定位置参数的类型字符串

char * method_copyArgumentType ( Method m, unsigned int index );



// 通过引用返回方法的返回值类型字符串

void method_getReturnType ( Method m, char *dst, size_t dst_len );



// 返回方法的参数的个数

unsigned int method_getNumberOfArguments ( Method m );



// 通过引用返回方法指定位置参数的类型字符串

void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );



// 返回指定方法的方法描述结构体

struct objc_method_description * method_getDescription ( Method m );



// 设置方法的实现

IMP method_setImplementation ( Method m, IMP imp );



// 交换两个方法的实现

void method_exchangeImplementations ( Method m1, Method m2 );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##方法调用流程&lt;/p&gt;
&lt;p&gt;在Objective-C中，消息会一直到运行时绑定的方法实现上。我们常用的[receiver message]会被runtime转换为一个函数调用&lt;code&gt;objc_msgSend&lt;/code&gt;。如下&lt;/p&gt;
&lt;p&gt;&lt;code&gt;objc_msgSend(receiver, selector)&lt;/code&gt;&lt;br&gt;如果消息中还有其它参数，则该方法的形式如下所示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;objc_msgSend(receiver, selector, arg1, arg2, ...)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个函数在执行的过程中完成了所有动态绑定的过程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找到SEL对应的方法实现。由于一个方法可能在不同的类有不同的实现，所有我们要依赖于接受者的类来确定确切的实现。&lt;/li&gt;
&lt;li&gt;调用方法的实现，将参数传入。&lt;/li&gt;
&lt;li&gt;将方法的返回这作为的自己的返回值。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一个基本消息的框架&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14463917464901.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意到，在&lt;code&gt;objc_msgSend&lt;/code&gt;中有两个隐藏参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消息接受对象&lt;/li&gt;
&lt;li&gt;方法的selecor&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;隐藏是以为内在定义的方法中没有申明，是在编译期被插入实现代码的。&lt;/p&gt;
&lt;p&gt;##消息转发&lt;/p&gt;
&lt;p&gt;当一个对象能接受一个消息的时候，那么一切都会按照我们想得去做，但是如果不能接受消息的时候，会发生什么？一般情况下，如果不能相应[object message],编译期会报错。如果是以perform来调用的，那么在运行时才会确定object是否会接收消息，如果不行的话，就会造成程序崩溃。&lt;/p&gt;
&lt;p&gt;当然，我们可以通过&lt;code&gt;respondsToSelector:&lt;/code&gt;来判断一下是否会响应这个消息，但是我们要用runtime来搞一搞，所以我们应该从&lt;code&gt;消息转发机制&lt;/code&gt;来考虑。&lt;/p&gt;
&lt;p&gt;消息转发机制基本分为三个步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动态方法解析&lt;/li&gt;
&lt;li&gt;备用接收者&lt;/li&gt;
&lt;li&gt;完成转发&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;###动态方法解析&lt;/p&gt;
&lt;p&gt;当当对象接收到位置的消息时，首先会调用类的&lt;code&gt;+resolveInstanceMethod:(实例方法)&lt;/code&gt;或者&lt;code&gt;+resolveClassMethod:(类方法)&lt;/code&gt;。因此，我们可以去增加一个处理方法。在消息不能被对象接收的时候就运行这个方法，前提是这个方法已经被实现了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void functionForMethod1(id self, SEL _cmd) {

   NSLog(@&amp;quot;%@, %p&amp;quot;, self, _cmd);

}



+ (BOOL)resolveInstanceMethod:(SEL)sel {



    NSString *selectorString = NSStringFromSelector(sel);



    if ([selectorString isEqualToString:@&amp;quot;method1&amp;quot;]) {

        class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &amp;quot;@:&amp;quot;);

    }



    return [super resolveInstanceMethod:sel];

}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;备用接收者&quot;&gt;&lt;a href=&quot;#备用接收者&quot; class=&quot;headerlink&quot; title=&quot;备用接收者&quot;&gt;&lt;/a&gt;备用接收者&lt;/h3&gt;&lt;p&gt;当我们的对象不能处理消息的时候，我们将消息转发到一个备用的对象，只要这个对象的类实现了这个方法&lt;br&gt;&lt;code&gt;- (id)forwardingTargetForSelector:(SEL)aSelector&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果返回的不是一个nil的话，那么这个对象就会被作为消息的心的接收者。而在外部看来，这个消息仍然被我们的发送的对象处理了。注意，这个方法返回的对象不是self自身，不然就是个无限循环了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface SUTRuntimeMethodHelper : NSObject



- (void)method2;



@end



@implementation SUTRuntimeMethodHelper



- (void)method2 {

    NSLog(@&amp;quot;%@, %p&amp;quot;, self, _cmd);

}



@end



#pragma mark -



@interface SUTRuntimeMethod () {

    SUTRuntimeMethodHelper *_helper;

}



@end



@implementation SUTRuntimeMethod



+ (instancetype)object {

    return [[self alloc] init];

}



- (instancetype)init {

    self = [super init];

    if (self != nil) {

        _helper = [[SUTRuntimeMethodHelper alloc] init];

    }



    return self;

}



- (void)test {

    [self performSelector:@selector(method2)];

}



- (id)forwardingTargetForSelector:(SEL)aSelector {



    NSLog(@&amp;quot;forwardingTargetForSelector&amp;quot;);



    NSString *selectorString = NSStringFromSelector(aSelector);



    // 将消息转发给_helper来处理

    if ([selectorString isEqualToString:@&amp;quot;method2&amp;quot;]) {

        return _helper;

    }



    return [super forwardingTargetForSelector:aSelector];

}



@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###完成的消息转发&lt;/p&gt;
&lt;p&gt;如果上述的行为都不能解决的话，runtime在这时候会给对象最后一次机会：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)forwardInvocation:(NSInvocation *)anInvocation
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;这个时候，消息的所有未处理的内容都被封装到了anInvocation中，包括SEL,target，参数。我们在这里可以选着将消息转发给其他的对象。&lt;/p&gt;
&lt;p&gt;forwardInvocation:方法的实现有两个任务：&lt;/p&gt;
&lt;p&gt;定位可以响应封装在anInvocation中的消息的对象。这个对象不需要能处理所有未知消息。&lt;br&gt;使用anInvocation作为参数，将消息发送到选中的对象。anInvocation将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于这一块，还没有具体的实践，毕竟到这一步，用runtime来解决不如好好回去check以下代码吧。&lt;/p&gt;
&lt;p&gt;##Method Swizze&lt;/p&gt;
&lt;p&gt;Method Swizzling是改变一个selector的实际实现的技术.这样，我们可以在runtime的时候修改类分发的队形的函数，修改对应的实现。&lt;/p&gt;
&lt;p&gt;例如，我们想在每一个&lt;code&gt;viewDidAppear&lt;/code&gt;增加一个跟踪代码，观察哪个vc被调用了，那么我们就可以通过&lt;code&gt;Method Swizzling&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;###Swizzling 注意事项&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Swizzling应该总是在+load中执行&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证—事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。&lt;/p&gt;
&lt;p&gt;+load在父类，子类，分类的实现都会分别调用，所以+load更适合&lt;/p&gt;
&lt;p&gt;###Swizzling应该总是在dispatch_once中执行&lt;/p&gt;
&lt;p&gt;与上面相同，因为swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的dispatch_once可以确保这种行为，我们应该将其作为method swizzling的最佳实践。&lt;/p&gt;
&lt;p&gt;###特别的地方&lt;/p&gt;
&lt;p&gt;&amp;gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;总是调用方法的原始实现(除非有更好的理由不这么做)：API提供了一个输入与输出约定，但其内部实现是一个黑盒。Swizzle一个方法而不调用原始实现可能会打破私有状态底层操作，从而影响到程序的其它部分。&lt;/li&gt;
&lt;li&gt;避免冲突：给自定义的分类方法加前缀，从而使其与所依赖的代码库不会存在命名冲突。&lt;/li&gt;
&lt;li&gt;明白是怎么回事：简单地拷贝粘贴swizzle代码而不理解它是如何工作的，不仅危险，而且会浪费学习Objective-C运行时的机会。阅读Objective-C Runtime Reference和查看&amp;lt;objc/runtime.h&amp;gt;头文件以了解事件是如何发生的。&lt;/li&gt;
&lt;li&gt;小心操作：无论我们对Foundation, UIKit或其它内建框架执行Swizzle操作抱有多大信心，需要知道在下一版本中许多事可能会不一样。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##总结&lt;/p&gt;
&lt;p&gt;runtime到这里，大概讲了下两个问题，方法转发和关联对象。觉得还是不够，因为很多东西写起来发现自己也不是很了解，暂且做一个笔记。&lt;/p&gt;
&lt;p&gt;这里感谢南峰子，写得runtime教程非常详细，给了我很多帮助。&lt;/p&gt;
&lt;p&gt;本文参考了大量下面三篇文章的内容。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://southpeak.github.io/blog/2014/11/06/objective-c-runtime-yun-xing-shi-zhi-si-:method-swizzling/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://southpeak.github.io/blog/2014/11/03/objective-c-runtime-yun-xing-shi-zhi-san-:fang-fa-yu-xiao-xi-zhuan-fa/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://southpeak.github.io/blog/2014/10/30/objective-c-runtime-yun-xing-shi-zhi-er-:cheng-yuan-bian-liang-yu-shu-xing/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;从开始写博客的时候，就由一个准备把Runtime好好研究整理出来。后来发现写runtime得文章太多了，而且自己研究的也算不上有多么深入，写出来估计很多错误- —–（因为主要是给自己看得）。最近在项目中，第一次用到了runtime解决了一个实际问题，这启发我，我的文章应该从
    
    </summary>
    
      <category term="Objective-C" scheme="http://csbzhixing.github.io/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>list</title>
    <link href="http://csbzhixing.github.io/2015/10/25/list/"/>
    <id>http://csbzhixing.github.io/2015/10/25/list/</id>
    <published>2015-10-25T15:38:26.000Z</published>
    <updated>2015-10-27T16:42:39.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;开始内功！&quot;&gt;&lt;a href=&quot;#开始内功！&quot; class=&quot;headerlink&quot; title=&quot;开始内功！&quot;&gt;&lt;/a&gt;开始内功！&lt;/h1&gt;&lt;p&gt;前几日和前老大谈了谈，总结起来内功不能不练。实习以来有三次想好好复习数据结构和算法，但是最后都半途而废。现在不应该再有任何理由了，不然以后再也没有时间好好去复习这些东西。从现在开始刷好题目，打好基础。&lt;/p&gt;
&lt;p&gt;##链表&lt;/p&gt;
&lt;p&gt;链表是线性表的一种。&lt;/p&gt;
&lt;p&gt;线性表是最简单基础的一种数据结构。线性表中的数据元素之间的关系是一对一的，除了头元素和尾元素之外，其他元素首尾相连。线性表有两种存储方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;顺序存储方式&lt;/li&gt;
&lt;li&gt;链式存储方式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数组是典型的顺序存储方式。链表是典型的链式存储方式。&lt;/p&gt;
&lt;p&gt;链式存储结构，指的是相邻的两个元素在内存中可能不是相邻的，每一个元素都有一个指针域，指针域存放的是下一个元素的指针。&lt;/p&gt;
&lt;p&gt;链式结构的优缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;优点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;插入和删除的复杂度为O(1)&lt;/li&gt;
&lt;li&gt;不会浪费太多内存，在需要添加元素的时候才会申请内存，删除元素后释放内存。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;缺点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;访问元素的时间复杂度最坏为O(N)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;链表就是链式存储的线性表。根据指针域的不同，链表分为单项链表，双向链表，循环链表等等&lt;/p&gt;
&lt;p&gt;一个简单的List定义&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;struct list {
int ver;
struct list *next;
};
typedef struct list *listLink;
// 插入
void insert_list(listLink *, int);
// 打印
void print_list(listLink *, int);
// 链表长
int list_length(listLink);
// 搜索一个特定的值
listLink search_list(listLink, int);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;四个方法的实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14459585444278.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;##指针常出现的问题&lt;/p&gt;
&lt;p&gt;###反转链表&lt;/p&gt;
&lt;p&gt;反转链表，分为两种情况讨论，单向链表和双向链表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;单向链表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;考虑到访问某个节点的时候，要检查下一个节点是否为空。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;要把反转后的最后一个节点（头节点）的指针指向null&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现代码如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14459590472638.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双向链表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;双向链表比较麻烦的地方在于Next和pre要呼唤，需要主要当前节点和上个节点的问题。&lt;/p&gt;
&lt;p&gt;###删除节点&lt;/p&gt;
&lt;p&gt;删除节点必须要知道被删除节点的前置节点，时间复杂度为O(1)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14459596886157.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;###循环链表&lt;/p&gt;
&lt;p&gt;循环链表表现于尾元素的next指针指向head元素，所以我们可以通过快慢指针去校验。具体的方法会在下面的链表的技巧中提到.&lt;/p&gt;
&lt;h2 id=&quot;链表的技巧&quot;&gt;&lt;a href=&quot;#链表的技巧&quot; class=&quot;headerlink&quot; title=&quot;链表的技巧&quot;&gt;&lt;/a&gt;链表的技巧&lt;/h2&gt;&lt;p&gt;###鲁棒性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当访问链表中某个节点的next节点的时候，一点要先判断当前节点是否为空。&lt;/li&gt;
&lt;li&gt;全部操作结束后，判断是否有环。若有环，则置其中一端为Null;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Dummy-Node&quot;&gt;&lt;a href=&quot;#Dummy-Node&quot; class=&quot;headerlink&quot; title=&quot;Dummy Node&quot;&gt;&lt;/a&gt;Dummy Node&lt;/h3&gt;&lt;p&gt;假节点，伪头节点。Dummy &lt;code&gt;Node&lt;/code&gt; 可以认为是一个假的头结点。我们可以构造一个&lt;code&gt;Dummy Node&lt;/code&gt; ，使他的next指针指向Head node。使用&lt;code&gt;Dummy Node&lt;/code&gt;目的是，在单向链表中，保正head不会再删除操作中丢失。此外，比较特殊的方法是用来进行删除head。&lt;/p&gt;
&lt;p&gt;Dummy Node可以处理对于head Node变化的情况。&lt;/p&gt;
&lt;h2 id=&quot;快慢指针&quot;&gt;&lt;a href=&quot;#快慢指针&quot; class=&quot;headerlink&quot; title=&quot;快慢指针&quot;&gt;&lt;/a&gt;快慢指针&lt;/h2&gt;&lt;p&gt;快慢指针式解决很多链表的问题的关键。快慢指的是指针每次移动的步长。常用的快指针步长为2，慢指针步长为1.快慢指针同时从头结点开始移动陪你过。&lt;/p&gt;
&lt;p&gt;快慢指针的应用可以解决以下问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;快速找出为止长度的链表的中间节点。我们让快指针的步长是慢指针的两倍。当快指针到达尾节点的时候，慢指针所指向的节点就是中间节点。&lt;/li&gt;
&lt;li&gt;判断单向链表是否成环。同样的原理，如果快指针 &lt;code&gt;*fase =NULL&lt;/code&gt;的时候，说明链表是NULL结尾的。如果快指针等于慢指针的时候，则说明该链表成环。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;开始内功！&quot;&gt;&lt;a href=&quot;#开始内功！&quot; class=&quot;headerlink&quot; title=&quot;开始内功！&quot;&gt;&lt;/a&gt;开始内功！&lt;/h1&gt;&lt;p&gt;前几日和前老大谈了谈，总结起来内功不能不练。实习以来有三次想好好复习数据结构和算法，但是最后都半途而废。现在不应该再
    
    </summary>
    
      <category term="数据结构" scheme="http://csbzhixing.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>AFNetworking 学习笔记 1</title>
    <link href="http://csbzhixing.github.io/2015/10/23/afnetworking-1/"/>
    <id>http://csbzhixing.github.io/2015/10/23/afnetworking-1/</id>
    <published>2015-10-23T02:31:15.000Z</published>
    <updated>2015-10-23T02:37:00.000Z</updated>
    
    <content type="html">&lt;p&gt;##从3.0开始&lt;/p&gt;
&lt;p&gt;一转眼，AF已经更新到了3.0版本。目前cocoapods上的最新版本是3.0 beta1。在3.0的版本里面，AF全面地使用&lt;code&gt;NSURLSession&lt;/code&gt;代替了&lt;code&gt;NSURLConnection&lt;/code&gt;。之前花了一些时间学习&lt;code&gt;NSURLSession&lt;/code&gt;，在这里的学习终于派上了用场。在这里主要学习3.0版本的使用。希望在项目中能够顺利地过度到AFNetwoking 3.0版本。此外，随着Objective-c慢慢被Swift替代，AFNetworking 3.0可能是最后一个大版本更新。本文会一直随着AN的更新继续更新，也是一个不断学习的过程。&lt;/p&gt;
&lt;p&gt;##结构&lt;/p&gt;
&lt;p&gt;在3.0时代，AFN精简了结构，全面使用了&lt;code&gt;NSURLSession&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14451531667191.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;beta1里面只剩下了当前几个Manager。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AFHTTPSessionManager&lt;/code&gt;是&lt;code&gt;AFURLSessionManager&lt;/code&gt;的子类。&lt;/p&gt;
&lt;p&gt;##AFURLSessionManager&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AFURLSessionManager&lt;/code&gt;实现了以下几种&lt;code&gt;NSURLSession&lt;/code&gt;的代理方法&lt;/p&gt;
&lt;h4 id=&quot;NSURLSessionDelegate&quot;&gt;&lt;a href=&quot;#NSURLSessionDelegate&quot; class=&quot;headerlink&quot; title=&quot;NSURLSessionDelegate&quot;&gt;&lt;/a&gt;&lt;code&gt;NSURLSessionDelegate&lt;/code&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;URLSession:didBecomeInvalidWithError:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URLSession:didReceiveChallenge:completionHandler:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URLSessionDidFinishEventsForBackgroundURLSession:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;NSURLSessionTaskDelegate&quot;&gt;&lt;a href=&quot;#NSURLSessionTaskDelegate&quot; class=&quot;headerlink&quot; title=&quot;NSURLSessionTaskDelegate&quot;&gt;&lt;/a&gt;&lt;code&gt;NSURLSessionTaskDelegate&lt;/code&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;URLSession:willPerformHTTPRedirection:newRequest:completionHandler:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URLSession:task:didReceiveChallenge:completionHandler:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URLSession:task:didCompleteWithError:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;NSURLSessionDataDelegate&quot;&gt;&lt;a href=&quot;#NSURLSessionDataDelegate&quot; class=&quot;headerlink&quot; title=&quot;NSURLSessionDataDelegate&quot;&gt;&lt;/a&gt;&lt;code&gt;NSURLSessionDataDelegate&lt;/code&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;URLSession:dataTask:didReceiveResponse:completionHandler:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URLSession:dataTask:didBecomeDownloadTask:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URLSession:dataTask:didReceiveData:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URLSession:dataTask:willCacheResponse:completionHandler:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;NSURLSessionDownloadDelegate&quot;&gt;&lt;a href=&quot;#NSURLSessionDownloadDelegate&quot; class=&quot;headerlink&quot; title=&quot;NSURLSessionDownloadDelegate&quot;&gt;&lt;/a&gt;&lt;code&gt;NSURLSessionDownloadDelegate&lt;/code&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;URLSession:downloadTask:didFinishDownloadingToURL:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesWritten:totalBytesExpectedToWrite:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;###成员&lt;/p&gt;
&lt;p&gt;####属性&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;AFURLSessionManager&lt;/code&gt;中，主要的三个属性如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14451544109695.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;session&lt;/code&gt;实现了会话，&lt;code&gt;operationQueue&lt;/code&gt;是一个操作队列。&lt;code&gt;responseSerializer&lt;/code&gt;是实现了&lt;code&gt;AFURLResponseSerialization&lt;/code&gt;协议的一个对象。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Manager中还包括了安全协议的对象和连通性的对象。这两个类将在后面谈到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14451545558576.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下面是Task的内容，包含与当前&lt;code&gt;Session&lt;/code&gt;中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14451547233232.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;回调块队列，包括了在主队列和私有队列的两个部分&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14451548418504.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;####方法&lt;/p&gt;
&lt;p&gt; 初始化方法&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/media/14455211888103.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;创建一个&lt;code&gt;NSURLSessionDataTask&lt;/code&gt;数据性任务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455212385758.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;创建&lt;code&gt;`NSURLSessionUploadTask&lt;/code&gt; 上传任务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455213126912.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/media/14455213190110.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;创建&lt;code&gt;NSURLSessionDownloadTask&lt;/code&gt; 下载任务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455213738134.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/media/14455213826398.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;获得一个特定任务的&lt;code&gt;progress进度&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455214651069.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/media/14455214692883.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/media/14455214742512.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;Session Delegate Callbacks 设置会话代理回调&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455217046547.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/media/14455217113671.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Task Delegate Callbacks 设置任务代理回调&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当任务需要一个新的请求体发送给服务器的时候。&lt;br&gt;&lt;img src=&quot;/media/14455219470133.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当HTTP请求回调有重定向的的话设置这个Block&lt;br&gt;&lt;img src=&quot;/media/14455219533707.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当一个请求需要特别的鉴权的时候设置这个challenge&lt;br&gt;&lt;img src=&quot;/media/14455219599178.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设置一个block去追踪上传进度&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455658294340.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设置一个block当任务完成后执行&lt;br&gt;&lt;img src=&quot;/media/14455658635389.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;####&lt;code&gt;Setting Data Task Delegate Callbacks 设置数据任务代理的回调&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置一个在数据任务获得response的时候回调block&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455662011592.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设置一个block当数据任务变成下载的任务的时候执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455662317310.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设置一个block当数据任务获得到数据的时候&lt;br&gt;&lt;img src=&quot;/media/14455662434172.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设置一个block绝对是否缓存数据任务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455662958106.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;####&lt;code&gt;Download Task Delegate Callbacks 下载任务代理回调&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置block当下载任务完成下载后&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455666105437.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设置block去追踪下载任务进度情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455666301025.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设置block当下载任务执行/恢复的时候 执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455666958363.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;头文件的内容基本就是以上的了。可以看到整个AF的体系非常清晰完整，没有多余的东西，头文件只暴露了应该暴露的东西，值得我们去学习。&lt;/p&gt;
&lt;p&gt;##使用的例子&lt;/p&gt;
&lt;p&gt;###使用&lt;code&gt;AFURLSessionManager&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从源码中可以看到，&lt;code&gt;AFURLSessionManager&lt;/code&gt;实现了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Objective-c&quot;&gt;NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate, NSSecureCoding, NSCopying
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先需要设置url和NSURLConfirguration&lt;/p&gt;
&lt;p&gt;这里是使用百度API商店的公开API&lt;br&gt;&lt;img src=&quot;/media/14453928846040.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后初始化Manager&lt;img src=&quot;/media/14453929237373.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设置ResponseSerializer&lt;br&gt;&lt;img src=&quot;/media/14453931412125.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;初始化request&lt;br&gt;&lt;img src=&quot;/media/14453932169242.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;对request进行相关设置&lt;br&gt;&lt;img src=&quot;/media/14453932396509.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;根据request生成对应的&lt;code&gt;NSURLSessionTask&lt;/code&gt;。&lt;br&gt;&lt;img src=&quot;/media/14453935717679.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;执行任务&lt;br&gt;&lt;img src=&quot;/media/14453936154108.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;来看看执行后的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14453937344699.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里由于使用的&lt;code&gt;AFHTTPResponseSerializer&lt;/code&gt;(API的问题，仅仅支持text/plain)所以在获取的数据后，我们自己要json序列化。如果是设计好的API,直接使用&lt;code&gt;AFJSONRequestSerializer&lt;/code&gt;就可以在回调中获取到json格式的数据了。&lt;/p&gt;
&lt;p&gt;可以看到，整个使用还是很方便的。我们可以根据自己的需求配置不同设置。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##从3.0开始&lt;/p&gt;
&lt;p&gt;一转眼，AF已经更新到了3.0版本。目前cocoapods上的最新版本是3.0 beta1。在3.0的版本里面，AF全面地使用&lt;code&gt;NSURLSession&lt;/code&gt;代替了&lt;code&gt;NSURLConnection&lt;/code&gt;。之
    
    </summary>
    
      <category term="Network" scheme="http://csbzhixing.github.io/categories/Network/"/>
    
    
  </entry>
  
  <entry>
    <title>改变，一刻都不能停止</title>
    <link href="http://csbzhixing.github.io/2015/10/09/other/"/>
    <id>http://csbzhixing.github.io/2015/10/09/other/</id>
    <published>2015-10-09T05:36:46.000Z</published>
    <updated>2015-10-09T06:03:11.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;杂谈，生活，学习&quot;&gt;&lt;a href=&quot;#杂谈，生活，学习&quot; class=&quot;headerlink&quot; title=&quot;杂谈，生活，学习&quot;&gt;&lt;/a&gt;杂谈，生活，学习&lt;/h1&gt;&lt;p&gt;##从iTunes store说起&lt;/p&gt;
&lt;p&gt;9.30号凌晨，在我半睡半醒的时候，准备更新下一些APP。然后就发现了iTunes 提醒我要同意新的协议，当时很困就睡着了，没有想太多。早上起来，发现apple music可以用了！没错！免费三个月，续费十块钱一个月！然后看了下电影。一堆一块钱的正版电影你相信吗？？！。&lt;/p&gt;
&lt;p&gt;好吧，为何我那么激动吗，对于很多人是不理解的。相对于一些必须消费的商品。图书，音乐，电影，游戏，软件这些虚拟服务，在许多人眼里就是免费的午餐。从来没想到过我们为何要去为这些东西掏钱。所以，很多人并不看好苹果这次在大陆推行的这些服务。然而我认为，苹果这是以一己之力，将要改变中国人对版权的认识。为什么这么说？价格说明一切。&lt;/p&gt;
&lt;p&gt;如今，出去吃顿饭一个人动不动上百，一杯果汁奶茶都几十块钱的时代，却还在为一个优秀APP几十块钱而烦恼。入手新手机后，买了几款APP。其中有一个第三方微博客户端墨客。我家里很不理解为什么有微博客户端我还会去选择掏钱去买。我觉得，仅仅是干净舒适的UI设计就足够我花这个钱，而且再不用看到一大堆乱七八糟的推广，能够最快的看到自己需要的内容，这一切仅仅18块钱，难道不比买一包烟，喝一杯果汁来的值得吗？&lt;/p&gt;
&lt;h2 id=&quot;新的工作，一样的生活&quot;&gt;&lt;a href=&quot;#新的工作，一样的生活&quot; class=&quot;headerlink&quot; title=&quot;新的工作，一样的生活&quot;&gt;&lt;/a&gt;新的工作，一样的生活&lt;/h2&gt;&lt;p&gt;国庆第一天，把宿舍几乎所有的东西都带回家了。8号到了新公司报道。在国庆的时候，好好的回顾了下以前的堕落的生活，顺便整理了下自己的学习和工作上的问题。发现自己任然有许多地方的欠缺。牛逼的人，总是有强迫症的。而我，似乎不能称为牛逼的人，就是因为没有强迫症。面对代码，能Copy/Paste的话就做了，没有想到怎么去重构，去思考怎么做的更好。面对重复的东西，总是尽可能去避免。不愿意耐心的去解决的困难的问题，总是想依赖其他的人的经验来解决。不踏过千千万万个坑，怎么能说自己是个出色的工程师？总不能一辈子都在搬砖吧。养成强迫症，才不会总是固守原来的生活。&lt;/p&gt;
&lt;p&gt;##深度和广度&lt;/p&gt;
&lt;p&gt;在面试的时候，和这家公司的团队老大有一番交流让我感触很深。搞技术的，除了要有深度，还要有广度。对于广度和深度，之前也和某老大谈过。全栈好不好，这个话恐怕只有自己到了那个层次才能谈谈。毕竟现在，哪怕仅仅是一个方面，自己都很难保证能解决多数的问题。如今进入到了这个团队，感受到了身边的牛人还真的很多，许多都是多面手。看来不能仅仅把自己的困在一个方面。多学多用给你才是王道。后面打算整理下自己的技能树，然后根据轻重来设计自己的学习路线。&lt;/p&gt;
&lt;p&gt;##让思维和身体都跑起来吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14443703278870.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;坚持跑步已经有了两个月。虽然中间因为各种原因停顿了几次，这个月的跑量一直没上去。然而现在固定了下来，也要恢复到之前的运动模式。身体的运动，也改善了我思考的模式。不再会因为因为小小的事情而去分心。执行力也越来越好，也容易控制自己的情绪了。思维跟随的身体，一起奔跑的感觉，实在是太好不过了。&lt;/p&gt;
&lt;p&gt;最后一句话，送给自己。&lt;/p&gt;
&lt;p&gt;##一切不变的，就是改变&lt;/p&gt;
&lt;p&gt;˙&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;杂谈，生活，学习&quot;&gt;&lt;a href=&quot;#杂谈，生活，学习&quot; class=&quot;headerlink&quot; title=&quot;杂谈，生活，学习&quot;&gt;&lt;/a&gt;杂谈，生活，学习&lt;/h1&gt;&lt;p&gt;##从iTunes store说起&lt;/p&gt;
&lt;p&gt;9.30号凌晨，在我半睡半醒的时候，准备更
    
    </summary>
    
      <category term="personal" scheme="http://csbzhixing.github.io/categories/personal/"/>
    
    
  </entry>
  
  <entry>
    <title>个人知识管理</title>
    <link href="http://csbzhixing.github.io/2015/09/29/update-self/"/>
    <id>http://csbzhixing.github.io/2015/09/29/update-self/</id>
    <published>2015-09-29T06:27:00.000Z</published>
    <updated>2015-09-29T08:00:42.000Z</updated>
    
    <content type="html">&lt;p&gt;9月25号上周五收到了新的iphone6s plus。在折腾了几天后，整理了出自己的一套效率工作系统，目前看来效果良好，不知道未来使用几个月是否会给自己带来不一样的体验。&lt;/p&gt;
&lt;p&gt;下面是系统大纲&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14435106554403.jpg&quot; alt=&quot;大纲&quot;&gt;&lt;/p&gt;
&lt;p&gt;##效率工具&lt;/p&gt;
&lt;p&gt;好的计划是成功的一般。在之前由于国内安卓机无法使用谷歌服务，许多需要谷歌服务框架的软件都用不了，一直以来都没有建立一个体系工具。入手iPhone之后，借助于VPN，能够很好的结合谷歌服务和苹果云服务了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sunrise。我能找到免费的日历里面最好的。能够同步iCloud和谷歌日历。能够跨平台。界面也很美观。能够同步iCloud日历就不用手动在sunrise上面添加行程，只需要在mac或者iPhone上面添加提醒事项就可以了。&lt;/li&gt;
&lt;li&gt;Noti:Do 限免入手的。小而美的TODO软件。能够同步到系统的提醒事项。使用简单方便。&lt;/li&gt;
&lt;li&gt;apple的提醒事项。系统内置的软件，对比了几个大而全的第三方软件后，我发现提醒事项已经能够满足多数的需求了，能够iCloud同步，非常方便。&lt;/li&gt;
&lt;li&gt;SimpleNote。简单好用的第三方笔记软件。没有使用自带note是因为同步出现了一些问题。SimpleNote同步也很方便，能够在web上使用也使得在Windows上也能使用。将一些需要备忘的比如邮箱，账号放入非常好。同时在iPhone上支持使用Touch ID加密，感觉太棒了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##存储&lt;/p&gt;
&lt;p&gt;网盘的使用参考了许多，最终选择了国内的坚果云和国外的DropBox&lt;/p&gt;
&lt;p&gt;##邮件&lt;/p&gt;
&lt;p&gt;在大学的时候，并没有很注意使用邮件，所有要邮件订阅的地方都是一个QQ邮箱就搞定了。后来发现其实邮件用处实在是太大了。不仅可以订阅消息，注册，沟通，还可以做计划，安排，备份（网盘）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GMail。这估计是所有Geek的第一选择。唯一的缺点就是要翻墙。而且我发现GMail的SMTP的服务器在mac上特别不好连接。GMail的账号可以通行所有谷歌服务，而且可以很便捷地登陆国外的网站服务。&lt;/li&gt;
&lt;li&gt;QQ。综合来看，现在国内邮箱服务做的最好的就是QQ邮箱了。没什么太大的槽点，后缀稍微low点，但是可以改成foxmail。&lt;/li&gt;
&lt;li&gt;apple mail.app 。苹果自带的邮箱软件。在这上面找了几个免费的，感觉都不是很好。许多人也说其实自带的就已经能够满足需求了。嗯，还是原生的好。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##资讯&lt;/p&gt;
&lt;p&gt;网络时代是信息大爆炸的时代，怎么根据自己的需求去订制整理咨询是很重要的。在辗转了一大咨询类APP以后，发现要么太复杂要么内容单一。最后决定通过RSS订阅来自己调整信息源。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;微博客户端 Moke。收费的客户端，18元人民币，少数几个花钱的APP。没有广告真的很清爽，有许多手势但是还没有掌握好。&lt;/li&gt;
&lt;li&gt;Pocket。对于Pocket，我是作为文档存放整理的地方。好的文章先加入到Pocket中，然后根据内容分类，后面决定每周花时间整理一个分类。&lt;/li&gt;
&lt;li&gt;知乎。上了知乎身体一天不如一天了。。。开玩笑的。知乎还是有很多干货，需要自己去挖掘，但是随着用户群体的扩大，感觉回答的质量下降的很厉害，太多的耍机灵简直浪费我生命。。&lt;/li&gt;
&lt;li&gt;Feedly。RSS订阅软件。看中的就是他跨平台的能力。缺点是要翻墙。。。而且很多功能必须付费才开通（我想分享我的订阅都要付费。。。）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;写作&quot;&gt;&lt;a href=&quot;#写作&quot; class=&quot;headerlink&quot; title=&quot;写作&quot;&gt;&lt;/a&gt;写作&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;MWeb。又是一个付费应用，而且很不便宜。。9.9刀。但是我感觉物超所值。功能很强大的MarkDown写作软件。现在习惯了用MWeb觉得Word真的。。跟不上他的设计了。&lt;/li&gt;
&lt;li&gt;SimpleNote。一些简单的备忘，临时的灵感记录，上面已经讲过了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##为什么要建立个人知识管理系统&lt;/p&gt;
&lt;p&gt;在最近几个月的学习中，我发现自己接收了太多的信息而不能很好的吸收，时间安排也太随性浪费了很多时间。既然买了新手机，不能和一般人一样作为一个娱乐工具，也应该去帮助自己提高。所以在做了一番工作后，自己设计了这一个系统，可能不完善，很简单，但也是个开始。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;9月25号上周五收到了新的iphone6s plus。在折腾了几天后，整理了出自己的一套效率工作系统，目前看来效果良好，不知道未来使用几个月是否会给自己带来不一样的体验。&lt;/p&gt;
&lt;p&gt;下面是系统大纲&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/144351065544
    
    </summary>
    
      <category term="personal" scheme="http://csbzhixing.github.io/categories/personal/"/>
    
    
  </entry>
  
  <entry>
    <title>多线程开发详谈</title>
    <link href="http://csbzhixing.github.io/2015/09/25/thread/"/>
    <id>http://csbzhixing.github.io/2015/09/25/thread/</id>
    <published>2015-09-25T01:49:52.000Z</published>
    <updated>2015-10-23T02:36:56.000Z</updated>
    
    <content type="html">&lt;p&gt;按照计划，这篇文章主要谈iOS下的并发编程。&lt;/p&gt;
&lt;p&gt;之前的文章已经谈过了GCD的实现，包括苹果在GCD之上实现的NSOperation。但是在几次面试后发现，仅仅了解API还不够，要去深入的了解整个运行的机制。只有对整个系统有了更深刻的了解，才能不被API给限制住。&lt;/p&gt;
&lt;p&gt;##并发&lt;/p&gt;
&lt;p&gt;并发，概念就是同时运行多个任务。这些任务可以以分时的方式运行在单核CPU上面，也可以以真正的并发运行在多核CPU上面。&lt;/p&gt;
&lt;p&gt;实现并发，不仅可以最大化地利用硬件的性能，也可以提高程序的功能。&lt;/p&gt;
&lt;p&gt;###线程&lt;/p&gt;
&lt;p&gt;&lt;code&gt;线程(thread)&lt;/code&gt;是组成进程的子单元，操作系统可以对线程进行单独的调用。在苹果系统上的API都是以线程为单元进行调度的。&lt;/p&gt;
&lt;p&gt;多线程运行不仅能够在多核CPU上运行，也可以仅仅运行在单核CPU上。通过CPU分时，系统将极小的时间片分配给不同线程，让用户以为是多任务运行的。但是通过分时的效果不如多线程直接运行在多核CPU上。&lt;/p&gt;
&lt;p&gt;通过使用&lt;code&gt;Instruments&lt;/code&gt;中的&lt;code&gt;CPU strategy view&lt;/code&gt;可以观察代码如何在多核CPU运行的。&lt;/p&gt;
&lt;p&gt;##并发变成的API&lt;/p&gt;
&lt;p&gt;在之前的文章已经谈过了高层封装的两种，这里的重点不是如何使用API。&lt;/p&gt;
&lt;p&gt;在苹果的多线程中，有以下API供我们使用，从底层到高层一次如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;pthread&lt;/li&gt;
&lt;li&gt;NSThread, 苹果在pthread上的封装&lt;/li&gt;
&lt;li&gt;Grand Central Dispatch（GCD）&lt;/li&gt;
&lt;li&gt;Operation Queues&lt;/li&gt;
&lt;li&gt;Run Loops&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里想重点谈一下Run Loops。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Run Loops&lt;/code&gt;不同于&lt;code&gt;GCD&lt;/code&gt;或者&lt;code&gt;Operation Queues&lt;/code&gt;一样的并发机制，因为&lt;code&gt;Run Loops&lt;/code&gt;并不能并行执行任务。不过在主dispatch/operation中，Run Loops提供了一种异步执行代码的机制。通过Run Loops，我们不必担心并发中的各种陷阱，就能&lt;code&gt;异步&lt;/code&gt;执行任务。&lt;/p&gt;
&lt;p&gt;在主线程中，每一个 Cocoa 和 CocoaTouch 程序中，Main run loop都是扮演了最重要的角色。因为是run loop 来处理相关的内核事件的。&lt;/p&gt;
&lt;p&gt;线程和run loop是一一对应的。线程在创建的时候并没有run loop，如果不主动获取，那run loop就不会存在。Run Loop的创建在第一次获取的时候，销毁在线程结束的时候。除了主线程外，只能在一个线程的内部获取run loop。&lt;/p&gt;
&lt;p&gt;对于run loop的详细，又是一篇很长的文章来说了。这里就不详细说了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;按照计划，这篇文章主要谈iOS下的并发编程。&lt;/p&gt;
&lt;p&gt;之前的文章已经谈过了GCD的实现，包括苹果在GCD之上实现的NSOperation。但是在几次面试后发现，仅仅了解API还不够，要去深入的了解整个运行的机制。只有对整个系统有了更深刻的了解，才能不被API给限制住。
    
    </summary>
    
      <category term="base" scheme="http://csbzhixing.github.io/categories/base/"/>
    
    
  </entry>
  
  <entry>
    <title>json&amp;amp;xml</title>
    <link href="http://csbzhixing.github.io/2015/09/24/json-and-xml/"/>
    <id>http://csbzhixing.github.io/2015/09/24/json-and-xml/</id>
    <published>2015-09-24T08:44:36.000Z</published>
    <updated>2015-09-24T09:07:01.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;网络传输格式-JSON-amp-XML&quot;&gt;&lt;a href=&quot;#网络传输格式-JSON-amp-XML&quot; class=&quot;headerlink&quot; title=&quot;网络传输格式 JSON &amp;amp; XML&quot;&gt;&lt;/a&gt;网络传输格式 JSON &amp;amp; XML&lt;/h1&gt;&lt;p&gt;第一次接触这两个格式还是在学校做一个财务管理系统的时候。在之前变成都是纯粹的单机编程，不设计到网络数据传输的问题。到了这个项目才开始考虑如何在服务器和客户端之间传输数据。项目中使用的是JSON，所以在这里先讲JSON的部分。&lt;/p&gt;
&lt;p&gt;##JSON&lt;/p&gt;
&lt;p&gt;JSON是一种轻量化的数据格式。他的特点就是方便已用。目前90%的网络传输都是依赖于JSON格式。&lt;/p&gt;
&lt;p&gt;首先来看看JSON格式是怎么样的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;
&amp;quot;access_token&amp;quot;: &amp;quot;ACCESS_TOKEN&amp;quot;,

   &amp;quot;expires_in&amp;quot;: 1234,

   &amp;quot;remind_in&amp;quot;:&amp;quot;798114&amp;quot;,

   &amp;quot;uid&amp;quot;:&amp;quot;12341234&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是一个常见的JSON格式。比较容易的看出，其实就是一种key-value的形式。&lt;/p&gt;
&lt;p&gt;key我们都好了解，是一个string。那么value就会有不一样的值。通过对比OC的对象，我们可以更容易的理解JSON中的数据类型。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;            JSON                    OC

            {}                        NSDictionary

            []                        NSArray

            &amp;quot;&amp;quot;                        NSString

           数字                      NSNumber


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;知道了JSON所对应的OC对象，我们就可以通过解析JSON对象，将相关的数据转换成OC对象来存储。在这里，介绍一种能够在本地模拟API的方式，这也是由于自己找不到很好的开发API所以想在本地能够模拟API的方式。&lt;/p&gt;
&lt;p&gt;##JSON Server 模拟 API&lt;/p&gt;
&lt;p&gt;###第一步 安装&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装Homebrew。这个可是个神器，能够管理mac上的第三方的库的工具。据说被作者写不出反转二叉树个谷歌拒了然后去了苹果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装node.js&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;brew install node&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装json-server&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;npm install -g json-server&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;根据需求创建JSON&quot;&gt;&lt;a href=&quot;#根据需求创建JSON&quot; class=&quot;headerlink&quot; title=&quot;根据需求创建JSON&quot;&gt;&lt;/a&gt;根据需求创建JSON&lt;/h2&gt;&lt;p&gt;安装完毕后，随便找个你喜欢的文件夹，创建一个JSON格式的文件，如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;JSON&quot;&gt;{
  &amp;quot;posts&amp;quot;: [
    { &amp;quot;id&amp;quot;: 1, &amp;quot;title&amp;quot;: &amp;quot;json-server&amp;quot;, &amp;quot;author&amp;quot;: &amp;quot;typicode&amp;quot; }
  ],
  &amp;quot;comments&amp;quot;: [
    { &amp;quot;id&amp;quot;: 1, &amp;quot;body&amp;quot;: &amp;quot;some comment&amp;quot;, &amp;quot;postId&amp;quot;: 1 }
  ],
  &amp;quot;profile&amp;quot;: { &amp;quot;name&amp;quot;: &amp;quot;typicode&amp;quot; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后保存。&lt;/p&gt;
&lt;p&gt;###启动JSON-Server&lt;/p&gt;
&lt;p&gt;通过命令&lt;code&gt;json-server --watch JSON文件的名字.json&lt;/code&gt;来启动Server&lt;/p&gt;
&lt;p&gt;到这里，我们就相当于在本地创建了一个服务器能够相应我们想对应的请求。&lt;/p&gt;
&lt;p&gt;以上面的的JSON文件为例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430769630713.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当然，功能不止这么一点，JSON-Server还有更多方式，详见github&lt;a href=&quot;https://github.com/typicode/json-server&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;json-server&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;##OC对象和JSON对象的转换&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过&lt;code&gt;NSJSONSerialization&lt;/code&gt;来序列化JSON.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;![](/media/14430773793672.jpg)


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出的结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430774045308.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;对比上面的JSON数据，我们可以看出解析的结果是正确的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过第三方库JSONKit来解析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 下载地址 &lt;a href=&quot;https://github.com/johnezang/JSONKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JSONKit&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/media/14430745214364.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用Mantle&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在项目中用的最多的方法，也觉得非常好用&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://github.com/Mantle/Mantle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mantle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在本地创建对应的OC类&lt;br&gt;&lt;img src=&quot;/media/14430784491980.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;实现相关的方法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430794069120.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;第三种是直接将JSON通过一定的方法转成了OC的类对象。在使用的时候感觉更方便。&lt;/p&gt;
&lt;p&gt;##XML&lt;/p&gt;
&lt;p&gt;虽然JSON在网络传输中有90%的使用率，但是我们依然不能放弃10%的XML是吧。&lt;/p&gt;
&lt;p&gt;XML全称是Extensible Markup Language，译作“可扩展标记语言”&lt;br&gt;跟JSON一样，也是常用的一种用于交互的数据格式&lt;br&gt;一般也叫XML文档（XML Document）&lt;/p&gt;
&lt;p&gt;下面是一个典型的XML文件的结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;一个元素包括了开始标签和结束标签
拥有元素内容：&amp;lt;city&amp;gt;上海&amp;lt;/city&amp;gt;
没有元素内容：&amp;lt;city&amp;gt;&amp;lt;/city&amp;gt;
没有元素内容的简写：&amp;lt;city/&amp;gt; 

一个元素可以嵌套若干个子元素（不能出现交叉嵌套）
&amp;lt;citys&amp;gt;
    &amp;lt;city&amp;gt;
        &amp;lt;name&amp;gt;上海&amp;lt;/name&amp;gt;
        &amp;lt;weather&amp;gt;大暴雨&amp;lt;/weather&amp;gt;
          &amp;lt;air&amp;gt;舒适&amp;lt;/air&amp;gt;
    &amp;lt;/city&amp;gt;
&amp;lt;/citys&amp;gt;

规范的XML文档最多只有1个根元素，其他元素都是根元素的子孙元素
XML中的所有空格和换行，都会当做具体内容处理

一个元素可以拥有多个属性，属性值必须用 双引号&amp;quot;&amp;quot; 或者 单引号&amp;#39;&amp;#39; 括住。
&amp;lt;city name=&amp;quot;上海&amp;quot; weather=&amp;quot;大暴雨&amp;quot; air=&amp;quot;舒适&amp;quot; /&amp;gt;


属性表示的信息也可以用子元素来表示，比如

   &amp;lt;city&amp;gt;
        &amp;lt;weather&amp;gt;大暴雨&amp;lt;/weather&amp;gt;
          &amp;lt;air&amp;gt;舒适&amp;lt;/air&amp;gt;
    &amp;lt;/city&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解析XML有两种方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DOM解析：一次性将整个XML文档加载进内存，比较适合解析小文件&lt;/li&gt;
&lt;li&gt;SAX解析：从根元素开始，按顺序一个元素一个元素往下解析，比较适合解析大文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在iOS SDK里面，提供了两种解析的框架&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;NSXMLParser：它是基于objective-c语言的sax解析框架，是ios sdk默认的xml解析框架，不支持dom模式。&lt;/li&gt;
&lt;li&gt;libxml2: 它是基于c语言的xml解析器，被苹果整合在ios sdk中，支持sax和dom模式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同样，第三方也有许多解析XML的库。这里不打算讲第三方的，一个XML使用的比较少，一个使用SDK自身的效率往往已经非常好了。&lt;/p&gt;
&lt;p&gt;###NSXMLParser&lt;/p&gt;
&lt;p&gt;NSXMLParser属于SAX解析，是从上往下依次解析每个元素，在解析到每个元素的时候会通知代理，所以使用NSXMLParser必须遵守他的协议。&lt;br&gt;使用非常简单&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430815879826.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;从当前项目读取XML文件，读出数据，穿件解析器，设置代理，开始解析。&lt;/p&gt;
&lt;p&gt;XML文件内容如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430816475695.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;设置代理后，我们要实现代理方法，主要有以下方法，直接上图了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430816906329.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430817012681.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430833160910.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430833236999.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;###libxml2&lt;/p&gt;
&lt;p&gt;重点在于导入libxml2的库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430836046841.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430836140287.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430836178120.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430836230051.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430836285068.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;编译项目，通过了就没问题了。&lt;/p&gt;
&lt;p&gt;用法参见&lt;a href=&quot;https://github.com/neonichu/GDataXML&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;##总结&lt;/p&gt;
&lt;p&gt;在实际使用中，还JSON用的更多，所以对于JSON的解析过程要更加了解。对于XML，有一些公司任然会使用，而一些现存的数据也会用XML存储，所有也要有一定的了解。&lt;/p&gt;
&lt;p&gt;这篇文章讲解了在网络通信中数据的格式。下一篇的话就进入iOS内如何进行网络通信了。虽然使用AFNetWorking已经有段时间了，但是对内部整个机制并不了解，要好好补课了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;网络传输格式-JSON-amp-XML&quot;&gt;&lt;a href=&quot;#网络传输格式-JSON-amp-XML&quot; class=&quot;headerlink&quot; title=&quot;网络传输格式 JSON &amp;amp; XML&quot;&gt;&lt;/a&gt;网络传输格式 JSON &amp;amp; XML&lt;/h1&gt;&lt;
    
    </summary>
    
      <category term="Network" scheme="http://csbzhixing.github.io/categories/Network/"/>
    
    
  </entry>
  
  <entry>
    <title>重新认识ARC</title>
    <link href="http://csbzhixing.github.io/2015/09/22/arc/"/>
    <id>http://csbzhixing.github.io/2015/09/22/arc/</id>
    <published>2015-09-22T09:48:06.000Z</published>
    <updated>2015-09-24T09:04:36.000Z</updated>
    
    <content type="html">&lt;p&gt;第一次接触ARC还是在第一次拿到项目的时候。学习OC的时候使用的教材主要是通过MRC来讲解Retain Counting(引用计数)的。后面只是简单的了解了下ARC是编译器在编译的过程中自动去估算对象的生命周期来自动添加retain和realse的。解放了双手，也就没有什么动力去研究了。现在得空了，是时候增强自己的技能树。当前的目标如下&lt;/p&gt;
&lt;p&gt;&amp;lt;!--more--&amp;gt;  
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;增加网络编程的相关知识&lt;ul&gt;
&lt;li&gt;TCP/IP HTTP HTTPS 协议的学习和了解&lt;/li&gt;
&lt;li&gt;JSON和XML的解析&lt;/li&gt;
&lt;li&gt;iOS自身关于网络请求相关的类和API&lt;/li&gt;
&lt;li&gt;第三方库AFNetWorking源码阅读&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;增加iOS内核方面的知识&lt;ul&gt;
&lt;li&gt;内存基本知识和管理方式&lt;/li&gt;
&lt;li&gt;ARC&lt;/li&gt;
&lt;li&gt;进程线程&lt;/li&gt;
&lt;li&gt;RunTime&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单的看是两个大类七个点，但是感觉每一个点都非常多东西。目前暂时把1.1的点给补完了。不过任然需要投入大量的时间去复习。这里打算整合2.1和2.2。&lt;/p&gt;
&lt;p&gt;##内存管理&lt;br&gt;学过计算机基础的人对于内存都不陌生，哪怕是没有计算机基础的人也明白内存对于电脑（终端）的重要性。内存管理，就是在程序运行的过程中，申请，使用，释放内存的过程。程序写的好不好，就看你在完成功能的同时是不是使用了尽可能少的内存。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;堆和栈&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在内存中，有两个重要的概念，分别是&lt;code&gt;堆和栈&lt;/code&gt;。这里不仅仅指代他们的数据结构。我们知道，一个函数执行的时候，他会被压入栈中。栈中的内存单元保存了函数的返回地址，局部变量，传参等数据。当函数被弹出栈的时候，一切数据都会被销毁。而&lt;code&gt;堆&lt;/code&gt;上的数据是由开发者自行申请管理的，生命周期由开发者自行掌握。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;引用计数&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;学过OC的人都知道，在OC中管理内存的方法是&lt;code&gt;引用计数&lt;/code&gt;(Retain Counting)。通过对堆和栈的了解，我们可以得出OC上的对象&lt;em&gt;都是在堆上&lt;/em&gt;的。&lt;/p&gt;
&lt;p&gt;在苹果开发文档里面有一张图很好的说明的通过引用计数来管理对象生命周期的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14429735006902.jpg&quot; alt=&quot;引用计数&quot;&gt;&lt;/p&gt;
&lt;p&gt;同样，引用计数也遵循几大内存管理原则&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;谁申请谁拥有&lt;/li&gt;
&lt;li&gt;肯以申请拥有一个存在的对象&lt;/li&gt;
&lt;li&gt;当不需要的再拥有对象的时候，申请释放&lt;/li&gt;
&lt;li&gt;不能释放不属于自己没有拥有的对象&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##Automatic Reference Counting (ARC)&lt;/p&gt;
&lt;p&gt;在学习iOS开发半年后，ARC给我留下了很深的印象。ARC是苹果在引用计数的基础上改善了编译器实现的功能。要了解ARC，首先要看看在没有ARC之前开发者是怎么去通过引用计数管理的。&lt;/p&gt;
&lt;p&gt;在ARC之前，我们统称为&lt;code&gt;MRC（Manual Reference Counting&lt;/code&gt;，即手动引用技术。通过调用&lt;code&gt;retain&lt;/code&gt;和&lt;code&gt;release&lt;/code&gt;来管理对象的生命周期。有了ARC之后，在编译的过程中，编译器可以根据上下文估算对象的生命周期，以此来自动的添加&lt;code&gt;retain&lt;/code&gt;和&lt;code&gt;release&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;注意，ARC只对OC对象有作用，对于C的类型对象不则按照C的内存管理的方法去管理。&lt;/p&gt;
&lt;p&gt;如果在工程中开启了使用ARC，那么就要遵循ARC定义的一些规范&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不能显示的调用&lt;code&gt;dealloc&lt;/code&gt;,&lt;code&gt;ratain&lt;/code&gt;,&lt;code&gt;release&lt;/code&gt;,&lt;code&gt;retainCount&lt;/code&gt;,&lt;code&gt;autoRelease&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果要复写&lt;code&gt;dealloc&lt;/code&gt;方法，不需要显示调用&lt;code&gt;[super dealloc]&lt;/code&gt;方法。&lt;/li&gt;
&lt;li&gt;不能再使用&lt;code&gt;AutoReleasepool&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;ARC下的修饰符&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在@Property 中，有四种修饰符是ARC提供的，他们分别是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;strong&lt;/li&gt;
&lt;li&gt;weak&lt;/li&gt;
&lt;li&gt;unsafe_unretained&lt;/li&gt;
&lt;li&gt;__autoreleasing&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中，重点来谈谈strong和weak&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;strong。我们理解为强引用。当前的对象实际拥有这个对象。默认情况下ARC使用的strong来修饰。&lt;/li&gt;
&lt;li&gt;weak。相对于strong的强引用，weak指的是弱引用。当引用的对象被释放掉的时候，当前引用对象会被自动置nil。weak通常被用来解决循环引用的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;__autoreleasing&lt;/code&gt;和&lt;code&gt;__unsafe_unretained&lt;/code&gt;在实际应用中是很少的。&lt;code&gt;__unsafe_unretained&lt;/code&gt;是为了兼容iOS4之前的版本，现在基本上不会使用了，主要是为了实现weak的功能。&lt;code&gt;__autoreleasing&lt;/code&gt;是表示在autorelease pool中自动释放对象的引用。&lt;/p&gt;
&lt;h2 id=&quot;block-在ARC下&quot;&gt;&lt;a href=&quot;#block-在ARC下&quot; class=&quot;headerlink&quot; title=&quot;block 在ARC下&quot;&gt;&lt;/a&gt;block 在ARC下&lt;/h2&gt;&lt;p&gt;block在之前已经小小的讨论过了，出现的几个问题都有谈论到，这里主要从ARC的角度上再谈一谈。&lt;/p&gt;
&lt;p&gt;block在ARC下最特殊的地方就是怎么去解决循环引用。在block的篇章中没有很详细讨论，原因也是没从内存的角度来看。这里详细讲下循环引用产生原因和在ARC下解决循环引用的方法。&lt;/p&gt;
&lt;p&gt;&amp;gt;&lt;br&gt;You can use lifetime qualifiers to avoid strong reference cycles. For example, typically if you have a graph of objects arranged in a parent-child hierarchy and parents need to refer to their children and vice versa, then you make the parent-to-child relationship strong and the child-to-parent relationship weak. Other situations may be more subtle, particularly when they involve block objects.&lt;br&gt;&amp;gt;&lt;br&gt;In manual reference counting mode, &lt;strong&gt;block id x; has the effect of not retaining x. In ARC mode, &lt;/strong&gt;block id x; defaults to retaining x (just like all other values). To get the manual reference counting mode behavior under ARC, you could use &lt;strong&gt;unsafe_unretained &lt;/strong&gt;block id x;. As the name &lt;strong&gt;unsafe_unretained implies, however, having a non-retained variable is dangerous (because it can dangle) and is therefore discouraged. Two better options are to either use &lt;/strong&gt;weak (if you don’t need to support iOS 4 or OS X v10.6), or set the __block value to nil to break the retain cycle.&lt;br&gt;&amp;gt;&lt;br&gt;The following code fragment illustrates this issue using a pattern that is sometimes used in manual reference counting.&lt;/p&gt;
&lt;p&gt;上面是苹果官方文档对循环引用的解释。通过引用计数，我们了解到，如果有两个对象，对彼此都是强引用的话，双方都无法释放对方，也就无法释放delloc对象，最终就造成了死循环。在iOS5以下的版本里面，我们可以通过手动使用&lt;code&gt;unsafe_unretained&lt;/code&gt;来使其中一个变量变成野指针。而在ARC下，我们通过使用weak来修饰其中一个变量，这样在block中就不存在双方强引用的抢矿。&lt;/p&gt;
&lt;p&gt;但是，上面的处理方法有个问题。我们不知道weak修饰的对象什么时候会被释放掉了，有可能在执行block里面的对象在之前就已经被释放掉了。在AFNetWorking中，提供了一个非常好的解决思路&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14429947239639.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面方法中，在block外先将self用&lt;code&gt;weak&lt;/code&gt;引用一个weakSelf，进入block后再使用一个&lt;code&gt;_strong_typeof&lt;/code&gt;去创建一个strong引用对象。这样的做法既能避免产生循环引用，也能避免weak对象提前被释放掉。&lt;/p&gt;
&lt;p&gt;##ARC与Toll-Free Bridging&lt;/p&gt;
&lt;p&gt;Toll-Free Briding保证了在程序中，可以方便和谐的使用Core Foundation类型的对象和Objective-C类型的对象。但是，我们知道，到了ARC的时候，两者的内存管理方法不同了。对于一种对象，我们不能用该两种内存管理方法去管理。所以在进入ARC之后，Toll-Free Bridging也进行了相应的变化。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;__bridge&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;只是申明了类型转变，并没有改变内存管理方法。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;__bridge_retained（修饰符） or CFBridgingRetain（函数）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;表示将指针类型转变的同时，将内存管理的责任由原来的Objective-C交给Core Foundation来处理，也就是，将ARC转变为MRC。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;__bridge_transfer（修饰符） or CFBridgingRelease（函数）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这个修饰符和函数的功能和上面那个__bridge_retained相反，它表示将管理的责任由Core Foundation转交给Objective-C，即将管理方式由MRC转变为ARC。&lt;/p&gt;
&lt;p&gt;上面就是要谈的ARC的内容了。其实ARC的坑比起MRC已经少了很多了，对于我们可怜的程序员来说已经是很大的解放了。&lt;/p&gt;
&lt;p&gt;这里对于内存管理仅仅是基于OC简单的谈了谈，觉得还是不够深刻，主要是自己在这方面的知识的确很欠缺。读了&lt;br&gt;&lt;a href=&quot;http://casatwy.com/ccheng-xu-de-nei-cun-guan-li.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;C程序的内存管理&lt;/a&gt;这篇文章学到了很多，在这里也安利一下。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;第一次接触ARC还是在第一次拿到项目的时候。学习OC的时候使用的教材主要是通过MRC来讲解Retain Counting(引用计数)的。后面只是简单的了解了下ARC是编译器在编译的过程中自动去估算对象的生命周期来自动添加retain和realse的。解放了双手，也就没有什么
    
    </summary>
    
      <category term="Objective-C" scheme="http://csbzhixing.github.io/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>IP TCP HTTPs 随便谈</title>
    <link href="http://csbzhixing.github.io/2015/09/18/title/"/>
    <id>http://csbzhixing.github.io/2015/09/18/title/</id>
    <published>2015-09-18T08:48:55.000Z</published>
    <updated>2015-09-24T09:04:35.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;IP-TCP-HTTPs-随便谈&quot;&gt;&lt;a href=&quot;#IP-TCP-HTTPs-随便谈&quot; class=&quot;headerlink&quot; title=&quot;IP TCP HTTPs 随便谈&quot;&gt;&lt;/a&gt;IP TCP HTTPs 随便谈&lt;/h1&gt;&lt;p&gt;在总结自己的技能书的缺点后，决定优先补充自己在计算机网络上知识的漏洞。现在互联网企业，离开了互联网什么都不是。对互联网，普通人可能停留在概念和使用上，而开发人员应该去深入的了解运行进制，进而去优化自己开发的产品。这篇文章，主要是记录自己最近看的一些资料的笔记。&lt;br&gt;&amp;lt;!--more--&amp;gt;  &lt;/p&gt;
&lt;p&gt;##IP 协议&lt;/p&gt;
&lt;p&gt;IP协议，是网络协议（Internet Protocol）的缩写。IP协议是互联网众多协议的基础。&lt;/p&gt;
&lt;p&gt;IP协议实现了解&lt;code&gt;*分组交换网络*&lt;/code&gt;。在协议下，每个机器被称为&lt;code&gt;*主机*&lt;/code&gt;，IP协议明确了主机之间数据包的传输方式。&lt;/p&gt;
&lt;p&gt;数据包，也就是一段二进制数据，包含了传输源的主机的信息。IP协议的特点是&lt;code&gt;*尽力服务*&lt;/code&gt;（best effort），提供有效的服务并尽可能的传输。这说明，在传输过程中，可能会丢失数据包，也可能传输了多个相同的数据包。&lt;/p&gt;
&lt;p&gt;IP 网络中的主机都配有自己的地址，被称为&lt;code&gt;*IP 地址*&lt;/code&gt;。每个数据包中都包含了源主机和目标主机的 IP 地址。IP 协议负责路径计算，即 IP 数据包在网络中的传输传输时，数据包所经过的每一个主机节点都会读取数据包中的目标主机地址信息，以便选择朝什么地方传送数据包。&lt;/p&gt;
&lt;p&gt;##蛋疼的IPv4&lt;/p&gt;
&lt;p&gt;如今，多数数据包任然使用的是IPv4（版本4），每一个IP地址都是32位的。比如192.168.1.1就是一个IPV4地址。我们可以算下，IPv4有多少个地址。。嗯，好像很多有43亿吗。。但是呢，到了10年的时候，就已经不到8%的了。。&lt;/p&gt;
&lt;p&gt;人们发现IPV4不够用啊，快用完了啊，用完了就不能加主机了啊！！！那怎么办，启用新的协议版本啊，所以除了个IPv6，将地址扩充到128位了。比如&lt;code&gt;2001:0db8:85a3:0042:1000:8a2e:0370:7334&lt;/code&gt;&lt;br&gt;就是一个IPv6的地址了。&lt;/p&gt;
&lt;p&gt;128位就是2的128次方个，据说够地球上每个沙子配一个IP了。但是呢，这个协议转换的很慢，目前基本国内的都是还是使用IPv4协议。。看来也不是很着急么。。&lt;/p&gt;
&lt;p&gt;##IP数据包的结构&lt;br&gt;一个IP数据包通常包括一个数据头部（header）和有效数据（payload）。有效数据自然是数据包中要传送的数据。而数据头部就是包含了一些传输数据相关的数据。&lt;/p&gt;
&lt;p&gt;####我们先来看个IPv4的头部&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/Screen%20Shot%202015-09-20%20at%2020.15.59.png&quot; alt=&quot;Screen Shot 2015-09-20 at 20.15.59&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，头部信息包含了当前版本的信息，payload采用的协议。Total Length 表明是有效数据加上头部信息长度的总长度。&lt;/p&gt;
&lt;p&gt;####在来看看一个IPv6的报头信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14427519874258.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;IPv6的头部长度固定到了40.同时IPv6可以链接下一个头部信息（Next Header）。&lt;/p&gt;
&lt;p&gt;##数据传输&lt;/p&gt;
&lt;p&gt;我们知道，在数据链路层对对所传输的数据帧数有限制，&lt;code&gt;*（MTU，最大传输单元）*&lt;/code&gt;。在IPv4的上，使用&lt;code&gt;*分片*&lt;/code&gt;来对数据包进行处理。具体来说，我们可以认为如果数据超过了最大传输单元，那么就会将数据切成几片。当数据到达目标主机后，可以根据分片的信息进行重组。当然，发送源可以选择不进行对数据进行&lt;code&gt;*分片*&lt;/code&gt;。如果超过了链路层最大传输单元又不进行&lt;code&gt;*分片*&lt;/code&gt;的话，发送源就会收到ICMP（Internet Control Message Protocol，Internet报文控制协议）的数据帧超长报告信息。&lt;/p&gt;
&lt;p&gt;在IPv6中，如果数据包超过了长度限制，路由会直接丢弃数据包（好狠）并且向ICMP6报告数据帧过长。然后数据源和目标源会根据这个特性来进行&lt;code&gt;路由发现&lt;/code&gt;，就是寻找两端之间最大传输单元的路由。找到最大传输单元的路由后，仅当此时数据包任然超过最大传输单元的时候，IPv6才会进行分片。`对于IPv6下的TCP来说，不会造成什么影响。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;到此，IP协议就到了一个段落了。IP协议是TCP协议的基础，因此了解是必须的。&lt;/p&gt;
&lt;p&gt;##TCP协议&lt;/p&gt;
&lt;p&gt;TCP协议是重头戏。TCP协议是重头戏。TCP协议是重头戏。重要的事情要说三遍。&lt;/p&gt;
&lt;p&gt;上面说了，IP协议是基于&lt;code&gt;尽可能服务&lt;/code&gt;的，那么TCP协议就是要基于IP协议，解决IP协议采用的不可靠传输引起的复杂的问题。因此，下面的重点就是来谈谈TCP连接的三个部分：建立连接，传输数据，断开连接的详细过程&lt;/p&gt;
&lt;p&gt;####TCP建立连接&lt;/p&gt;
&lt;p&gt;首先，我们要知道TCP连接是全双工的,是建立在两个主机之间的。每个连接都存在两种角色：&lt;code&gt;服务器端，监听连接&lt;/code&gt;，&lt;code&gt;客户端，主动连接服务器端&lt;/code&gt;。客户端主动连接服务器端被称为&lt;code&gt;active open(主动打开)&lt;/code&gt;。而服务器端这种监听连接的行为被称为&lt;code&gt;passive open(被动打开)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三次握手&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCP建立连接是一个确认和反复确认的过程，我们习惯统称为三次握手。这个地方也是几乎所有面试会问的地方，需要注意了。&lt;/p&gt;
&lt;p&gt;三次连接，具体的过程有语言描述为以下的过程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;客服端向服务器端发送SYN包和一个随机序列号X，表示本次的连接的身份。&lt;/li&gt;
&lt;li&gt;服务器端收到客服端发送的连接的请求以后，发送一个SYN-ACK包和一个确认ack号X+1(确认序列号X的连接请求确认)。此时服务器还会发送一个随机序列号Y，表示向客户端连接的请求。&lt;/li&gt;
&lt;li&gt;客户端收到服务器的回复后，会发送一个ACK包，一个确认号Y+1和序列号X+1给服务器。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;SYN包，为&lt;code&gt;synchronize sequence numbers (同步序列号)&lt;/code&gt;。用于确认两段传输数据的身份，确保数据包最后都达到了应该到的地方。在建立连接的时候，源和目标都需要确认&lt;code&gt;同步序列号&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;ACK包，为&lt;code&gt;acknowledgment (确认)&lt;/code&gt;。某一端接到数据后，通过回传序列号来确认收到报文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14428004882999.jpg&quot; alt=&quot;三次握手&quot;&gt;&lt;/p&gt;
&lt;p&gt;####传输数据&lt;/p&gt;
&lt;p&gt;建立连接，就是为了传输数据。发送端发出的报文都会带有一个序列号，与当前已传送的字节总数有关。接受端会根据已经接收的报文给发送端传送确认报文，确认信息同样在头部的缩写带的ACK。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14427976037921.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意的整个过程是双向的。两端都会持续的发送数据。X端发送的数据不会等到Y端发送确认后才发送下一个报文。&lt;/p&gt;
&lt;p&gt;TCP协议是可靠的传输协议，所以有一系列复杂的机制来进行具体的的拥塞控制。需要处理的问题如下:&lt;code&gt;丢失报文重发&lt;/code&gt;，&lt;code&gt;动态调整发送报文的频率&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流量控制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;流量控制的原则就是发送数据的一方的速度不能比接受数据一方的速度要快。接收方，也就是&lt;code&gt;接收窗口&lt;/code&gt;会告诉发送方自身&lt;code&gt;接收窗口&lt;/code&gt;数据缓冲区的大小。在tcp包，通过两个两个关键的字段可以得出接收窗口的大小:&lt;code&gt;win -- 窗口大小&lt;/code&gt;和&lt;code&gt;wscale -- 窗口发大因子&lt;/code&gt; 。如果win=65535 , wscale = 4，那么我们可以计算出接收窗口的大小是 64kB * 4 = 256kB。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拥塞控制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拥塞控制相比于流量控制要复杂一些。拥塞控制就是根据当前网络情况计算出当前网络数据传输的最佳速度。首先我们要认识到，最佳速度不一定就是要最快。一方面，我们希望以更快的速度传输数据。另一方面，由于传输的速度过快，导致大量的数据传入会使处理性能受到影响。在分组交换网络中有一个特点就是&lt;code&gt;超负荷崩溃&lt;/code&gt;。当负载过大的时候，数据包之间会产生拥塞，直接导致丢包率上升。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;拥塞控制需要充分考虑对流量的影响。RFC 5681 中对 TCP 拥塞控制有 6,000 字左右的阐述。发送方要时刻关注来自接收方的确认信息。要做到这点并不简单，有的时候还需要一定的妥协。要知道底部 IP 协议数据包是无序传输的，数据包会丢失也会重复。发送方需要评估 RTT 往返时间，然后基于 RTT 去确定是否收到了接收方的确认信息。重发数据包也有很大代价，除了连接延迟问题，网络的负载也会发生明显的波动。导致 TCP 需要不停的去适应当前网络情况。&lt;/p&gt;
&lt;p&gt;更重要的是，TCP 连接本身是易变的。除了数据传输，连接的两端还会不时的发送一些提醒和确认信息以便可以适当的调整状态来维持连接。&lt;/p&gt;
&lt;p&gt;基于这种一直在相互协调中的连接关系，TCP 连接往往会是短暂而低效的。在建立连接的初期，TCP 协议算法还不能完全了解当前网络状况。而在连接将要结束的时候，反馈给发送方的信息又可能不充分，这样就很难对连接状况做出实时的合理的评估。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;四次挥手，断开连接&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;建立连接是通过&lt;code&gt;三次握手&lt;/code&gt;，而释放连接是通过&lt;code&gt;四次握手&lt;/code&gt;。在最下方有图示解释整个过程。那么为什么需要四次握手才能释放连接呢？&lt;/p&gt;
&lt;p&gt;上文提到了，TCP是全双工的，因此每个方向上的连接需要单独关闭。这个原则就是当一方没有数据可以传送的时候，发送FIN来终止这一方的连接，但是另一方向上的数据仍然可以发送。当另一方向也发送了FIN的时候，整个连接才完全的关闭了。无论服务器端还是客户端都可以发送来FIN来主动关闭连接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14428004433668.jpg&quot; alt=&quot;四次挥手&quot;&gt;&lt;/p&gt;
&lt;p&gt;##HTTPS&lt;/p&gt;
&lt;p&gt;之前的博文谈到了HTTP（超文本传输协议）。如今苹果操作系统iOS也升级到了iOS9。在iOS9中强制所有网络传输协议使用HTTPS。看来对HTTPS的了解是势在必行的了。&lt;/p&gt;
&lt;p&gt;HTTPS,实际上可以看作HTTP的加密版本。HTTPS将HTTP协议数据包放到SSL/TSL层加密后，在TCP/IP蹭去传输。到了目标源后，在SST/TSL将数据包解密，传递到HTTP层就是普通的HTTP数据包了。&lt;/p&gt;
&lt;p&gt;HTTPS = HTTP + SSL/TSL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SSL/TSL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于SSL/TSL，我们可以参考下面两篇文章：&lt;/p&gt;
&lt;p&gt;!&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;!&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单的来说，通过SSL/TSL四次握手，来解决下面三个问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数字证书：该证书包含了公钥等信息，一般是由服务器发给客户端，接收方通过验证这个证书是不是由信赖的CA签发，或者与本地的证书相对比，来判断证书是否可信；假如需要双向验证，则服务器和客户端都需要发送数字证书给对方验证；&lt;/li&gt;
&lt;li&gt;三个随机数：这三个随机数构成了后续通信过程中用来对数据进行对称加密解密的“对话密钥”。&lt;br&gt;首先客户端先发第一个随机数N1，然后服务器回了第    二个随机数N2（这个过程同时把之前提到的证书发给    客户端），这两个随机数都是明文的；而第三个随机    数N3（这个随机数被称为Premaster secret），    客户端用数字证书的公钥进行非对称加密，发给服务    器；而服务器用只有自己知道的私钥来解密，获取第    三个随机数。这样，服务端和客户端都有了三个随机    数N1+N2+N3，然后两端就使用这三个随机数来生    成“对话密钥”，在此之后的通信都是使用这个“对话    密钥”来进行对称加密解密。因为这个过程中，服务端    的私钥只用来解密第三个随机数，从来没有在网络中    传输过，这样的话，只要私钥没有被泄露，那么数据    就是安全的。&lt;/li&gt;
&lt;li&gt;加密通信协议：就是双方商量使用哪一种加密方式，假如两者支持的加密方式不匹配，则无法进行通信；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体的可以参考上面两篇文章的内容，去了解SSL/TSL加密的过程。在这里想重点说的是在iOS中使用HTTPS。&lt;/p&gt;
&lt;p&gt;在iOS中，常用的是&lt;code&gt;NSURLConnection&lt;/code&gt;支持HTTPS的实现。而常用的第三方库&lt;code&gt;AFNetworking&lt;/code&gt;封装了使用&lt;code&gt;NSURLConnection&lt;/code&gt;实现的逻辑代码，更加完善。在&lt;code&gt;AFNetworking&lt;/code&gt;中使用的方法如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Objective-C

NSURL * url = [NSURL URLWithString:@&amp;quot;https://www.google.com&amp;quot;];
AFHTTPRequestOperationManager * requestOperationManager = [[AFHTTPRequestOperationManager alloc] initWithBaseURL:url];
dispatch_queue_t requestQueue = dispatch_create_serial_queue_for_name(&amp;quot;kRequestCompletionQueue&amp;quot;);
requestOperationManager.completionQueue = requestQueue;

AFSecurityPolicy * securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];

//allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO
//如果是需要验证自建证书，需要设置为YES
securityPolicy.allowInvalidCertificates = YES;

//validatesDomainName 是否需要验证域名，默认为YES；
//假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。
//置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。
//如置为NO，建议自己添加对应域名的校验逻辑。
securityPolicy.validatesDomainName = YES;

//validatesCertificateChain 是否验证整个证书链，默认为YES
//设置为YES，会将服务器返回的Trust Object上的证书链与本地导入的证书进行对比，这就意味着，假如你的证书链是这样的：
//GeoTrust Global CA 
//    Google Internet Authority G2
//        *.google.com
//那么，除了导入*.google.com之外，还需要导入证书链上所有的CA证书（GeoTrust Global CA, Google Internet Authority G2）；
//如是自建证书的时候，可以设置为YES，增强安全性；假如是信任的CA所签发的证书，则建议关闭该验证，因为整个证书链一一比对是完全没有必要（请查看源代码）；
securityPolicy.validatesCertificateChain = NO;

requestOperationManager.securityPolicy = securityPolicy;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##杂谈&lt;/p&gt;
&lt;p&gt;关于连接。TCP连接容易在两个地方出问题：初始设置，以及通过连接传输最后一部分的内容。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;建立连接的时候，TCP由于要进行三次握手，所以在这过程中会有一定的时间损耗。一般一个移动终端向服务发送一个数据包普遍需要250ms, 三次握手的话就是需要750ms。而在HTTPS中则更加夸张。因为HTTPS需要四次握手。。。嗯，在TCP和HTTPS都握手完后，大概需要1750ms.是建立一个HTTP连接的两倍。为了安全，就肯定要牺牲时间效率。&lt;/p&gt;
&lt;p&gt;此外，由于TCP需要侦测当前最佳的转发路由，所以在传送大量的数据时，需要不停地去调整以便得到最佳速度。这种算法被称为&lt;code&gt;慢启动&lt;/code&gt;。注意到，慢启动在数据链路层传输质量差的网络上表现的更差，无线网络就是典型的例子。(4G说，怪我咯)。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;通过TCP释放连接的过程，我们也知道可能存在问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果发送方完成数据发送，接受方自然会停止发送 ACK 确认。在最后四个报文传输的过程中，快速重发算法是没有办法处理这四个报文的数据包的丢失问题的（因为不会收到三个相同的确认 ACK，所以不能界定传输丢包）。在常规网络环境下，四个数据包相当于 5.7kB 的数据规模。总之，在这最后 5.7kB 的传输的过程中，快速重发机制是无效的。针对这种情况，TCP 会启用其他机制来侦测丢包问题。对于这种情况，重传操作可能要消耗几秒钟去执行，这并不奇怪&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;超时处理&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在APP实际处理中，经常发生网络请求超时的现象。许多APP大概在15秒后收不到反馈就会提示超时信息。这种设计其实并不是很友好。我们知道，只有TCP连接还在，TCP都会保证将请求发送出去并会等待响应的返回，只是时间长短的问题。&lt;/p&gt;
&lt;p&gt;个人在这里参考了一些APP的做法，觉得应该在每次请求的时候设置一个计时器，当计时器到达倒数完成后，可以提示用户是否继续网络请求，如果取消就将TCP连接断开，如果继续就继续等待网络请求响应。&lt;/p&gt;
&lt;p&gt;##最后&lt;/p&gt;
&lt;p&gt;了解了IP TCP HTTPS后，接下来想阅读一些文章怎么从这些方面入手去优化网络请求。在互联网时代，数据和网络是承载产品的基础。因此，网络，怎么深入学习都不过分。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IP-TCP-HTTPs-随便谈&quot;&gt;&lt;a href=&quot;#IP-TCP-HTTPs-随便谈&quot; class=&quot;headerlink&quot; title=&quot;IP TCP HTTPs 随便谈&quot;&gt;&lt;/a&gt;IP TCP HTTPs 随便谈&lt;/h1&gt;&lt;p&gt;在总结自己的技能书的缺点后，
    
    </summary>
    
      <category term="Network" scheme="http://csbzhixing.github.io/categories/Network/"/>
    
    
  </entry>
  
  <entry>
    <title>面试小计 9.14</title>
    <link href="http://csbzhixing.github.io/2015/09/14/interview-9-dot-14/"/>
    <id>http://csbzhixing.github.io/2015/09/14/interview-9-dot-14/</id>
    <published>2015-09-14T15:22:57.000Z</published>
    <updated>2015-09-21T02:34:29.000Z</updated>
    
    <content type="html">&lt;p&gt;今天是人生第二次面试。约的公司十一点半。十一点就到了公司楼下。公司所在的地方到家里不远，曾经这里也是充满了许多童年的记忆。想不到过了十几年，自己也会来这里面试，也有可能在这里工作，想想一切都充满许多有趣的偶然。&lt;/p&gt;
&lt;p&gt;谈起面试，这只是第二次面试。第一次面试让我感觉非常不好，受到了不小的打击，然而不知道为何现在的公司会收留我做实习生（难道是我长的很适合程序员？）经过了半年的实习经历，踏过了许多以前完全想不到的坑，有了一定的收获，但是这次面试还是有些紧张。相比于第一次面试，我对自己的不足有了更多的认识，也就担心了更多，后面发现我担心是对的，但是担心的点完全不对。。&lt;/p&gt;
&lt;p&gt;上了楼，被HR妹子领到一个卡座等待面试。不得不说这个公司的环境要比我的现在的实习公司好了不是一个量级，连拿给我的矿泉水都很高级。。等了大概有五分钟到十分钟，来了个哥们，一看上去就是很厉害的程序员（的确我发现厉害的程序员在长相上都能体现出来）。先自我介绍了一下。由于HR那边只有拉勾网的简历，实在是太普通，所以我把自己带的简历从新给面试官看了下。面试官开始说他也不是负责iOS的（当时内心一惊，我其实很怂考算法和数据结构这种所谓的基础- -）&lt;/p&gt;
&lt;p&gt;然后开始聊了下自己现在在公司所做的项目。用电脑展示了一下，开始问第一个问题就是自己负责的了哪些功能，答UI和后台都有设计。然后问了一下一些UI设计的问题，接着就提出一个我刚好思考过的问题：UITableView在网络请求的时候加载图片如何保证流畅性。这个问题刚好周末也和同事讨论过问题，之前也有在网上查了一些不同人思考，就讲了下自己的见解，大概就是通过异步的方式，将UI刷新和图片读取放入不同的线程，通过判断滑动状态来决定是否更新UI。然后他提出我的解决方案中存在的一个问题：如果快速的滑动，只会显示一些预设的空白图片，这样不利于用户去搜索的一个固定的目标。这个问题我回答的时候缺乏了思考，我回答的是通过网络异步请求加载，在前几个屏的Cell延后显示，同时将图片下载预存，快速滑动的时候将新滑入屏幕的cell进行设置图片。后来想来其实有个更讨巧的方法，就是通过分页，控制一次刷新的cell的数量，就避免了用户快速滑动的情况出现。&lt;/p&gt;
&lt;p&gt;对于项目，由于面试官也不是做iOS开发的，所以就没设计到一些我准备很久的题目，随后他提出了在项目中是如何与后台联调的。这个问题的许多地方我只知道一些概念，所以理解上有点偏差，但是总体还是回答出来了。&lt;/p&gt;
&lt;p&gt;然后面试官随后话锋一转开始问HTTP协议。好险之前抽空整理了HTTP相关知识。HTTP协议必问状态码，在解释了状态码的分类和一些常见的状态码后，他问了我3XX状态码的问题。。怕什么来什么，虽然我记得3XX状态码的归类，但是具体到细节上还是有些遗忘（果真必须什么都要掌握啊）。回答稍微差了一点。&lt;/p&gt;
&lt;p&gt;随后面试官问了网络优化的问题。这个问题我感觉比较广泛，不是很好回答，面试官也说不仅限于服务器或者客户端。大概谈了一下自己在项目中的一点想法，特别是当网络服务不好的时候，如何去制造一些交互让用户减少对网络不良造成的影响产生不好反应的可能。然后面试官放了大招 – 请你谈谈网络安全问题。。。当时真的有点慌了，因为和自己准备的东西偏差有点大。随后就从自己的角度谈了下常规的网络攻击的问题。然后。。。然后问了我SQL注入。。这个我真的只是听说啊，臣妾做不到啊。。。&lt;/p&gt;
&lt;p&gt;后面还问了一些项目体会，一些经历。。还考了下指针环的判断和一个小球掉落的题目。。那个小球掉落的题目不知道答案应该是什么，感觉就是一个二分查找。。应该问下面试官他的答案的。&lt;/p&gt;
&lt;p&gt;到此，第一个面试官问完，走了出去，松了口气，缓一缓。。压力很大，因为和自己想的有点偏差，即使考数据结构和算法都没这样。。因为是没有心理准备。&lt;/p&gt;
&lt;p&gt;大概等了有十分钟。来了第二个面试官，上来换了个座位，然后开始让我简单的自我介绍。然后问了下在校成绩和在校所做的项目。。这时候我就有点忧伤了，因为在笑的项目最大的是就是学院的薪资管理系统，但是这个项目时间比较久了而且记忆的东西不多了（所以同学们一定要写自己有把握的项目啊）。然后出了个SQL题目让我写。。。比较没把握的写了，然后提出自己在项目中用的是Hibernate框架，在这个方向上可能不是很对。在之后就是聊天了，大概就是介绍公司的一些状况，一些学习的途径，还问我来深圳工作是否会错过学校的校招，不考研的原因是什么。在这些问题上我都有自己的想法也就简单说了下。最后问我了下现在公司的情况，薪资问题。。然后就问我有事很么了解的（这算过了还是没过。。）然后讨论了一些我在现在公司开发的遇到的坑。。感觉两个面试官能力都很强，思维能力的确看得出来的不一样。最后出来已经是12点15了。&lt;/p&gt;
&lt;p&gt;总结这次面试，作为一个应届生应该有更扎实的基础和全面的知识。自己近半年的精力都放在了iOS上，面对一些问题已经很生疏了，但是这不是抛弃其他知识的理由。第二个面试官也谈到了，广泛的涉猎，单一的深入，才能长久的在技术的路上走下去。最后还是希望进入这家公司，无论从环境上还是见到的人上都觉得非常不错。。当然希望自己的薪资也能高一点。&lt;/p&gt;
&lt;p&gt;进和没进，都会更新一下。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;最终担心了两天，还是过了！希望能够在新的团队里面学到更多的知识。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天是人生第二次面试。约的公司十一点半。十一点就到了公司楼下。公司所在的地方到家里不远，曾经这里也是充满了许多童年的记忆。想不到过了十几年，自己也会来这里面试，也有可能在这里工作，想想一切都充满许多有趣的偶然。&lt;/p&gt;
&lt;p&gt;谈起面试，这只是第二次面试。第一次面试让我感觉非
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>socket</title>
    <link href="http://csbzhixing.github.io/2015/09/13/socket/"/>
    <id>http://csbzhixing.github.io/2015/09/13/socket/</id>
    <published>2015-09-12T21:27:26.000Z</published>
    <updated>2015-09-24T09:05:45.000Z</updated>
    
    <content type="html">&lt;p&gt;##写在前面&lt;/p&gt;
&lt;p&gt;最近一直在找更好的实习，发现网络编程是一个优秀的程序员必备的技能。而自己在学校中学到的东西很少（逃。要不是有之前的实习和做个一个小小的项目，对于很多知识可能还只是停留在书本上（其实就是没进脑）。最近有人问我是否了解socket，我顿时语塞。对与socket的认识还是学习java的时候知道可以使用socket进行客户端与服务器端的通信，可是当时并没有去实践。欠下的债都是要还的。&lt;/p&gt;
&lt;p&gt;此外为什么我每篇博文的开头都写点自己的感受。我觉得博客不仅仅是记录自己的技术积累，也是抒发自己心情的一个途经，所以我会在每篇文章前面写一点点自己在写博文的时候的心情。&lt;br&gt;&amp;lt;!--more--&amp;gt;  &lt;/p&gt;
&lt;p&gt;##正文&lt;/p&gt;
&lt;p&gt;socket，套接字，是基于TCP/IP协议族下的一种网络通信方式。我们知道，在本地，进程之间有多种方法去通信。在网络中，我们同样可以使用socket进行通信。接下来一步步来看socket是如何使网络上的进程相互通信的。&lt;/p&gt;
&lt;p&gt;我们知道，要像让进程通信，首先必须确认进程的身份。如同我们只有知道了和自己谈话的是谁，我们才知道谈什么。在本地，进程拥有唯一的标识PID。在网络上，基于TCP/IP协议，通过&lt;em&gt;IP，协议，端口号&lt;/em&gt;，我们可以确认一个进程的唯一身份。&lt;/p&gt;
&lt;p&gt;使用TCP/IP协议的应用程序通常采用应用编程接口，有本文讲到的socket（套接字）和TIL（被淘汰了）。目前而言，绝多大数的应用程序都是基于socket进行网络通信的，所以了解socket是一个程序员必备的。&lt;/p&gt;
&lt;p&gt;##scocket 究竟是什么&lt;/p&gt;
&lt;p&gt;socket起源于UNIX。我们知道UNIX的设计原理就是&lt;em&gt;一切皆文件&lt;/em&gt;，操作都是&lt;em&gt;open -&amp;gt; read/write -&amp;gt; close&lt;/em&gt;。所以说，我们可以认为socket也是一个文件，是基于上述设计原理的实现。socket函数就是专门来完成相应操作的。&lt;/p&gt;
&lt;p&gt;##socket 操作&lt;/p&gt;
&lt;p&gt;在上面我们知道了socket是一个文件，那么socket自然有对应的操作方法，下面是基于TCP的几个基本操作。&lt;br&gt;(注，本文的方法是使用Objective-C写的，其实socket在任何语言都是差不多的)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objective-c&quot;&gt;
// 创建并初始化socket，返回socket的文件描述符，如果返回值为-1则创建失败
int socket(int addresFamily, int type, int protocol)

// 关闭socket
int close(int socketFileDescriptor)

// 将socket与特定的IP地址和端口号绑定，成功返回0，失败返回-1
int bind(int socketFileDescriptor, sockadd *addressToBind)

// 接受客户端的请求并且将客户端的网络地址信息存入clientAddress
// 当客户端的连接请求被接受后，双方的通信链路就建立好了，两者就可以开始通信了。

int accept(int socketFileDescriptor, sockaddr *clientAddress, int clientAddressStructLength)

// 客户端向特定的IP的服务器发送连接请求，成功返回0，失败返回-1
// 当服务器建立好后，客户端就可以通过这个函数与服务器端建立连接。
// 对于UDP来说，该接口是可选的，如果调用了这个接口表明设置了UDP socket默认的网络地址.
// 对于TCP来说，这里就是三次握手发生的地方

int connect(int socketFileDescriptor, sockaddr *serverAddress, int serverAddressLength)

// 通过DNS查找特定的IP，如果找不到返回NULL
hostent *gethostbyname(char *hostname)

// 发送数据，发送成功后返回成功发送的字节数，否则返回-1
int send(int socketFileDescriptor,char *buffer, int flags)

// 接收数据，成功后返回成功读取的字节数，否则返回-1
int receive(int socketFileDesciptor,char *buffer,int flags)

// 下面两个方法是UDP的方法

// UDP发送,返回状态同上
int sendto(int socketFileDesciptor, char *buffer, int bufferLength, int flags, sockaddr *destinationAddress, int destinationAddressLength)

// UDP读取，返回状态同上
int recvfrom(int socketFileDesciptor, char *buffer, int bufferLength, int flags, sockaddr *fromAddress, int fromAddressLength)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过观察方法，我们发现socket其实就是&lt;em&gt;确认目标 -&amp;gt;建立连接 -&amp;gt; 传送/读取 -&amp;gt; 断开&lt;/em&gt; 的过程&lt;/p&gt;
&lt;p&gt;我们再来看看TCP和UDP下socket操作的不同的地方&lt;/p&gt;
&lt;p&gt;####TCP&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.coderyi.com//qiniu/429/image/5269612b25e6df1b3ee5ab8352b2c3b6.jpg&quot; alt=&quot;TCP&quot;&gt;&lt;/p&gt;
&lt;p&gt;####UDP&lt;br&gt;&lt;img src=&quot;http://www.coderyi.com//qiniu/429/image/cd6d1690d3d6eefd300987e590c1483f.jpg&quot; alt=&quot;UDP&quot;&gt;&lt;/p&gt;
&lt;p&gt;##最后&lt;/p&gt;
&lt;p&gt;到此，对于socket编程的概念有了个一个初步的认识了。在实际开发中，我们一般不会直接调用这些底层的API。借助于一些开源的第三方库更有利于项目的开发运行。不过，对于基本的理论知识还是必须要掌握的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##写在前面&lt;/p&gt;
&lt;p&gt;最近一直在找更好的实习，发现网络编程是一个优秀的程序员必备的技能。而自己在学校中学到的东西很少（逃。要不是有之前的实习和做个一个小小的项目，对于很多知识可能还只是停留在书本上（其实就是没进脑）。最近有人问我是否了解socket，我顿时语塞。对与s
    
    </summary>
    
      <category term="Network" scheme="http://csbzhixing.github.io/categories/Network/"/>
    
    
  </entry>
  
  <entry>
    <title>GCD小结</title>
    <link href="http://csbzhixing.github.io/2015/09/12/gcd/"/>
    <id>http://csbzhixing.github.io/2015/09/12/gcd/</id>
    <published>2015-09-12T13:16:43.000Z</published>
    <updated>2015-09-24T09:05:48.000Z</updated>
    
    <content type="html">&lt;p&gt;#写在最前面&lt;/p&gt;
&lt;p&gt;最近发现自己学东西的效率好像高了，难道是因为写博客做笔记的原因吗？的确通过写博客来记录自己学习的成果能够加强自己对很多问题的理解。只有能够通过自己的语言将学习到的内容讲出来才是真的理解。所以以后看来要多写写。&lt;br&gt;&amp;lt;!--more--&amp;gt;  &lt;/p&gt;
&lt;p&gt;#正文&lt;/p&gt;
&lt;p&gt;##GCD是什么鬼&lt;/p&gt;
&lt;p&gt;GCD，简单的来说就是苹果自己出的一套多核运算的解决方案。虽然苹果没有安卓那么多核心，但是并行化运算能够提高流程性是不可争辩的事实。GCD内部自动管理线程 的生命周期，不需要我们自己去手动管理。我们只需要调用对应的API就可以了。GCD是基于C语言开发的，不过由于使用了block，所以使用起来很方便。在了解GCD之前，我们需要了解一点多线程运行的原理。&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;GCD中有两个重要的概念：&lt;em&gt;任务&lt;/em&gt; 和 &lt;em&gt;队列&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;任务。我们可以理解任务就是一个动作，放在GCD中就是一个代码块（block）。执行任务有两种，分别为&lt;em&gt;同步执行&lt;/em&gt; 和 &lt;em&gt;异步执行&lt;/em&gt;。同步和异步的区别其实很好理解。&lt;code&gt;同步执行&lt;/code&gt;既是当前任务执行完前会阻塞当前进程，&lt;code&gt;而异步执行&lt;/code&gt;就不会。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;队列。队列是用来存放任务的。我们可以理解为任务就是队列中排队等待执行。队列分为&lt;em&gt;串行队列&lt;/em&gt;和&lt;em&gt;并行队列&lt;/em&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;串行队列，就像排队一样，严格遵守FIFO。&lt;/li&gt;
&lt;li&gt;并行队列，同样执行FIFO。不同的是，取出来的任务会根据情况放到别的线程上。由于多个线程出队的时间间隔可能很短，所以容易认为是非FIFO的。不过即使这样，系统也会根据硬件条件来判断，并不一定会所有任务都在同时执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;创建队列的操作如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i3.tietuku.com/045e13ec06064ef3.png&quot; alt=&quot;queue&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;创建任务如下如图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i3.tietuku.com/b2ef139ced93771f.png&quot; alt=&quot;task&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;队列组&quot;&gt;&lt;a href=&quot;#队列组&quot; class=&quot;headerlink&quot; title=&quot;队列组&quot;&gt;&lt;/a&gt;队列组&lt;/h4&gt;&lt;p&gt;  对列组就是将多个队列添加到一个组里。这样的方式使我们可以在队列里所有的任务都完成后收到一个通知方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  objective-c

  // 创建队列组
    dispatch_group_t group = dispatch_group_create();

    dispatch_group_async(group, globalQueue, ^{
      for (NSInteger i = 0; i &amp;lt; 3; i++)
      {
          NSLog(@&amp;quot;group - queue - %@&amp;quot;, [NSThread currentThread]);
      }
    });
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;NSOperation-和-NSOperationQueue&quot;&gt;&lt;a href=&quot;#NSOperation-和-NSOperationQueue&quot; class=&quot;headerlink&quot; title=&quot;NSOperation 和 NSOperationQueue&quot;&gt;&lt;/a&gt;NSOperation 和 NSOperationQueue&lt;/h2&gt;&lt;p&gt;  NSOperation 和 NSOperationQueue是苹果对GCD的基于面向对象的完全封装，使其更容易理解。操作方式也更简单&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将要执行的任务封装到一个&lt;code&gt;NSOperation&lt;/code&gt;对象中&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将任务添加到一个&lt;code&gt;NSOperationQueue&lt;/code&gt;中&lt;/p&gt;
&lt;p&gt;此后系统将自动在执行任务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;添加任务&quot;&gt;&lt;a href=&quot;#添加任务&quot; class=&quot;headerlink&quot; title=&quot;添加任务&quot;&gt;&lt;/a&gt;添加任务&lt;/h3&gt;&lt;p&gt; 由于NSOperation是一个抽象类，所以不能直接封装任务。但是有两个子类用于封装任务：&lt;code&gt;NSInvocationOperation&lt;/code&gt; 和 &lt;code&gt;NSBlockOperation&lt;/code&gt;。创建一个队列后，需要调动&lt;code&gt;start()&lt;/code&gt;方法来启动，&lt;em&gt;默认在当前队列同步执行&lt;/em&gt;。同时队列提供&lt;code&gt;cancel()&lt;/code&gt;方法在中途取消任务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSInvocationOperation 传入一个方法名。&lt;/li&gt;
&lt;li&gt;NSBlockOperation 传入一个代码块。&lt;ul&gt;
&lt;li&gt;在NSBlockOperation中，有一个方法&lt;code&gt;addExecutionBlock&lt;/code&gt;方法。这个方法使我们可以添加多个block到队列中。&lt;em&gt;这些block将会并发执行**，将在&lt;/em&gt;主线程和其他的多个线程``执行任务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;###添加队列&lt;/p&gt;
&lt;p&gt;   多数时候，我们不希望当前线程被占用，因为会影响到UI的流畅性（UI永远在主线程上）。因此我们需要创建新的队列。只要我们添加任务到队列上，就会自动调用任务的&lt;code&gt;start()&lt;/code&gt;方法。如果任务在其他队列上，那么他就会在其他线程上并行执行。&lt;/p&gt;
&lt;p&gt;   我们发现，&lt;code&gt;NSOperationQueue&lt;/code&gt;并没有设置串行和并行队列的问题，那么&lt;code&gt;NSOperationQueue&lt;/code&gt;是怎么确定队列的类型的呢。苹果通过封装巧妙的使调用者不需要特意的去注意队列的性质，只需要设置&lt;code&gt;NSOperationQueue&lt;/code&gt;中的&lt;code&gt;maxConcurrentOperationCount&lt;/code&gt; – 最大并发数就可以了。&lt;/p&gt;
&lt;p&gt;##总结&lt;/p&gt;
&lt;p&gt;   在上篇block的文章中也谈到了block在gcd的中的应用。通过gcd，我们可以最大化的去使用硬件的性能，避免出现卡顿的现象。多线程用的好不好，也基本上代表了一个开发者的能力水平。虽然多线程编程有许多坑，但只有跨过一个个坑，才能变成大牛，不是吗？&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;#写在最前面&lt;/p&gt;
&lt;p&gt;最近发现自己学东西的效率好像高了，难道是因为写博客做笔记的原因吗？的确通过写博客来记录自己学习的成果能够加强自己对很多问题的理解。只有能够通过自己的语言将学习到的内容讲出来才是真的理解。所以以后看来要多写写。&lt;br&gt;&amp;lt;!--more--&amp;g
    
    </summary>
    
      <category term="Objective-C" scheme="http://csbzhixing.github.io/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP学习</title>
    <link href="http://csbzhixing.github.io/2015/09/10/http/"/>
    <id>http://csbzhixing.github.io/2015/09/10/http/</id>
    <published>2015-09-10T15:46:08.000Z</published>
    <updated>2015-09-24T09:05:52.000Z</updated>
    
    <content type="html">&lt;p&gt;#HTTP学习&lt;/p&gt;
&lt;p&gt;HTTP协议是网络中最广泛的协议之一，对HTTP协议的了解应该是每一个和网络打交道的程序员必须具备的技能。很多公司面试都要求对网络知识有一定的了解，一个是TCP/IP协议，一个就是HTTP协议，HTTP协议应用层的协议，内容比较少，这周花时间去总结了一下，做一个备忘。&lt;br&gt;&amp;lt;!--more--&amp;gt;  &lt;/p&gt;
&lt;p&gt;##HTTP简单分析&lt;/p&gt;
&lt;p&gt;HTTP是一个基于请求/响应模式的、无状态的协议。即，浏览器与服务端连接之后，浏览器向服务器发送一个请求，服务器返回响应信息之后，双方的链接就被关闭。&lt;/p&gt;
&lt;p&gt;HTTP1.0是典型的请求/响应模式。&lt;/p&gt;
&lt;p&gt;HTTP1.1在1.0的基础上进行了改进，加入了“持续连接”的机制。通过这种机制，客户端发送请求得到响应后，连接不会马上关闭，可以继续发送请求，还可以流水线发送多个请求、而不用等待每一个响应的到来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;URI和URL&lt;ul&gt;
&lt;li&gt;URL我们应该是很熟悉的了，全名是统一资源定位符，包含了需要查找的信息的资源。&lt;/li&gt;
&lt;li&gt;而URI是URL的父集，纯粹是一个WEB的资源符号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;HTTP请求&quot;&gt;&lt;a href=&quot;#HTTP请求&quot; class=&quot;headerlink&quot; title=&quot;HTTP请求&quot;&gt;&lt;/a&gt;HTTP请求&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://i3.tietuku.com/2c834f74cd465d7e.png&quot; alt=&quot;HTTP Request&quot;&gt;&lt;/p&gt;
&lt;p&gt;简单的来说 HTTP请求可以分为三部分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;请求行&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;消息报头&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;请求正文&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;###请求行&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;请求行主要的内容是是请求方法和请求的位置（URL）&lt;/p&gt;
&lt;p&gt;请求方法主要有以下几种方法（注意方法都是全部字母大写）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i3.tietuku.com/05fa7108f6959f91.png&quot; alt=&quot;HTTP Request method&quot;&gt;&lt;/p&gt;
&lt;p&gt;在APP中，最多用的到的就是POST 和 GET 两种方法。许多地方都要求区别两者的区别，所以在这里做一下重点笔记对比两者方法的不同&lt;/p&gt;
&lt;p&gt;（在这里小小的吐槽，在学校计算机网络的学习中，POST和GET的区别基本就是一句话：POST比GET更好更安全。其实在查阅了许多资料后，发现并没有那么简单）&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;####POST&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据HTTP规范，POST表示可能修改服务器上的资源的请求，比如提交表格，注册等等都是常用POST&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;POST将请求的正文包在HTTP包体中&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;POST没有大小限制&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;####GET&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;GET操作，根据HTTP规范，仅仅用于信息获取，而且是应该是安全的幂等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GET操作会将请求的数据附在URL后面，参数之间以&amp;amp;相连（这就是为什么很多人认为GET不安全了）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;GET的数据限制，由于浏览器或者服务器可能会对URL存在长度限制，所以有可能会产生影响&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过对比，我们发现常见的误区有两个&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;POST比GET更安全。通过上面对比，我们发现，虽然POST没有将参数直接放在URL中，但是通过抓包的手段，我们依然可以获得HTTP包体中的参数。由此看来，想依靠POST就简单保证安全是不可能的。&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;POST能比GET传输更多。通过上面的叙述也可以得知，其实HTTP协议本身没有进行限制，POST和GET都没有大小限制，而是第三方的浏览器和服务器造成了差别&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;什么时候用POST，什么时候用GET，我们要依据不同的使用场景来区分。如果有缓存的需求，那自然就不能用POST方法。如果必须要用表格，GET也不行了。&lt;/p&gt;
&lt;h2 id=&quot;HTTP响应&quot;&gt;&lt;a href=&quot;#HTTP响应&quot; class=&quot;headerlink&quot; title=&quot;HTTP响应&quot;&gt;&lt;/a&gt;HTTP响应&lt;/h2&gt;&lt;p&gt;请求响应类似与请求。如图所示&lt;/p&gt;
&lt;p&gt;可以看到，HTTP响应的第一行叫状态行，包含了HTTP版本，状态码，状态描述信息。&lt;/p&gt;
&lt;p&gt;状态码是判断请求状态的重要标志，由三位数字组成，有五种定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1XX —- 请示信息，表示请求已经接受，可以继续处理&lt;/li&gt;
&lt;li&gt;2XX —- 成功状态，表示请求被服务器接受&lt;/li&gt;
&lt;li&gt;3XX —- 重定向，要完成请求的话需要更进一步的操作&lt;/li&gt;
&lt;li&gt;4XX —- 客户端错误，请求错误或者请求无法被实现&lt;/li&gt;
&lt;li&gt;5XX —- 服务器端错误，服务器未能完成合法的请求&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;全部取值如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;    100——客户必须继续发出请求
   101——客户要求服务器根据请求转换HTTP协议版本


     200——交易成功
    201——提示知道新文件的URL
    202——接受和处理、但处理未完成
    203——返回信息不确定或不完整
    204——请求收到，但返回信息为空
    205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
    206——服务器已经完成了部分用户的GET请求

      300——请求的资源可在多处得到
    301——删除请求数据
    302——在其他地址发现了请求数据
    303——建议客户访问其他URL或访问方式
    304——客户端已经执行了GET，但文件未变化
    305——请求的资源必须从服务器指定的地址得到
    306——前一版本HTTP中使用的代码，现行版本中不再使用
    307——申明请求的资源临时性删除

     400——错误请求，如语法错误
    401——请求授权失败
    402——保留有效ChargeTo头响应
    403——请求不允许
    404——没有发现文件、查询或URl
    405——用户在Request-Line字段定义的方法不允许
    406——根据用户发送的Accept拖，请求资源不可访问
    407——类似401，用户必须首先在代理服务器上得到授权
    408——客户端没有在用户指定的饿时间内完成请求
    409——对当前资源状态，请求不能完成
    410——服务器上不再有此资源且无进一步的参考地址
    411——服务器拒绝用户定义的Content-Length属性请求
    412——一个或多个请求头字段在当前请求中错误
    413——请求的资源大于服务器允许的大小
    414——请求的资源URL长于服务器允许的长度
    415——请求资源不支持请求项目格式
    416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段
    417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求

       500——服务器产生内部错误
    501——服务器不支持请求的函数
    502——服务器暂时不可用，有时是为了防止发生系统过载
    503——服务器过载或暂停维修
    504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长
    505——服务器不支持或拒绝支请求头中指定的HTTP版本



&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;常见的错误主要有400 404 403 500 503等等&lt;/p&gt;
&lt;p&gt;相应正文，包含了请求获得的资源，有HTML文件，JSON格式数据，文件的URL等等&lt;/p&gt;
&lt;h3 id=&quot;消息报头&quot;&gt;&lt;a href=&quot;#消息报头&quot; class=&quot;headerlink&quot; title=&quot;消息报头&quot;&gt;&lt;/a&gt;消息报头&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;HTTP请求和HTTP响应都有消息报头。而消息报头是由众多报头域组成。每一个报头域都由名字＋“：”＋空格组成，消息报头域的名字是大小写无关的。&lt;/p&gt;
&lt;p&gt;HTTP消息报头包括普通报头、请求报头、响应报头和实体报头。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;普通报头：&quot;&gt;&lt;a href=&quot;#普通报头：&quot; class=&quot;headerlink&quot; title=&quot;普通报头：&quot;&gt;&lt;/a&gt;普通报头：&lt;/h4&gt;&lt;p&gt;在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。&lt;/p&gt;
&lt;p&gt;常见的普通报头：&lt;/p&gt;
&lt;p&gt;1）Cache-Control&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cache-Control用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。

请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;
响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2）Date&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Date普通报头域表示消息产生的日期和时间


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3）Connection&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Connection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接


&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h4 id=&quot;请求报头&quot;&gt;&lt;a href=&quot;#请求报头&quot; class=&quot;headerlink&quot; title=&quot;请求报头&quot;&gt;&lt;/a&gt;请求报头&lt;/h4&gt;&lt;p&gt;请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。&lt;br&gt;（在APP中，一些身份验证的信息可能需要在header中添加）&lt;/p&gt;
&lt;p&gt;常见的请求报头：&lt;/p&gt;
&lt;p&gt;1)Accept&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Accept请求报头域用于指定客户端接受哪些类型的信息。


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2)Accept-Charset&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Accept-Charset请求报头域用于指定客户端接受的字符集。如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3）Accept-Encoding&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4）Accept-Language&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5）Authorization&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;6）Host&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;发送请求时，该报头域是必需的。Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;7）User-Agent&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。


&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h4 id=&quot;响应报头&quot;&gt;&lt;a href=&quot;#响应报头&quot; class=&quot;headerlink&quot; title=&quot;响应报头&quot;&gt;&lt;/a&gt;响应报头&lt;/h4&gt;&lt;p&gt;响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。&lt;/p&gt;
&lt;p&gt;常见的实体报头：&lt;/p&gt;
&lt;p&gt;1）Location&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Location响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2）Server&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Server响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3）WWW-Authenticate&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;WWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。


&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h4 id=&quot;实体报头&quot;&gt;&lt;a href=&quot;#实体报头&quot; class=&quot;headerlink&quot; title=&quot;实体报头&quot;&gt;&lt;/a&gt;实体报头&lt;/h4&gt;&lt;p&gt;请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。&lt;/p&gt;
&lt;p&gt;实体报头包括：&lt;/p&gt;
&lt;p&gt;常见的实体报头：&lt;/p&gt;
&lt;p&gt;1）Content-Encoding&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Content-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding主要用于记录文档的压缩方法。


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2）Content-Language&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Content-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;阅读者。&lt;/p&gt;
&lt;p&gt;3）Content-Length&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Content-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。即一个数字字符占一个字节，用其对应的ASCII码来存储传输。


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4）Content-Type&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5）Expires&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Expires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;6）Last-Modified&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Last-Modified实体报头域用于指示资源的最后修改日期和时间。


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##总结&lt;/p&gt;
&lt;p&gt;HTTP协议的内容不是多，常用的内容就几个，但是需要非常熟悉，因为HTTP协议是网络交互重要的协议之一。&lt;/p&gt;
&lt;p&gt;接下来花一些时间去回顾TCP/IP协议，内容多就会有几篇文章来记录学习的一些笔记心得。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;#HTTP学习&lt;/p&gt;
&lt;p&gt;HTTP协议是网络中最广泛的协议之一，对HTTP协议的了解应该是每一个和网络打交道的程序员必须具备的技能。很多公司面试都要求对网络知识有一定的了解，一个是TCP/IP协议，一个就是HTTP协议，HTTP协议应用层的协议，内容比较少，这周花时间去
    
    </summary>
    
      <category term="Network" scheme="http://csbzhixing.github.io/categories/Network/"/>
    
    
  </entry>
  
</feed>
