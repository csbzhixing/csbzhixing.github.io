<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>学海无涯</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://csbzhixing.github.io/"/>
  <updated>2016-12-31T02:53:53.000Z</updated>
  <id>http://csbzhixing.github.io/</id>
  
  <author>
    <name>csbzhixing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2016，注定不平凡</title>
    <link href="http://csbzhixing.github.io/2016/12/31/2016%EF%BC%8C%E6%B3%A8%E5%AE%9A%E4%B8%8D%E5%B9%B3%E5%87%A1/"/>
    <id>http://csbzhixing.github.io/2016/12/31/2016，注定不平凡/</id>
    <published>2016-12-31T01:50:41.000Z</published>
    <updated>2016-12-31T02:53:53.000Z</updated>
    
    <content type="html">&lt;p&gt;2016年，注定是一个不一样的年份。年头到年尾，世界上发生了太多历史性的进程。一个英国脱欧，一个特朗普当选就足以让世人谈论上许多年。对于我个人，也是一个不同寻常的年份：今年我毕业了。&lt;/p&gt;
&lt;h3 id=&quot;毕业了，我想谈谈教育&quot;&gt;&lt;a href=&quot;#毕业了，我想谈谈教育&quot; class=&quot;headerlink&quot; title=&quot;毕业了，我想谈谈教育&quot;&gt;&lt;/a&gt;毕业了，我想谈谈教育&lt;/h3&gt;&lt;p&gt;从上学第一天开始，我就想什么时候会结束这一段历程，想不到到来后却一点感觉没有。结束了学生身份，最大的感触就是：不再会有人照顾你了。&lt;/p&gt;
&lt;p&gt;16年的求学经历，改变了一个人多少，每个人都会有自己的看法。在我看来，学生时代养成的习惯是永远改不掉的。很幸运的是，自己能够从小学一路顺利得读完大学。相比较许多无缘能够进入学校学习的人来说，能够接受完整系统的知识教育，是一件太幸福的事情。&lt;/p&gt;
&lt;p&gt;在经历了完整的中国教育系统设计的教育体系后，感觉并没有网络以及他人所说的那么不堪。的确，中国某些体系原因造成了教育系统多变的情况，我也是几乎踏准了每次教育改革的门槛。但是我并不认为，这些改革最后改变了什么，甚至我不认为教授的内容会对人有什么影响。到目前为止，我认为，学校教育带给我最大的好处，就是学会系统逻辑的思考以及自学能力。&lt;/p&gt;
&lt;p&gt;大多人批判中国教育为填鸭式教育。其实，在我看来，这只是一种迫不得已的手段。只有在严酷的训练下，才有悟的可能。绝不同于网络小说的主人公，我们不会在一天突然灵光一闪然后打通了任督二脉因此学贯中西。我们只能在不停地残酷的训练中总结，直到有一天明白知识的相通性。很遗憾的是，太多人麻木在重复高强度的训练中，只有少数人能够参透。我也是在大学最后，才明白过来，为时已晚。&lt;/p&gt;
&lt;p&gt;教育，最大的目的是授人以渔。学会学习才是学习最大的目的。&lt;/p&gt;
&lt;h3 id=&quot;读书，不是为了考试&quot;&gt;&lt;a href=&quot;#读书，不是为了考试&quot; class=&quot;headerlink&quot; title=&quot;读书，不是为了考试&quot;&gt;&lt;/a&gt;读书，不是为了考试&lt;/h3&gt;&lt;p&gt;上了大学后，除了少数的专业书籍，几乎怎么看书了。就这样浑浑噩噩过了两年，不仅专业并没有多大的提升，眼界和思维也是停滞不前。所幸的是这两年又捡回了读书的习惯。如果只依靠考试来鞭笞自己读书，恐怕也无法在未来走的更远吧。&lt;/p&gt;
&lt;p&gt;在这里简单列下书单，也算推荐一些书籍&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/3369600/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;当我谈跑步时我谈些什么&lt;/a&gt; 春上春树记录自己的跑步中一些随想。看到其中一些想法和自己跑步中想法有相似之处。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/26835090/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Soft Skills: The software developer’s life manual&lt;/a&gt;代码之外的软技能。程序员不能只埋头技术，还应该抬头看看世界。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/3432304/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;大江东去&lt;/a&gt;讲改革开放前期的小说。前两部给我的启发很多。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/4239246/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;市场的力量&lt;/a&gt;有点浅，实例不错。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/7057936/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;批判性思维：带你走出思维误区&lt;/a&gt;中文翻译有些无法表达完善，但内容的确详实，有能力的推荐看原版&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/5290524/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;微革命&lt;/a&gt;内容偏水，思考的点不错。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;16年因为毕业，没能完成自己在年初定下的读书计划。17年不该再有借口。读书，应该是一辈子的事情。&lt;/p&gt;
&lt;h3 id=&quot;技术&quot;&gt;&lt;a href=&quot;#技术&quot; class=&quot;headerlink&quot; title=&quot;技术&quot;&gt;&lt;/a&gt;技术&lt;/h3&gt;&lt;p&gt;作为程序员，年终总结怎么能不写技术呢？不过，我不打算在这里写很多技术内容，只想谈谈对编程技术的一些思考。&lt;/p&gt;
&lt;p&gt;编程技术，总的来说我认为也属于工程技术的一种，而且是属于门槛较低的部分。君不见满街40天培训Android，iOS，web月薪过万。然而，只有潮退了才知道谁在裸泳。16年的资本寒冬也影响到了炙手可热的互联网产业。一批批创业公司倒下使初级开发严重过剩。一个iOS岗位一周几百上千封简历不是夸张。作为一名刚毕业进入工作岗位的开发，说没有担心那是假的。究竟在几年后如何保持一定的竞争力？这些个一直在思考这些问题。&lt;/p&gt;
&lt;p&gt;广义上的信息技术发展已经有几十个年头了，而新概念还在层出不穷。机器学习，AR,VR,大数据等等名字容易让新进行业的人头晕眼花。不能不承认，APP时代已经开始拉下帷幕了，未来究竟在哪，谁也给不出一个准确的答案。跟着行业走的技术也只能跟着行业的兴衰。作为技术，不能只着眼一处，保持学习，才能永远不被拉下。&lt;/p&gt;
&lt;h3 id=&quot;17年，路在哪里&quot;&gt;&lt;a href=&quot;#17年，路在哪里&quot; class=&quot;headerlink&quot; title=&quot;17年，路在哪里&quot;&gt;&lt;/a&gt;17年，路在哪里&lt;/h3&gt;&lt;p&gt;絮叨半天，发现自己的行文依旧这么烂（逃。年终总结，不就是应该给未来的自己避免踩上同一个坑吗。17年会怎么样，我不知道。但是我想我应该让自己知道17该怎么样。&lt;/p&gt;
&lt;p&gt;读书依旧是不可少的，保持一个月一本的节奏。&lt;/p&gt;
&lt;p&gt;技术上，本职上的iOS客户端开发要深挖下去，不能停留在表面的应用了。初次之外，学学数据处理分析相关的技术吧。&lt;/p&gt;
&lt;p&gt;锻炼，16年的断断续续的，没能保持一定惯性。锻炼是最考验一个人意志力的行为。17年要保持，只有一个好身体才能应付一切。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;2016年，注定是一个不一样的年份。年头到年尾，世界上发生了太多历史性的进程。一个英国脱欧，一个特朗普当选就足以让世人谈论上许多年。对于我个人，也是一个不同寻常的年份：今年我毕业了。&lt;/p&gt;
&lt;h3 id=&quot;毕业了，我想谈谈教育&quot;&gt;&lt;a href=&quot;#毕业了，我想谈谈教育&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从面试想到的</title>
    <link href="http://csbzhixing.github.io/2016/12/19/%E6%B5%85%E8%B0%88%E4%B8%80%E7%82%B9%E9%9D%A2%E8%AF%95%E4%BD%93%E9%AA%8C/"/>
    <id>http://csbzhixing.github.io/2016/12/19/浅谈一点面试体验/</id>
    <published>2016-12-19T01:50:41.000Z</published>
    <updated>2016-12-31T01:51:16.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;浅谈一点面试体验&quot;&gt;&lt;a href=&quot;#浅谈一点面试体验&quot; class=&quot;headerlink&quot; title=&quot;浅谈一点面试体验&quot;&gt;&lt;/a&gt;浅谈一点面试体验&lt;/h1&gt;&lt;p&gt;最近部门业务扩展，移动端终于迎来了难得招人的机会。在经历半个月的招聘体验后，感触良多，想总结下这半个月的体验以及一点想法&lt;/p&gt;
&lt;h2 id=&quot;移动端怎么了&quot;&gt;&lt;a href=&quot;#移动端怎么了&quot; class=&quot;headerlink&quot; title=&quot;移动端怎么了&quot;&gt;&lt;/a&gt;移动端怎么了&lt;/h2&gt;&lt;p&gt; 在挂出简历了不到一天，邮箱就被上百封简历轰炸了。虽然对今天就业形势有一些耳闻，但是碰到如此情形还是有点惊讶。到昨天，整整收到了600多封iOS简历。iOS开发究竟怎么了？是苹果不行了吗？其实并不是iOS开发不行了，而是移动端的风口过了。在简历中，我看到了形形色色色的项目。从2C的教育，医疗，直播等等，到2B的IM，项目管理等等，这些项目都有一个特点 — 开发时间特别短。几乎没有一个项目是在一个人手里开发超过1年的。同时，几乎每个人手里都有四五个项目，甚至一个刚工作一年的人的简历里就写了四个项目。可见，在过去一两年，移动端开发过热导致许多公司盲目的上项目。其中印象深刻的是，光汽车蓝牙相关的APP就有十几个。不过在汽车上驾驶员使用手机的问题，就说有多少人真的需要一个APP来通过蓝牙控制汽车功能？这些项目往往在功能简单的同时，没有太多的技术难度，仅仅是为了完成公司产品而生成的。在面试的过程中，简单问了些蓝牙协议的实现，几乎100%的面试者都说通过三方实现的。随着投资热潮褪去，这些项目的一批批的死去，自然释放出了许多初级移动端开发(尤其iOS)。移动端并没有死去，而是走向理智，只是在风口上的猪掉了下来。&lt;/p&gt;
&lt;h2 id=&quot;请不要写精通好吗&quot;&gt;&lt;a href=&quot;#请不要写精通好吗&quot; class=&quot;headerlink&quot; title=&quot;请不要写精通好吗&quot;&gt;&lt;/a&gt;请不要写精通好吗&lt;/h2&gt;&lt;p&gt; 在筛选简历的时候，看到精通和熟练的次数几乎是一样多。参与竞聘的人员几乎都是1-3年经验。怎么样才可以说对某项技能达到了精通的地步？我认为，至少在对于这项技能，无论理论还是应用都达到了烂熟于心的地步。在开始时，对于简历上写着精通的面试者，我无不抱着探讨的心态去讨论。然而，迄今为止，几乎没有精通OC的面试者能够讲清楚&lt;code&gt;atomic&lt;/code&gt; 和 &lt;code&gt;nonatomic&lt;/code&gt;的区别，为什么常用&lt;code&gt;nonatomic&lt;/code&gt;，为什么用&lt;code&gt;atomic&lt;/code&gt;也不能保证安全。至于精通TCP/UPD的，甚至不能准确讲出TCP连接断开的过程。正如有句话：懂的越多，越觉得自己不懂。&lt;/p&gt;
&lt;h2 id=&quot;不好意思，我没想过&quot;&gt;&lt;a href=&quot;#不好意思，我没想过&quot; class=&quot;headerlink&quot; title=&quot;不好意思，我没想过&quot;&gt;&lt;/a&gt;不好意思，我没想过&lt;/h2&gt;&lt;p&gt;这恐怕是我听过最多的一句话，也是我听不愿听到一句话。作为一个开发，每天我们都能遇到各种各样的问题。然而遇到了问题，我们是简单的百度一下，还是停下来想想后面的原因？每逢谈到循环引用，几乎都谈到block中的情况。然而如果我直接问道除了block中的情况呢，几乎80%的面试者都懵逼了。我想，如果真正理解了循环引用，不可能只能想到block中这么一种情况。谈到&lt;code&gt;autoreleasepool&lt;/code&gt;的理解和用法。除了简单和&lt;code&gt;ARC&lt;/code&gt;关联在一起(其实这里不该混淆在一起)，就只会简单的说不知道了。然而，在&lt;code&gt;main.m&lt;/code&gt;文件中其实就用了&lt;code&gt;autorealesepool&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;请写上你熟悉的，而不是仅仅用过的&quot;&gt;&lt;a href=&quot;#请写上你熟悉的，而不是仅仅用过的&quot; class=&quot;headerlink&quot; title=&quot;请写上你熟悉的，而不是仅仅用过的&quot;&gt;&lt;/a&gt;请写上你熟悉的，而不是仅仅用过的&lt;/h2&gt;&lt;p&gt;在筛选简历的时候，简历上有一些新意的字眼的确有加分项。比如&lt;code&gt;swift3&lt;/code&gt;的开发经历，网络和渲染的优化，熟悉第三方库的实现(&lt;code&gt;YYKit&lt;/code&gt;,&lt;code&gt;SDWebImage&lt;/code&gt;等等)。然而，当你在简历上体现出来这些东西时候，起码自己要熟悉。仅仅使用swift写了一个demo可不能熟悉swift。swift的特性，比如柯里化，比如enum,structs,class的区别和选型考虑，这些问题如果都没有考虑，仅仅把一个demo从oc转成swift也仅仅在语言层面的转化而已。而优化的部分，起码要搞清楚优化的意义在哪里，为何需要优化，仅仅封装业务相关内容可不是优化。而第三方库理解，不该只是在调调API这样。无论多么优秀的第三方实现都有自己的不足和可以改进的地方。只有自己读了源码，认真去思考，分辨优劣，才能谈得上理解。&lt;/p&gt;
&lt;h2 id=&quot;请不要说用不到&quot;&gt;&lt;a href=&quot;#请不要说用不到&quot; class=&quot;headerlink&quot; title=&quot;请不要说用不到&quot;&gt;&lt;/a&gt;请不要说用不到&lt;/h2&gt;&lt;p&gt;这句话最多听到的是在问算法的时候。失望的是，到目前为止，还没有人能答出几道简单的算法和数据结构相关的题目。一个简单的求两个数的最大公约数几乎没有人能给出想法(没错，就是直接说不会)。而归并排序，快排，二分查找更是无人能说出一二。iOS开发真的不需要用到算法和数据结构吗？我想不是的。其实很多劣质的代码往往是对数据结构和算法的不熟悉导致的。记得一个非常常见的例子：新增数据的比对。比如增量上报通讯录，很多人旺旺是做for循环嵌套。然而如果能用到hash表，效率能有量级的提高。虽然如今iOS开发能真的需要自己去手写算法的地方很少，但如果就此不去学习，不说不能更进一步，可能还会产出许多劣质的代码。&lt;/p&gt;
&lt;h2 id=&quot;基础，离不开的基础&quot;&gt;&lt;a href=&quot;#基础，离不开的基础&quot; class=&quot;headerlink&quot; title=&quot;基础，离不开的基础&quot;&gt;&lt;/a&gt;基础，离不开的基础&lt;/h2&gt;&lt;p&gt;经过多次面试后，HR反馈给我，说面试者认为我考的内容偏向于“死”的内容，而开放性关于项目的内容很少。笔者在这里阐述下自己的观点。万丈高楼平地起，再牛的人，再好的项目，无不是从一点点基础开始的。离开了扎实的基础，我不认为讲开放性的内容能够说出独特的见解。事实上，我也问过一些开放性的内容，比如渲染的优化，网络优化的点。然而，对view渲染的机制深入的不够以及对网络协议的浅薄见解，影响到了许多人能谈的很少。所以，我在后面的面试，依然会坚持对基础的考核，毕竟，基础扎实了，再去做深入的探索也不会有太大的困难。&lt;/p&gt;
&lt;h2 id=&quot;三年，还是一&quot;&gt;&lt;a href=&quot;#三年，还是一&quot; class=&quot;headerlink&quot; title=&quot;三年，还是一&quot;&gt;&lt;/a&gt;三年，还是一&lt;/h2&gt;&lt;p&gt;在前文说到，参与面试的人都是有两三年开发经验，有数个项目经验在身的。然而在我看来，他们仅仅是把一年经验，反复用了三年而已，甚至，我认为其中有些人甚至不如优秀的应届。为何会出现这样的问题，在我看来多数原因在于把自己的眼界困死了。几乎所有人的简历上都写着能够完成一个完整的app。但是在我看来，完成一个完整APP是一个有一年开发经验合格的iOS开发就能做到的。而两三年经验的开发，应该更多去深入细节，串联自己的知识。记得我常问一个问题：iOS中有哪些锁的实现方法？少数人能谈到&lt;code&gt;NSLock&lt;/code&gt;，多数人只知道&lt;code&gt;synchronized&lt;/code&gt;。我不是很理解三年的开发经历就没想了解过其他的实现吗？况且网上讲解的文章也不少。&lt;/p&gt;
&lt;p&gt;吐槽了那么多，实际上也是想鞭笞自己。学无止境，有太多的点需要自己去研究，永远不能满足现有的状况，永远不要让自己待在舒适区，切记切记。&lt;/p&gt;
&lt;p&gt;后面可能会总结下在面试中问道的问题。实际上有些问题也是最近在准备的时候学习到了更多的内容，也算为自己的知识体系做了补充。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;浅谈一点面试体验&quot;&gt;&lt;a href=&quot;#浅谈一点面试体验&quot; class=&quot;headerlink&quot; title=&quot;浅谈一点面试体验&quot;&gt;&lt;/a&gt;浅谈一点面试体验&lt;/h1&gt;&lt;p&gt;最近部门业务扩展，移动端终于迎来了难得招人的机会。在经历半个月的招聘体验后，感触良多，想总结
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Weex, React Native, JSPatch</title>
    <link href="http://csbzhixing.github.io/2016/08/23/%20RN--WEEX--JSPATCH/"/>
    <id>http://csbzhixing.github.io/2016/08/23/ RN--WEEX--JSPATCH/</id>
    <published>2016-08-23T15:16:32.000Z</published>
    <updated>2016-08-23T15:20:46.000Z</updated>
    
    <content type="html">&lt;p&gt;本文是做内部分享的时候整理的知识内容，整理了出来。&lt;/p&gt;
&lt;h2 id=&quot;技术介绍&quot;&gt;&lt;a href=&quot;#技术介绍&quot; class=&quot;headerlink&quot; title=&quot;技术介绍&quot;&gt;&lt;/a&gt;技术介绍&lt;/h2&gt;&lt;h3 id=&quot;Weex&quot;&gt;&lt;a href=&quot;#Weex&quot; class=&quot;headerlink&quot; title=&quot;Weex&quot;&gt;&lt;/a&gt;Weex&lt;/h3&gt;&lt;p&gt;Weex是阿里手淘开源的一套跨平台开发。核心语法借鉴了vue.js。&lt;/p&gt;
&lt;p&gt;Weex是跨平台，可扩展的动态化技术. 你能通过在Weex源码中写&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签，然后把这些标签转换为JS Bundle用于部署, 在服务端以这些JS Bundle响应请求. 当客户端接收到JS Bundle时，它能用被客户端中的JS引擎用于管理Native渲染;API调用和用户交互.&lt;/p&gt;
&lt;h4 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;&gt;&lt;/a&gt;基本语法&lt;/h4&gt;&lt;p&gt; &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;是必须的，使用类HTML的形式，内容由多个标签组成，不同标签代表不同的组件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;，可选，使用类CSS语法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 可选，使用js描述页面中逻辑和数据，数据定义也在这个部分&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 中有三种不同的根节点形式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;container&amp;gt;&lt;/code&gt;，普通根节点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;scroller&amp;gt;&lt;/code&gt;，滚动根节点，适用于全页面滚动&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;，列表根节点，适用于复用元素的列表场景。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;类似CSS的形式，和标准CSS有一些细微的差别&lt;/p&gt;
&lt;p&gt;第一种使用内联的方式，通过style属性直接添加样式。第二种通过&lt;code&gt;class&lt;/code&gt;属性与&lt;code&gt;style&lt;/code&gt;属性建立对应关系&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;container&amp;gt;
    &amp;lt;text style=&amp;quot;font-size: 64;&amp;quot;&amp;gt;Alibaba&amp;lt;/text&amp;gt;
    &amp;lt;text class=&amp;quot;large&amp;quot;&amp;gt;Weex Team&amp;lt;/text&amp;gt;
  &amp;lt;/container&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style&amp;gt;
  .large {font-size: 64;}
&amp;lt;/style&amp;gt;``
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;中代码遵循&lt;code&gt;ES5&lt;/code&gt;语法标准&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;image onclick=&amp;quot;handler&amp;quot; ...&amp;gt;&amp;lt;/image&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
  module.exports = {
    methods: {
      handler: function (e) {
        // TODO
      }
    }
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当一个事件函数被调用，它会收到的第一个参数就是事件对象。每个事件对象包含一下属性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt;,事件名称，如&lt;code&gt;click&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;target&lt;/code&gt;，目标元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timestamp&lt;/code&gt;,事件触发的时间戳。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;渲染流程&quot;&gt;&lt;a href=&quot;#渲染流程&quot; class=&quot;headerlink&quot; title=&quot;渲染流程&quot;&gt;&lt;/a&gt;渲染流程&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;
Weex we 文件 ---------------前端(we源码)
↓ (转换) -------------------前端(构建过程)
JS Bundle -----------------前端(JS Bundle代码)
↓ (部署) -------------------服务器
在服务器上的JS bundle  ------服务器
↓ (编译) ------------------ 客户端(JS引擎)
虚拟 DOM 树 --------------- 客户端(Weex JS Framework)
↓ (渲染) ------------------ 客户端(渲染引擎)
Native视图 ---------------  客户端(渲染引擎)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;渲染流程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;虚拟DOM.&lt;/li&gt;
&lt;li&gt;构造树结构. 分析虚拟DOM JSON数据以构造渲染树(RT).&lt;/li&gt;
&lt;li&gt;添加样式. 为渲染树的各个节点添加样式.&lt;/li&gt;
&lt;li&gt;创建视图. 为渲染树各个节点创建Native视图.&lt;/li&gt;
&lt;li&gt;绑定事件. 为Native视图绑定事件.&lt;/li&gt;
&lt;li&gt;CSS布局. 使用 css-layout 来计算各个视图的布局.&lt;/li&gt;
&lt;li&gt;更新视窗(Frame). 采用上一步的计算结果来更新视窗中各个视图的最终布局位置.&lt;/li&gt;
&lt;li&gt;最终页面呈现.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;存在的问题&quot;&gt;&lt;a href=&quot;#存在的问题&quot; class=&quot;headerlink&quot; title=&quot;存在的问题&quot;&gt;&lt;/a&gt;存在的问题&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;刚刚开源，社区活跃度不高，以阿里团队为主&lt;/li&gt;
&lt;li&gt;支持的控件比较少（比如button就没有），checkbox，radio也没有&lt;/li&gt;
&lt;li&gt;焦点问题&lt;/li&gt;
&lt;li&gt;CSS不支持父级继承&lt;/li&gt;
&lt;li&gt;文档不完善&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;和React-Native-对比&quot;&gt;&lt;a href=&quot;#和React-Native-对比&quot; class=&quot;headerlink&quot; title=&quot;和React Native 对比&quot;&gt;&lt;/a&gt;和React Native 对比&lt;/h4&gt;&lt;h5 id=&quot;JS引擎：&quot;&gt;&lt;a href=&quot;#JS引擎：&quot; class=&quot;headerlink&quot; title=&quot;JS引擎：&quot;&gt;&lt;/a&gt;JS引擎：&lt;/h5&gt;&lt;p&gt;安卓上 weex使用V8， ReactNative使用JSCore&lt;/p&gt;
&lt;p&gt;iOS上，都使用了JSCore&lt;/p&gt;
&lt;p&gt;原因是，RN为了使用JSCore，将整个JSCore打包进了app的webkit库，所以安卓的包体容量有比较明显的增大。而iOS则自带&lt;/p&gt;
&lt;p&gt;weex考虑到在安卓上都需要自己打包，那么就选择了更新的V8引擎，而iOS则继续使用系统自带的JSCore&lt;/p&gt;
&lt;h5 id=&quot;JS开发框架：&quot;&gt;&lt;a href=&quot;#JS开发框架：&quot; class=&quot;headerlink&quot; title=&quot;JS开发框架：&quot;&gt;&lt;/a&gt;JS开发框架：&lt;/h5&gt;&lt;p&gt;weex基于vue.js(2W+ star)。小巧轻量的前端开发框架，组件化，数据绑定，2.0引入virtual dom。&lt;/p&gt;
&lt;p&gt;ReactNative使用React(4W+ star)。革命性的前端开发框架，组件化，数据绑定，virtual dom。&lt;/p&gt;
&lt;p&gt;这两者，vue更符合web开发的习惯，JSX改变比较大，但是总体而言，熟悉web开发都不是大问题，对于只有移动端开发经验的人可能RN的学习成本稍高。&lt;/p&gt;
&lt;h5 id=&quot;布局&quot;&gt;&lt;a href=&quot;#布局&quot; class=&quot;headerlink&quot; title=&quot;布局&quot;&gt;&lt;/a&gt;布局&lt;/h5&gt;&lt;p&gt;布局两者都是基于facebook的代码解析，实现了flexBox的子集&lt;/p&gt;
&lt;p&gt;这个代码解析，写起来是爽，但是，对于复杂的页面，会产生比较严重的性能问题.&lt;/p&gt;
&lt;p&gt;这里本来分享用了内部项目的图，这里没有放出来。大家可以自己用三套框架去实现同一个页面，用reveal去看下就明白了。&lt;/p&gt;
&lt;p&gt;能不能解决这个问题，网上有人提出了改变思路的方式，即不适用前端布局的思维用js去驱动Native绘图，而是用native的思路去用js驱动。不过这样的话，就加大了前端人员的学习成本&lt;/p&gt;
&lt;h5 id=&quot;Moudle方法调用线程：&quot;&gt;&lt;a href=&quot;#Moudle方法调用线程：&quot; class=&quot;headerlink&quot; title=&quot;Moudle方法调用线程：&quot;&gt;&lt;/a&gt;Moudle方法调用线程：&lt;/h5&gt;&lt;p&gt;weex 可以通过注解标注是否在UI线程执行&lt;/p&gt;
&lt;p&gt;ReactNative在安卓上是在&lt;code&gt;native_modules&lt;/code&gt;线程执行。iOS里面，每一个&lt;code&gt;native_modules&lt;/code&gt;可以支持标记，需要重写module的&lt;code&gt;methodQueue&lt;/code&gt;方法，就可以获得在&lt;code&gt;main_queue&lt;/code&gt;中执行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//RCTClipboard类的源码
- (dispatch_queue_t)methodQueue
{
  return dispatch_get_main_queue();
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;扩展性&quot;&gt;&lt;a href=&quot;#扩展性&quot; class=&quot;headerlink&quot; title=&quot;扩展性&quot;&gt;&lt;/a&gt;扩展性&lt;/h5&gt;&lt;p&gt;组件的扩展上，weex和ReactNative具有一样的能力&lt;/p&gt;
&lt;p&gt;三方库的接入上，weex对网络，图片，统计等常见的用户可能想自己定制的功能，提供了相应的适配接口，可以由用户方便的定制，ReactNative需要自己修改源码&lt;/p&gt;
&lt;p&gt;两者在功能上并无绝对的优劣。在开发催收的过程中，我们发现很多常见的功能RN没有支持，但是我们通过一点点摸索都能自己扩展出来。RN在底层的native代码都是一个个module，可以根据开发需要灵活扩展插拔。基本上能想的出来的都可以自己实现，当然，有些实现起来比较麻烦，因此，对于RN，目前还不太适合做重量级的产品。&lt;/p&gt;
&lt;h4 id=&quot;weex-or-ReactNative&quot;&gt;&lt;a href=&quot;#weex-or-ReactNative&quot; class=&quot;headerlink&quot; title=&quot;weex or ReactNative&quot;&gt;&lt;/a&gt;weex or ReactNative&lt;/h4&gt;&lt;p&gt;weex的诞生据说是为了解决ReactNative的一些问题。目前阿里在推动&lt;code&gt;write once run anywhere&lt;/code&gt;的方面上是走的最前的。两者对&lt;code&gt;write once run anywhere&lt;/code&gt;思考，我认为，是出发重点，终点不同。RN的目的是革命Native端，而weex则是想改变H5在移动端的效果，因此做到了web,iOS,android三平台统一（RN做不到web端）。因此，在开发商，weex甚至可以抛开native的palyground，直接在web上做开发，等到调试差不多了，再到native上做细致的检查。&lt;/p&gt;
&lt;p&gt;weex的出生决定了他站在了巨人的肩膀上。一个&lt;code&gt;devTools&lt;/code&gt;就足以看到weex团队想做出的改变。&lt;/p&gt;
&lt;p&gt;网上有人类比两者是windows和Linux的关系，而我认为应该是mac OS和Linux的关系。&lt;/p&gt;
&lt;h2 id=&quot;JSPatch&quot;&gt;&lt;a href=&quot;#JSPatch&quot; class=&quot;headerlink&quot; title=&quot;JSPatch&quot;&gt;&lt;/a&gt;JSPatch&lt;/h2&gt;&lt;h3 id=&quot;平台介绍&quot;&gt;&lt;a href=&quot;#平台介绍&quot; class=&quot;headerlink&quot; title=&quot;平台介绍&quot;&gt;&lt;/a&gt;平台介绍&lt;/h3&gt;&lt;p&gt;基于OC的runtime机制，使用iOS内置的JavaScriptCore.framework作为JS引擎，从JS传递要调用的类名函数名到Objective-C，再使用NSInvocation动态调用对应的OC方法。&lt;/p&gt;
&lt;p&gt;优势：&lt;/p&gt;
&lt;p&gt;使用JS语言，比之前的使用Lua的&lt;code&gt;WXPatch&lt;/code&gt;适用更广泛。&lt;/p&gt;
&lt;p&gt;符合Apple规则&lt;/p&gt;
&lt;p&gt;引擎小，除去扩展内容，核心只有三个文件&lt;/p&gt;
&lt;p&gt;支持block。&lt;/p&gt;
&lt;h3 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h3&gt;&lt;p&gt;JSPatch之所以能够做到通过JS来调用和修改OC方法的根本原因是OC是动态语言，OC所有的类和方法都的生成和调用都可以通过runtime在运行时进行，因此可以通过类名/方法名反射得到相应的类和方法。&lt;/p&gt;
&lt;h4 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h4&gt;&lt;p&gt;调用&lt;code&gt;requir&lt;/code&gt;后，就可以直接使用类了，过程就是在JS全局作用域上创建一个同名变量，变量指向一个对象，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var _require = function(clsName) {
  if (!global[clsName]) {
    global[clsName] = {
      __clsName: clsName
    }
  }
  return global[clsName]
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;封装JS对象&quot;&gt;&lt;a href=&quot;#封装JS对象&quot; class=&quot;headerlink&quot; title=&quot;封装JS对象&quot;&gt;&lt;/a&gt;封装JS对象&lt;/h4&gt;&lt;p&gt;由于JS调用没定义的属性或者放发的时候不会转发，而是直接抛出异常。作者最先开始考虑的是在&lt;code&gt;require&lt;/code&gt;的时候将类名传入OC，通过runtime将整个类的方法和属性返回给JS，JS对每个方法名都生成一个函数，这个函数的内容就是将通过方法名去调用OC的方法实现。&lt;/p&gt;
&lt;p&gt;然而这种方法实现会造成巨大性能问题，因为除了要遍历当前类的方法，还要遍历父类一直到根类所有继承链上的方法，所以在引入几个类以后就造成内存暴涨。作者为了解决这个问题，想出在 OC 执行 JS 脚本前，通过正则把所有方法调用都改成调用 __c() 函数，再执行这个 JS 脚本，做到了类似 OC/Lua/Ruby 等的消息转发机制：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UIView.alloc().init()
-&amp;gt;
UIView.__c(&amp;#39;alloc&amp;#39;)().__c(&amp;#39;init&amp;#39;)()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;给 JS 对象基类 Object 加上 &lt;strong&gt;c 成员，这样所有对象都可以调用到 &lt;/strong&gt;c，根据当前对象类型判断进行不同操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object.defineProperty(Object.prototype, &amp;#39;__c&amp;#39;, {value: function(methodName) {
  if (!this.__obj &amp;amp;&amp;amp; !this.__clsName) return this[methodName].bind(this);
  var self = this
  return function(){
    var args = Array.prototype.slice.call(arguments)
    return _methodFunc(self.__obj, self.__clsName, methodName, args, self.__isSuper)
  }
}})
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;消息传递&quot;&gt;&lt;a href=&quot;#消息传递&quot; class=&quot;headerlink&quot; title=&quot;消息传递&quot;&gt;&lt;/a&gt;消息传递&lt;/h4&gt;&lt;p&gt;是用了JSCore的接口，在启动JSPatch的时候会创建一个&lt;code&gt;JSContext&lt;/code&gt;实例，&lt;code&gt;JSContext&lt;/code&gt;是JS的执行环境，可以给&lt;code&gt;JSContext&lt;/code&gt;添加方法，JS可以直接调用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JSContext *context = [[JSContext alloc] init];
context[@&amp;quot;hello&amp;quot;] = ^(NSString *msg) {
    NSLog(@&amp;quot;hello %@&amp;quot;, msg);
};
[_context evaluateScript:@&amp;quot;hello(&amp;#39;word&amp;#39;)&amp;quot;];     //output hello word
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JS 通过调用 JSContext 定义的方法把数据传给 OC，OC 通过返回值传会给 JS。调用这种方法，它的参数/返回值 JavaScriptCore 都会自动转换，OC 里的 NSArray, NSDictionary, NSString, NSNumber, NSBlock 会分别转为JS端的数组/对象/字符串/数字/函数类型。&lt;/p&gt;
&lt;h4 id=&quot;对象持有转换&quot;&gt;&lt;a href=&quot;#对象持有转换&quot; class=&quot;headerlink&quot; title=&quot;对象持有转换&quot;&gt;&lt;/a&gt;对象持有转换&lt;/h4&gt;&lt;p&gt;对于一个自定义id对象，JavaScriptCore 会把这个自定义对象的指针传给 JS，这个对象在 JS 无法使用，但在回传给 OC 时 OC 可以找到这个对象。对于这个对象生命周期的管理，按我的理解如果JS有变量引用时，这个 OC 对象引用计数就加1 ，JS 变量的引用释放了就减1，如果 OC 上没别的持有者，这个OC对象的生命周期就跟着 JS 走了，会在 JS 进行垃圾回收时释放。&lt;/p&gt;
&lt;p&gt;传给 JS 的变量是这个 OC 对象的指针，这个指针也可以重新传回 OC，要在 JS 调用这个对象的某个实例方法，只需要在函数里把这个对象指针以及它要调用的方法名传回给 OC 就行了。&lt;/p&gt;
&lt;p&gt;目前没找到方法判断一个 JS 对象是否表示 OC 指针，这里的解决方法是在 OC 把对象返回给 JS 之前，先把它包装成一个 NSDictionary：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static NSDictionary *_wrapObj(id obj) {
    return @{@&amp;quot;__obj&amp;quot;: obj};
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样在JS对象里就可以变成这样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{__obj: [OC Object 对象指针]}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;方法替换&quot;&gt;&lt;a href=&quot;#方法替换&quot; class=&quot;headerlink&quot; title=&quot;方法替换&quot;&gt;&lt;/a&gt;方法替换&lt;/h4&gt;&lt;p&gt;运用runtime的原理，不展开讲。&lt;/p&gt;
&lt;h4 id=&quot;死锁问题&quot;&gt;&lt;a href=&quot;#死锁问题&quot; class=&quot;headerlink&quot; title=&quot;死锁问题&quot;&gt;&lt;/a&gt;死锁问题&lt;/h4&gt;&lt;p&gt;javaScript 语言是单线程的，在 OC 使用 JavaScriptCore 引擎执行 JS 代码时，会对 JS 代码块加锁，保证同个 JSContext 下的 JS 代码都是顺序执行。所以调用 JSPatch 替换的方法，以及在 JSPatch 里调用 OC 方法，都会在这个锁里执行，这导致三个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JSPatch替换的方法无法并行执行，如果如果主线程和子线程同时运行了 JSPatch 替换的方法，这些方法的执行都会顺序排队，主线程会等待子线程的方法执行完后再执行，如果子线程方法耗时长，主线程会等很久，卡住主线程。&lt;/li&gt;
&lt;li&gt;某种情况下，JavaScriptCore 的锁与 OC 代码上的锁混合时，会产生死锁。&lt;/li&gt;
&lt;li&gt;UIWebView 的初始化会与 JavaScriptCore 冲突。若在 JavaScriptCore 的锁里(第一次)初始化 UIWebView 会导致 webview 无法解析页面。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;死锁的例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
// oc

@implementation AppDelegate
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 
{
    ClassA* obj = [[ClassA alloc] init];
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        //A线程
        @synchronized(obj) {    //X锁
            sleep(3);
            [obj methodA];   //methodA被JS替换，调用会进JS，请求JSCore的锁
        }
    });

    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        //B线程
        [obj methodA];  //methodA被JS替换，调用会进JS，请求JSCore的锁
    });
}
@end


@implementation ClassA
- (void)methodA
{
}
- (void)methodB
{
    @synchronized(self) {   //X锁
        int a = 0;
    }
}
@end


// js

defineClass(&amp;#39;ClassA&amp;#39;, {
    methodA: function() {
        self.methodB()   //调用到OC，
    },
})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了解决死锁的问题，JSPatch设计了&lt;code&gt;performSelectorInOC&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    __isPerformInOC:1,
    obj:self.__obj,
    clsName:self.__clsName,
    sel: args[0],
    args: args[1],
    cb: args[2]
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;返回obj后，JS调用就结束了。在 OC 可以拿到 JS 函数的返回值，也就拿到了这个对象，然后判断它是否 &lt;code&gt;__isPerformInOC=1&lt;/code&gt; 对象，若是就根据对象里的 selector / 参数等信息调用对应的 OC 方法，这时这个 OC 方法的调用是在 &lt;code&gt;JavaScriptCore&lt;/code&gt; 的锁之外调用的，我们的目的就达到了。&lt;br&gt;执行 OC 方法后，会去调 {obj} 里的的 cb 函数，把 OC 方法的返回值传给 cb 函数，重新回到 JS 去执行代码。这里会循环判断这些回调函数是否还返回 &lt;code&gt;__isPerformInOC=1&lt;/code&gt; 的对象，若是则重复上述流程执行，不是则结束。&lt;/p&gt;
&lt;h3 id=&quot;安全问题&quot;&gt;&lt;a href=&quot;#安全问题&quot; class=&quot;headerlink&quot; title=&quot;安全问题&quot;&gt;&lt;/a&gt;安全问题&lt;/h3&gt;&lt;h4 id=&quot;传输安全&quot;&gt;&lt;a href=&quot;#传输安全&quot; class=&quot;headerlink&quot; title=&quot;传输安全&quot;&gt;&lt;/a&gt;传输安全&lt;/h4&gt;&lt;p&gt;JS 脚本可以调用任意 OC 方法，权限非常大，若被中间人攻击替换代码，会造成较大的危害。&lt;/p&gt;
&lt;p&gt;解决方案 对称加密，HTTPS，RSA校验&lt;/p&gt;
&lt;p&gt;有能力上HTTPS，简单安全用RSA，不推荐对称加密。&lt;/p&gt;
&lt;h4 id=&quot;执行安全&quot;&gt;&lt;a href=&quot;#执行安全&quot; class=&quot;headerlink&quot; title=&quot;执行安全&quot;&gt;&lt;/a&gt;执行安全&lt;/h4&gt;&lt;p&gt;下发的 JS 脚本灵活度大，相当于一次小型更新，若未进行充分测试，可能会出现 crash 等情况对 APP 稳定性造成影响。&lt;/p&gt;
&lt;p&gt;解决方案：灰度，监控，回退&lt;/p&gt;
&lt;p&gt;回退是推荐所有APP都接入，灰度和监控室中大型APP要考虑的&lt;/p&gt;
&lt;h4 id=&quot;对比RN-weex的优势&quot;&gt;&lt;a href=&quot;#对比RN-weex的优势&quot; class=&quot;headerlink&quot; title=&quot;对比RN/weex的优势&quot;&gt;&lt;/a&gt;对比RN/weex的优势&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;小巧。只需引入 JPEngine.h JPEngine.m JSPatch.js 三个小文件，体积小巧，也无需搭建环境。&lt;/li&gt;
&lt;li&gt;学习成本低。可以继续沿用原来 OC 的思维写程序，无需学习新一套规则，即刻上手。&lt;/li&gt;
&lt;li&gt;限制少。可以说完全没有限制，OC / JS 上玩出花的各种模式都可以照搬使用，不会被某一框架思维和写法限定。所有 OC / JS 库直接使用，无需适配。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##个人观点&lt;/p&gt;
&lt;h3 id=&quot;RN-vs-weex&quot;&gt;&lt;a href=&quot;#RN-vs-weex&quot; class=&quot;headerlink&quot; title=&quot;RN vs weex&quot;&gt;&lt;/a&gt;RN vs weex&lt;/h3&gt;&lt;h4 id=&quot;开发APP&quot;&gt;&lt;a href=&quot;#开发APP&quot; class=&quot;headerlink&quot; title=&quot;开发APP&quot;&gt;&lt;/a&gt;开发APP&lt;/h4&gt;&lt;p&gt;RN的优势无疑是国际大厂facebook的鼎力支持和开源社区极高的热情。RN的出生的目的已经决定了他未来的方向：替代Native开发。RN的基础架构设计让RN具有无线的可能，能用Native做到的，RN都能做到。然而，大而全也意味着前进困难，目前RN仍然未发布1.0版本，facebook自身也仅仅在几个用户量较小的APP上使用。Native端兼容问题和性能问题都还没能很好的解决。因此，使用RN开发，目前仅仅适合量级小，功能简单的APP，同时还需要一定量有Web,native段经验的工程师一同踩坑。&lt;/p&gt;
&lt;p&gt;weex是国内大厂阿里的作品，从历史上来看，阿里开源了很多也弃坑了很多，对于weex这个刚开源出来的框架，多数人还是抱着谨慎乐观的态度。从一些公开技术分享上来看，阿里在weex上投入了很多人力，也是因为移动端和web的业务发展导致的。目前weex支持的组件和功能都是非常基础单一的，甚至很多必要的功能都没有实现，社区活跃度不高也导致很多坑可能需要自己慢慢看源码去踩。不过，weex站在RN巨人的肩膀上，丰富的开发工具链，提供了更便捷的调试工具和playGround。目前来看，如果阿里愿意投入更多力量，号召开源社区做贡献，未必不能与RN一较高下。目前来看，weex仅适合用于做非常简单的demo（比如一些套壳H5），还不适合做完整功能的APP。&lt;/p&gt;
&lt;h4 id=&quot;hot-fix&quot;&gt;&lt;a href=&quot;#hot-fix&quot; class=&quot;headerlink&quot; title=&quot;hot fix&quot;&gt;&lt;/a&gt;hot fix&lt;/h4&gt;&lt;p&gt;两个框架都适合做热更新，从这方面看，两者没有优劣区别。两者都只能改变已经实现的部分，不能添加或者修改已经存在的方法。&lt;/p&gt;
&lt;h3 id=&quot;JSPatch-vs-RN-amp-weex&quot;&gt;&lt;a href=&quot;#JSPatch-vs-RN-amp-weex&quot; class=&quot;headerlink&quot; title=&quot;JSPatch vs RN&amp;amp;weex&quot;&gt;&lt;/a&gt;JSPatch vs RN&amp;amp;weex&lt;/h3&gt;&lt;h4 id=&quot;开发APP-1&quot;&gt;&lt;a href=&quot;#开发APP-1&quot; class=&quot;headerlink&quot; title=&quot;开发APP&quot;&gt;&lt;/a&gt;开发APP&lt;/h4&gt;&lt;p&gt;用JSPatch去开发一个APP有没有，有，但是目前我看到的，只有两个开源的小项目。从作者的观点来看，JSPatch可以用来开发一个单独的模块，但是不适合开发一整个APP。毕竟，JSPatch的思路依然是由native的思维用JS来开发，既然如此，不如直接用OC开发更加直接。但由于OC强大无比的runtime，JSPatch可以用于开发一个全新的页面去替代原本使用Native编写的页面，这一点是RN和weex做不到的。&lt;/p&gt;
&lt;h4 id=&quot;hot-patch&quot;&gt;&lt;a href=&quot;#hot-patch&quot; class=&quot;headerlink&quot; title=&quot;hot patch&quot;&gt;&lt;/a&gt;hot patch&lt;/h4&gt;&lt;p&gt;JSPatch的出生就是为了解决iOS发版困难的问题，基于OC的runtime和js的灵活使JSPatch在热修复上比RN/weex强上了一个量级。举两个例子&lt;/p&gt;
&lt;p&gt;一：实现一个没有实现的功能。&lt;/p&gt;
&lt;p&gt;RN/weex都需要实现一个jsBride，就是在native实现好，用js去调用。这样的方式就无法动态的添加方法，比如我们现在七贷做了个微信分享，砍掉了一个拷贝链接的按钮。用JSPatch就可以很快的加回去，不需要发版本，而如果是用RN开发的，Native原本就没有实现这段代码，那就无能为力了。&lt;/p&gt;
&lt;p&gt;二：替换原生的页面&lt;/p&gt;
&lt;p&gt;很多项目本身已经使用Native开发一段时间了，接入RN/weex后也只是局部新页面使用。RN可以开发一整个新功能界面，动态更新到app上，但是这个新功能界面怎么打开呢？办法有一个，app内有一套URLRoute的路由机制，并且辅助以云端可控的路由配置表，那么确实可以改变某些位置原本的界面跳转，从而跳转打开全新的RN界面，实现了新RN界面的动态更新，但是JSPatch就不需要URLRoute这套全局跳转的辅助机制帮忙，JSPatch完全有能力更改任何已经由OC写好的代码，随意的改变跳转到新界面，随意的增加新按钮，不改变旧界面就把新界面打开！&lt;/p&gt;
&lt;h4 id=&quot;内存控制差异&quot;&gt;&lt;a href=&quot;#内存控制差异&quot; class=&quot;headerlink&quot; title=&quot;内存控制差异&quot;&gt;&lt;/a&gt;内存控制差异&lt;/h4&gt;&lt;p&gt;JSPatch在OC和JC交互的时候，将OC对象，界面，Model直接传给JS的上下文，同时OC对象的引用计数会+1，并随着JS的垃圾回收而对这个OC对象进行额外的控制。JS中无法访问这个OC对象，但可以将OC对象的方法发回给OC环境去操作。&lt;/p&gt;
&lt;p&gt;RN在OC与JS交互的时候，是完全不支持传递任何OC对象的，所有能在JS与OC中间传递的，一定是可以被json化，字符化的内容，数字，字典，数组，字符串，所以RN专门有个RCTConvert类去专门处理，json的序列化model化，反序列化反model化。那么RN是如何通过JS去控制一个纯OC的界面View呢?是通过viewTag，JS控制的每一个界面效果，都是传过来一个tag，让native创建，让native修改，native会储存住这些tag到一个hashmap里，这样JS才能够不直接传递OC对象，而是传递一个数字，从而控制OC对象&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;二者的实现差异，是会造成一些底层运行差异的，OC与JS对象只传递JSON其实就保证了，JS上下文的内存与OC上下文的内存完全没有互通，各自的内从各自控制，JS是一套垃圾回收机制，而OC是一套引用计数机制。&lt;/p&gt;
&lt;p&gt;JSPatch将二者进行了互通，这些互通的对象内存管理则是一套，又有引用计数控制，又有JS的垃圾回收，当JS的垃圾回收，并且iOS的引用计数归0，才会销毁。&lt;/p&gt;
&lt;p&gt;这里没有优劣之分，JSPatch在双内存控制机制下，也是可以正常work没有问题的，RN&amp;amp;Weex的这套机制，内存上简单清晰，不过这都是底层实现的问题，上层使用，都是没问题的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##总结&lt;/p&gt;
&lt;p&gt;这里借用JSPatch 作者给出的一个比较。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;框架&lt;/th&gt;
&lt;th&gt;学习成本&lt;/th&gt;
&lt;th&gt;接入成本&lt;/th&gt;
&lt;th&gt;开发效率&lt;/th&gt;
&lt;th&gt;性能体验&lt;/th&gt;
&lt;th&gt;热更新能力&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RN&amp;amp;Weex&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;高，跨平台&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JSPatch&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;中，单一iOS&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;很强&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文是做内部分享的时候整理的知识内容，整理了出来。&lt;/p&gt;
&lt;h2 id=&quot;技术介绍&quot;&gt;&lt;a href=&quot;#技术介绍&quot; class=&quot;headerlink&quot; title=&quot;技术介绍&quot;&gt;&lt;/a&gt;技术介绍&lt;/h2&gt;&lt;h3 id=&quot;Weex&quot;&gt;&lt;a href=&quot;#Weex&quot; cl
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Method Swizzle 与 AOP</title>
    <link href="http://csbzhixing.github.io/2016/08/19/Method%20Swizzle%20%E4%B8%8E%20AOP/"/>
    <id>http://csbzhixing.github.io/2016/08/19/Method Swizzle 与 AOP/</id>
    <published>2016-08-19T15:03:29.000Z</published>
    <updated>2016-08-19T15:17:07.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Method-Swizzle&quot;&gt;&lt;a href=&quot;#Method-Swizzle&quot; class=&quot;headerlink&quot; title=&quot;Method Swizzle&quot;&gt;&lt;/a&gt;Method Swizzle&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Method Swizzle&lt;/code&gt;是基于runtime实现“黑魔法”。&lt;/p&gt;
&lt;p&gt;写这篇主要是源于上周一次项目bug fix。&lt;/p&gt;
&lt;p&gt;项目基于React Native 0.20版本开发，在调用相机拍照后，由于照片自身带有了旋转信息，因此照片在客户看来不是“正的”。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)imagePickerController:(UIImagePickerController *)picker
didFinishPickingMediaWithInfo:(NSDictionary&amp;lt;NSString *, id&amp;gt; *)info
{
  NSString *mediaType = info[UIImagePickerControllerMediaType];
  BOOL isMovie = [mediaType isEqualToString:(NSString *)kUTTypeMovie];
  NSString *key = isMovie ? UIImagePickerControllerMediaURL : UIImagePickerControllerReferenceURL;
  NSURL *imageURL = info[key];
  if (imageURL) {
    [self _dismissPicker:picker args:@[imageURL.absoluteString]];
    return;
  }

  // This is a newly taken image, and doesn&amp;#39;t have a URL yet.
  // We need to save it to the image store first.
  UIImage *originalImage = info[UIImagePickerControllerOriginalImage];

  // WARNING: Using ImageStoreManager may cause a memory leak because the
  // image isn&amp;#39;t automatically removed from store once we&amp;#39;re done using it.
  [_bridge.imageStoreManager storeImage:originalImage withBlock:^(NSString *tempImageTag) {
    [self _dismissPicker:picker args:tempImageTag ? @[tempImageTag] : nil];
  }];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到其实就是需要对&lt;code&gt;originalImage&lt;/code&gt;进行方向修正。&lt;/p&gt;
&lt;p&gt;然后跟踪了RN的实现，发现他是存在应用的临时变量里面，可是用的是CGImage。意味着我们即使取出来了这个Image，也无法获知这个Image的方向信息。当时第一反应是。。我自己来实现一个选择器。。。不过这个工作量略大，而且可能会造成很多不知原因的坑。晚上洗澡的时候，突然想到可以可以通过Method swizzle的方式去实现。&lt;/p&gt;
&lt;p&gt;新建了一个category，在&lt;code&gt;+(void)load&lt;/code&gt;方法的替换了&lt;code&gt;imagePickerController&lt;/code&gt;方法，测试一下，OK。&lt;/p&gt;
&lt;h3 id=&quot;什么时候用&quot;&gt;&lt;a href=&quot;#什么时候用&quot; class=&quot;headerlink&quot; title=&quot;什么时候用&quot;&gt;&lt;/a&gt;什么时候用&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Method Swizzle&lt;/code&gt;是把锋利的刀，用的好，削铁如泥；用的不好，害人害己。&lt;/p&gt;
&lt;p&gt;一般而言，如果能有好的方法解决，不推荐使用&lt;code&gt;Method Swizzle&lt;/code&gt;。原因就是难以跟踪问题。如A实现一个方法&lt;code&gt;run&lt;/code&gt;。一个开发在&lt;code&gt;A(B)&lt;/code&gt;这个category里面替换成了&lt;code&gt;runFast&lt;/code&gt;，而另一个开发在&lt;code&gt;A(C)&lt;/code&gt;里面替换成了&lt;code&gt;runSlow&lt;/code&gt;。那我们调用&lt;code&gt;run&lt;/code&gt;方法的时候到底是什么结果？&lt;/p&gt;
&lt;h3 id=&quot;该怎么用&quot;&gt;&lt;a href=&quot;#该怎么用&quot; class=&quot;headerlink&quot; title=&quot;该怎么用&quot;&gt;&lt;/a&gt;该怎么用&lt;/h3&gt;&lt;p&gt;替换方法应该是在运行时确定唯一的，如果存在多次不确定的&lt;code&gt;Method Swizzle&lt;/code&gt;，我们就无法知道最后获取的IMP来源于来个方法。因此在哪里替换，怎么替换，对于不同类型的方法都不一样。&lt;/p&gt;
&lt;h4 id=&quot;普通实例方法&quot;&gt;&lt;a href=&quot;#普通实例方法&quot; class=&quot;headerlink&quot; title=&quot;普通实例方法&quot;&gt;&lt;/a&gt;普通实例方法&lt;/h4&gt;&lt;p&gt;替换普通实例方法比较简单，创建了一个对应类的分类，在分类中实现&lt;code&gt;+(void)load&lt;/code&gt;方法，在&lt;code&gt;+(void)load&lt;/code&gt;方法中进行替换。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (void)load {
    Class originalClass = NSClassFromString(@&amp;quot;Car&amp;quot;);
    Class swizzledClass = [self class];
    SEL originalSelector = NSSelectorFromString(@&amp;quot;run:&amp;quot;);
    SEL swizzledSelector = @selector(xxx_run:);
    Method originalMethod = class_getInstanceMethod(originalClass, originalSelector);
    Method swizzledMethod = class_getInstanceMethod(swizzledClass, swizzledSelector);

    IMP originalIMP = method_getImplementation(originalMethod);
    IMP swizzledIMP = method_getImplementation(swizzledMethod);
    const char *originalType = method_getTypeEncoding(originalMethod);
    const char *swizzledType = method_getTypeEncoding(swizzledMethod);

    class_replaceMethod(originalClass,swizzledSelector,originalIMP,originalType);
    class_replaceMethod(originalClass,originalSelector,swizzledIMP,swizzledType);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先要知道为何在&lt;code&gt;+(void)load&lt;/code&gt;中实现替换。&lt;code&gt;+(void)load&lt;/code&gt;这个方法首先是在运行时执行，切只执行一次，因此就符合了我们在&lt;code&gt;在程序运行期只执行一次替换&lt;/code&gt;的想法。其次，&lt;code&gt;+(void)load&lt;/code&gt;的执行顺序是&lt;code&gt;父类-&amp;gt;子类-&amp;gt;分类&lt;/code&gt;的顺序，且不覆盖。因此，分类的&lt;code&gt;+(void)load&lt;/code&gt;不会影响类的&lt;code&gt;+(void)load&lt;/code&gt;也是我们正需要的。&lt;/p&gt;
&lt;h4 id=&quot;类方法&quot;&gt;&lt;a href=&quot;#类方法&quot; class=&quot;headerlink&quot; title=&quot;类方法&quot;&gt;&lt;/a&gt;类方法&lt;/h4&gt;&lt;p&gt;实现类方法的实现思路也是一样的，不同的是我们不从实例方法列表中去获取相关方法实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (void)load {
    Class cls = [self class];
    SEL originalSelector = @selector(dictionary);
    SEL swizzledSelector = @selector(xxx_dictionary);

    // 使用class_getClassMethod来获取类方法的Method
    Method originalMethod = class_getClassMethod(cls, originalSelector);
    Method swizzledMethod = class_getClassMethod(cls, swizzledSelector);
    if (!originalMethod || !swizzledMethod) {
        return;
    }

    IMP originalIMP = method_getImplementation(originalMethod);
    IMP swizzledIMP = method_getImplementation(swizzledMethod);
    const char *originalType = method_getTypeEncoding(originalMethod);
    const char *swizzledType = method_getTypeEncoding(swizzledMethod);

    // 类方法添加,需要将方法添加到MetaClass中
    Class metaClass = objc_getMetaClass(class_getName(cls));
    class_replaceMethod(metaClass,originalSelector,swizzledIMP,swizzledType);
    class_replaceMethod(metaClass,swizzledSelector,originalIMP,originalType);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;区别有2点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;class_getClassMethod(Class cls, SEL name)&lt;/code&gt;替换掉&lt;code&gt;class_getInstanceMethod(Class cls, SEL name)&lt;/code&gt;。看得出方法的差异。&lt;/li&gt;
&lt;li&gt;实例方法的内容是记录在class的method list上的，而类方法是记录在meta-class 上的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;修改类簇&quot;&gt;&lt;a href=&quot;#修改类簇&quot; class=&quot;headerlink&quot; title=&quot;修改类簇&quot;&gt;&lt;/a&gt;修改类簇&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;+ (void)load {
    Class originalClass = NSClassFromString(@&amp;quot;__NSDictionaryM&amp;quot;);
    Class swizzledClass = [self class];
    SEL originalSelector = @selector(setObject:forKey:);
    SEL swizzledSelector = @selector(safe_setObject:forKey:);
    Method originalMethod = class_getInstanceMethod(originalClass, originalSelector);
    Method swizzledMethod = class_getInstanceMethod(swizzledClass, swizzledSelector);

    IMP originalIMP = method_getImplementation(originalMethod);
    IMP swizzledIMP = method_getImplementation(swizzledMethod);
    const char *originalType = method_getTypeEncoding(originalMethod);
    const char *swizzledType = method_getTypeEncoding(swizzledMethod);

    class_replaceMethod(originalClass,swizzledSelector,originalIMP,originalType);
    class_replaceMethod(originalClass,originalSelector,swizzledIMP,swizzledType);
}

- (void)safe_setObject:(id)anObject forKey:(id&amp;lt;NSCopying&amp;gt;)aKey {
    if (anObject &amp;amp;&amp;amp; aKey) {
        [self safe_setObject:anObject forKey:aKey];
    }
    else if (aKey) {
        [(NSMutableDictionary *)self removeObjectForKey:aKey];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/ClassCluster.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;&lt;br&gt;中详细讲解了什么是类簇。这里我们替换的是&lt;code&gt;__NSDictionaryM&lt;/code&gt;中对应的&lt;code&gt;setObject:forKey:&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;AOP-和-Method-Swizzle&quot;&gt;&lt;a href=&quot;#AOP-和-Method-Swizzle&quot; class=&quot;headerlink&quot; title=&quot;AOP 和 Method Swizzle&quot;&gt;&lt;/a&gt;AOP 和 Method Swizzle&lt;/h2&gt;&lt;p&gt;有一定开发经验的人一定听说过AOP。用一句个人觉得比较经典的话来概括&lt;code&gt;这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程&lt;/code&gt;。这里来看，通过Method Swizzle正好来实现AOP。在这方面，github上有一个实现非常好的开源库&lt;a href=&quot;https://github.com/steipete/Aspects&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Aspects&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里的话，会用它来做一下分析，怎么去实现AOP。&lt;/p&gt;
&lt;h3 id=&quot;功能分析&quot;&gt;&lt;a href=&quot;#功能分析&quot; class=&quot;headerlink&quot; title=&quot;功能分析&quot;&gt;&lt;/a&gt;功能分析&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Aspects&lt;/code&gt;这个库实现了AOP,那么实现到什么地步，能做到什么样的功能，可以从头文件定义中略知一二&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef NS_OPTIONS(NSUInteger, AspectOptions) {
    AspectPositionAfter   = 0,            /// Called after the original implementation (default)
    AspectPositionInstead = 1,            /// Will replace the original implementation.
    AspectPositionBefore  = 2,            /// Called before the original implementation.

    AspectOptionAutomaticRemoval = 1 &amp;lt;&amp;lt; 3 /// Will remove the hook after the first execution.
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;定义了&lt;code&gt;AspectOptions&lt;/code&gt;，从名字看出，分别可以做到将新方法插入到老方法之前/之后，替换原有的方法，仅在第一次替换原来的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@protocol AspectToken &amp;lt;NSObject&amp;gt;

/// Deregisters an aspect.
/// @return YES if deregistration is successful, otherwise NO.
- (BOOL)remove;

@end

/// The AspectInfo protocol is the first parameter of our block syntax.
@protocol AspectInfo &amp;lt;NSObject&amp;gt;

/// The instance that is currently hooked.
- (id)instance;

/// The original invocation of the hooked method.
- (NSInvocation *)originalInvocation;

/// All method arguments, boxed. This is lazily evaluated.
- (NSArray *)arguments;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;两个协议，实现后可以实现撤销插入/ 获得插入的实例信息，原有方法内容和参数列表。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface NSObject (Aspects)

/// Adds a block of code before/instead/after the current `selector` for a specific class.
///
/// @param block Aspects replicates the type signature of the method being hooked.
/// The first parameter will be `id&amp;lt;AspectInfo&amp;gt;`, followed by all parameters of the method.
/// These parameters are optional and will be filled to match the block signature.
/// You can even use an empty block, or one that simple gets `id&amp;lt;AspectInfo&amp;gt;`.
///
/// @note Hooking static methods is not supported.
/// @return A token which allows to later deregister the aspect.
+ (id&amp;lt;AspectToken&amp;gt;)aspect_hookSelector:(SEL)selector
                           withOptions:(AspectOptions)options
                            usingBlock:(id)block
                                 error:(NSError **)error;

/// Adds a block of code before/instead/after the current `selector` for a specific instance.
- (id&amp;lt;AspectToken&amp;gt;)aspect_hookSelector:(SEL)selector
                           withOptions:(AspectOptions)options
                            usingBlock:(id)block
                                 error:(NSError **)error;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对NSObject定义了一个分类，只要两个方法，分别是对类方法和实例方法的操作。&lt;/p&gt;
&lt;p&gt;可以看到，Aspect的实现功能还是很强大的。在提供基本Method swizzle的基础上还实现了对不同插入位置的功能，提供可撤回的替换。&lt;/p&gt;
&lt;h3 id=&quot;实现细节&quot;&gt;&lt;a href=&quot;#实现细节&quot; class=&quot;headerlink&quot; title=&quot;实现细节&quot;&gt;&lt;/a&gt;实现细节&lt;/h3&gt;&lt;p&gt;在自己实现&lt;code&gt;Method Swizzle&lt;/code&gt;的时候，我们也会考虑到，如果我需要恢复被替换的方法怎么做？如果我仅仅想在某个方法执行前或执行后执行一个方法呢？比如我需要在所有的&lt;code&gt;viewDidLoad&lt;/code&gt;中插入一个log语句，这时候用&lt;code&gt;Method Swizzle&lt;/code&gt;显然是不合适，而&lt;code&gt;Aspect&lt;/code&gt;能做到的，也是让我们好奇的，来看看具体的实现方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (id&amp;lt;AspectToken&amp;gt;)aspect_hookSelector:(SEL)selector
                      withOptions:(AspectOptions)options
                       usingBlock:(id)block
                            error:(NSError **)error {
    return aspect_add((id)self, selector, options, block, error);
}

/// @return A token which allows to later deregister the aspect.
- (id&amp;lt;AspectToken&amp;gt;)aspect_hookSelector:(SEL)selector
                      withOptions:(AspectOptions)options
                       usingBlock:(id)block
                            error:(NSError **)error {
    return aspect_add(self, selector, options, block, error);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;两个公开API进来后都是调用&lt;code&gt;static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error)&lt;/code&gt;这个静态方法，区别就是对类方法中替换要在self前用id修饰。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) {
    NSCParameterAssert(self);
    NSCParameterAssert(selector);
    NSCParameterAssert(block);

    __block AspectIdentifier *identifier = nil;
    aspect_performLocked(^{
        if (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) {
            AspectsContainer *aspectContainer = aspect_getContainerForObject(self, selector);
            identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error];
            if (identifier) {
                [aspectContainer addAspect:identifier withOptions:options];

                // Modify the class to allow message interception.
                aspect_prepareClassAndHookSelector(self, selector, error);
            }
        }
    });
    return identifier;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法中首先定义了一个&lt;code&gt;AspectIdentifier&lt;/code&gt;类型的实例变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface AspectIdentifier : NSObject
+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error;
- (BOOL)invokeWithInfo:(id&amp;lt;AspectInfo&amp;gt;)info;
@property (nonatomic, assign) SEL selector;
@property (nonatomic, strong) id block;
@property (nonatomic, strong) NSMethodSignature *blockSignature;
@property (nonatomic, weak) id object;
@property (nonatomic, assign) AspectOptions options;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到这个类的定义就是对Aspect定义的。&lt;/p&gt;
&lt;p&gt;随后执行&lt;code&gt;aspect_performLocked&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    static void aspect_performLocked(dispatch_block_t block) {
    static OSSpinLock aspect_lock = OS_SPINLOCK_INIT;
    OSSpinLockLock(&amp;amp;aspect_lock);
    block();
    OSSpinLockUnlock(&amp;amp;aspect_lock);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法中创建了一个&lt;code&gt;OSSpinLockLock&lt;/code&gt;自旋锁，对block执行进行保护。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;自旋锁是在多处理器系统(SMP)上为保护一段关键代码的执行或者关键数据的一种保护机制，是实现synchronization的一种手段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;传入的block中，首先先执行&lt;code&gt;aspect_isSelectorAllowedAndTrack&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;aspect_isSelectorAllowedAndTrack&lt;/code&gt;比较长，从字面含义上来讲就是是否允许插入和追踪。&lt;/p&gt;
&lt;p&gt;代码就不贴了。。简单说下思路。&lt;/p&gt;
&lt;p&gt;我们知道有些方法是无法被替换的，有些hook的方法对插入的位置很敏感(好像很污的感觉)。这个方法就是对这些黑名单进行判断&lt;/p&gt;
&lt;p&gt;首先是不能替换的，有&lt;code&gt;release&lt;/code&gt;,&lt;code&gt;retain&lt;/code&gt;,&lt;code&gt;autorelease&lt;/code&gt;,&lt;code&gt;forwardInvocation&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;只能在添加block到hook方法前的：&lt;code&gt;dealloc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;被hook的类响应SEL的。。。喂你再去检查下好吧&lt;/p&gt;
&lt;p&gt;接下来被hook的是不是元类，如果不是的话就可以愉快的返回YES啦。&lt;/p&gt;
&lt;p&gt;如果是元类。。稍微麻烦点。梳理一下逻辑如下&lt;/p&gt;
&lt;p&gt;&lt;code&gt;swizzledClassesDict&lt;/code&gt;是一个dictionary，里面存放的已经是以当前类为key，以&lt;code&gt;AspectTracker&lt;/code&gt;为value的键值对。&lt;code&gt;AspectTracker&lt;/code&gt;定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface AspectTracker : NSObject
- (id)initWithTrackedClass:(Class)trackedClass;
@property (nonatomic, strong) Class trackedClass;
@property (nonatomic, readonly) NSString *trackedClassName;
@property (nonatomic, strong) NSMutableSet *selectorNames;
@property (nonatomic, strong) NSMutableDictionary *selectorNamesToSubclassTrackers;
- (void)addSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName;
- (void)removeSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName;
- (BOOL)subclassHasHookedSelectorName:(NSString *)selectorName;
- (NSSet *)subclassTrackersHookingSelectorName:(NSString *)selectorName;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;意义如名字一样，实现的是一个跟踪对象。这个对象里面存放了跟踪的类，类的名字，选择器的名称已经子类跟踪对象的选择器。&lt;/p&gt;
&lt;p&gt;获得&lt;code&gt;tracker&lt;/code&gt;后，判断是否已经hook了子类的相同选择器方法，注意只能在继承链上hook一次相同选择器的方法。&lt;/p&gt;
&lt;p&gt;随后递归父类，查看是否在继承链上已经hook过了。&lt;/p&gt;
&lt;p&gt;如果上述过程都能顺利进行下来的话，说明可以hook啦，这时候递归父类，将selector添加到tracker里面。&lt;/p&gt;
&lt;p&gt;回到上面的&lt;code&gt;aspect_performLocked&lt;/code&gt;中，这时候我们得知是能hook啦，这时候根据传进来的&lt;code&gt;self&lt;/code&gt;和&lt;code&gt;selector&lt;/code&gt;创建一个&lt;code&gt;AspectsContainer&lt;/code&gt;。&lt;code&gt;AspectsContainer&lt;/code&gt;的定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface AspectsContainer : NSObject
- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;
- (BOOL)removeAspect:(id)aspect;
- (BOOL)hasAspects;
@property (atomic, copy) NSArray *beforeAspects;
@property (atomic, copy) NSArray *insteadAspects;
@property (atomic, copy) NSArray *afterAspects;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里有三个属性，都是array类型，从名字不难看到，存的是hook前，被hook的，hook后的。&lt;/p&gt;
&lt;p&gt;创建&lt;code&gt;AspectsContainer&lt;/code&gt;之后，对&lt;code&gt;identifier&lt;/code&gt;初始化，如果成功初始化，向&lt;code&gt;AspectsContainer&lt;/code&gt;添加&lt;code&gt;identifier&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)options {
    NSParameterAssert(aspect);
    NSUInteger position = options&amp;amp;AspectPositionFilter;
    switch (position) {
        case AspectPositionBefore:  self.beforeAspects  = [(self.beforeAspects ?:@[]) arrayByAddingObject:aspect]; break;
        case AspectPositionInstead: self.insteadAspects = [(self.insteadAspects?:@[]) arrayByAddingObject:aspect]; break;
        case AspectPositionAfter:   self.afterAspects   = [(self.afterAspects  ?:@[]) arrayByAddingObject:aspect]; break;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;判断option，将&lt;code&gt;AspectIdentifier&lt;/code&gt;添加到对应的array&lt;/p&gt;
&lt;p&gt;最后，执行&lt;code&gt;aspect_prepareClassAndHookSelector&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;aspect_prepareClassAndHookSelector&lt;/code&gt;是整个&lt;code&gt;Aspect&lt;/code&gt;里面最核心的部分了，前面的行为都是判断是否能hook和做相应的缓存操作，在这里才是真正的执行hook的地方。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) {
    NSCParameterAssert(selector);
    Class klass = aspect_hookClass(self, error);
    Method targetMethod = class_getInstanceMethod(klass, selector);
    IMP targetMethodIMP = method_getImplementation(targetMethod);
    if (!aspect_isMsgForwardIMP(targetMethodIMP)) {
        // Make a method alias for the existing method implementation, it not already copied.
        const char *typeEncoding = method_getTypeEncoding(targetMethod);
        SEL aliasSelector = aspect_aliasForSelector(selector);
        if (![klass instancesRespondToSelector:aliasSelector]) {
            __unused BOOL addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);
            NSCAssert(addedAlias, @&amp;quot;Original implementation for %@ is already copied to %@ on %@&amp;quot;, NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), klass);
        }

        // We use forwardInvocation to hook in.
        class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding);
        AspectLog(@&amp;quot;Aspects: Installed hook for -[%@ %@].&amp;quot;, klass, NSStringFromSelector(selector));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;思路和我们自己动手实现&lt;code&gt;Method Swizzle&lt;/code&gt;是差不多的，过程也是获取到被hook的class，然后通过&lt;code&gt;selector&lt;/code&gt;获取到指定函数指针&lt;code&gt;IMP&lt;/code&gt;。然后将传入的方法(block)替换掉&lt;code&gt;IMP&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;首先执行的是一个&lt;code&gt;aspect_hookClass&lt;/code&gt;方法，返回一个Class对象。&lt;/p&gt;
&lt;p&gt;整体的思路如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class statedClass = self.class;
    Class baseClass = object_getClass(self);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果对runtime不熟悉的人可能不知道这两者的有什么不同。简单的说，&lt;code&gt;self.class&lt;/code&gt;返回的是这个Object&lt;br&gt;所属的类，而&lt;code&gt;object_getClass&lt;/code&gt;返回的是这个Object的元类，也就是类对象的类（很绕口）。接下来，就来判断元类是否被修改过（元类的类名被添加了特有的后缀），如果没有修改过，将对象的类进行hook：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void _aspect_modifySwizzledClasses(void (^block)(NSMutableSet *swizzledClasses)) {
    static NSMutableSet *swizzledClasses;
    static dispatch_once_t pred;
    dispatch_once(&amp;amp;pred, ^{
        swizzledClasses = [NSMutableSet new];
    });
    @synchronized(swizzledClasses) {
        block(swizzledClasses);
    }
}

static Class aspect_swizzleClassInPlace(Class klass) {
    NSCParameterAssert(klass);
    NSString *className = NSStringFromClass(klass);

    _aspect_modifySwizzledClasses(^(NSMutableSet *swizzledClasses) {
        if (![swizzledClasses containsObject:className]) {
            aspect_swizzleForwardInvocation(klass);
            [swizzledClasses addObject:className];
        }
    });
    return klass;
}

static NSString *const AspectsForwardInvocationSelectorName = @&amp;quot;__aspects_forwardInvocation:&amp;quot;;
static void aspect_swizzleForwardInvocation(Class klass) {
    NSCParameterAssert(klass);
    // If there is no method, replace will act like class_addMethod.
    IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, &amp;quot;v@:@&amp;quot;);
    if (originalImplementation) {
        class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, &amp;quot;v@:@&amp;quot;);
    }
    AspectLog(@&amp;quot;Aspects: %@ is now aspect aware.&amp;quot;, NSStringFromClass(klass));
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;理解起来不困难，用一个mutableSet存储类名，如果&lt;code&gt;swizzledClasses&lt;/code&gt;不在set里面的话，执行&lt;code&gt;aspect_swizzleForwardInvocation&lt;/code&gt;。这个方法就是替换&lt;code&gt;forwardInvocation&lt;/code&gt;这方法，目的是替换掉&lt;code&gt;forwardInvocation&lt;/code&gt;方法转发，采用自定以的&lt;code&gt;__aspects_forwardInvocation&lt;/code&gt;&lt;br&gt;核心就是下面两句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, &amp;quot;v@:@&amp;quot;);
    if (originalImplementation) {
        class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, &amp;quot;v@:@&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;__ASPECTS_ARE_BEING_CALLED__&lt;/code&gt;是最关键的方法，这个方法就是决定我们要替换的方法如何执行的地方。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void __ASPECTS_ARE_BEING_CALLED__(__unsafe_unretained NSObject *self, SEL selector, NSInvocation *invocation) {
    NSCParameterAssert(self);
    NSCParameterAssert(invocation);
    SEL originalSelector = invocation.selector;
    SEL aliasSelector = aspect_aliasForSelector(invocation.selector);
    invocation.selector = aliasSelector;
    AspectsContainer *objectContainer = objc_getAssociatedObject(self, aliasSelector);
    AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(self), aliasSelector);
    AspectInfo *info = [[AspectInfo alloc] initWithInstance:self invocation:invocation];
    NSArray *aspectsToRemove = nil;

    // Before hooks.
    aspect_invoke(classContainer.beforeAspects, info);
    aspect_invoke(objectContainer.beforeAspects, info);

    // Instead hooks.
    BOOL respondsToAlias = YES;
    if (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) {
        aspect_invoke(classContainer.insteadAspects, info);
        aspect_invoke(objectContainer.insteadAspects, info);
    }else {
        Class klass = object_getClass(invocation.target);
        do {
            if ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) {
                [invocation invoke];
                break;
            }
        }while (!respondsToAlias &amp;amp;&amp;amp; (klass = class_getSuperclass(klass)));
    }

    // After hooks.
    aspect_invoke(classContainer.afterAspects, info);
    aspect_invoke(objectContainer.afterAspects, info);

    // If no hooks are installed, call original implementation (usually to throw an exception)
    if (!respondsToAlias) {
        invocation.selector = originalSelector;
        SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName);
        if ([self respondsToSelector:originalForwardInvocationSEL]) {
            ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation);
        }else {
            [self doesNotRecognizeSelector:invocation.selector];
        }
    }

    // Remove any hooks that are queued for deregistration.
    [aspectsToRemove makeObjectsPerformSelector:@selector(remove)];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个方法里，实际上替换的就是&lt;code&gt;forwardInvocation:&lt;/code&gt;这个runtime方法，自造了一个调用方法。&lt;br&gt;目的就是从原有方法和hook方法去做处理。&lt;/p&gt;
&lt;p&gt;过程就是先用临时变量获取&lt;code&gt;invocation&lt;/code&gt;的seletor，将&lt;code&gt;invocation&lt;/code&gt;的selecor替换成aliasSelector。通过传入的参数构造&lt;code&gt;AspectInfo&lt;/code&gt;。取得&lt;code&gt;objectContainer&lt;/code&gt;和&lt;code&gt;classContainer&lt;/code&gt;（都是&lt;code&gt;AspectsContainer&lt;/code&gt;）类型的。调用&lt;code&gt;aspect_invoke&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;aspect_invoke&lt;/code&gt;是一个宏方法（其实这里也不用写成宏）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define aspect_invoke(aspects, info) \
for (AspectIdentifier *aspect in aspects) {\
    [aspect invokeWithInfo:info];\
    if (aspect.options &amp;amp; AspectOptionAutomaticRemoval) { \
        aspectsToRemove = [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \
    } \
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用了&lt;code&gt;invokeWithInfo&lt;/code&gt;判断aspect的option，如果需要一出，就讲他从对应的container中移除。&lt;br&gt;&lt;code&gt;invokeWithInfo&lt;/code&gt;的方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (BOOL)invokeWithInfo:(id&amp;lt;AspectInfo&amp;gt;)info {
    NSInvocation *blockInvocation = [NSInvocation invocationWithMethodSignature:self.blockSignature];
    NSInvocation *originalInvocation = info.originalInvocation;
    NSUInteger numberOfArguments = self.blockSignature.numberOfArguments;

    // Be extra paranoid. We already check that on hook registration.
    if (numberOfArguments &amp;gt; originalInvocation.methodSignature.numberOfArguments) {
        AspectLogError(@&amp;quot;Block has too many arguments. Not calling %@&amp;quot;, info);
        return NO;
    }

    // The `self` of the block will be the AspectInfo. Optional.
    if (numberOfArguments &amp;gt; 1) {
        [blockInvocation setArgument:&amp;amp;info atIndex:1];
    }

    void *argBuf = NULL;
    for (NSUInteger idx = 2; idx &amp;lt; numberOfArguments; idx++) {
        const char *type = [originalInvocation.methodSignature getArgumentTypeAtIndex:idx];
        NSUInteger argSize;
        NSGetSizeAndAlignment(type, &amp;amp;argSize, NULL);

        if (!(argBuf = reallocf(argBuf, argSize))) {
            AspectLogError(@&amp;quot;Failed to allocate memory for block invocation.&amp;quot;);
            return NO;
        }

        [originalInvocation getArgument:argBuf atIndex:idx];
        [blockInvocation setArgument:argBuf atIndex:idx];
    }

    [blockInvocation invokeWithTarget:self.block];

    if (argBuf != NULL) {
        free(argBuf);
    }
    return YES;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个部分就是从原有方法中取出参数列表赋给block，在这过程总检查是否block不符合原来方法。将&lt;code&gt;self.block&lt;/code&gt;设为&lt;code&gt;blockInvocation&lt;/code&gt;的target。&lt;/p&gt;
&lt;p&gt;回到&lt;code&gt;aspect_hookClass&lt;/code&gt;，在上面特殊情况处理之后，就是一般情况，这时候创建动态子类，类名以&lt;code&gt;AspectsSubclassSuffix&lt;/code&gt;为指定后缀。&lt;code&gt;aspect_hookedGetClass&lt;/code&gt;中替换掉&lt;code&gt;Class&lt;/code&gt;方法，使其返回的是&lt;code&gt;statedClass(被hook的类)&lt;/code&gt;，这里将动态生成的子类的&lt;code&gt;Class&lt;/code&gt;和&lt;code&gt;Meta Class&lt;/code&gt;都替换成&lt;code&gt;statedClass&lt;/code&gt;，最后将&lt;code&gt;subclass&lt;/code&gt;注册进去，最后将&lt;code&gt;subclass&lt;/code&gt;设置成&lt;code&gt;self&lt;/code&gt;的类。这样就完成了hook的过程，&lt;code&gt;self&lt;/code&gt;执行的方法和信息都被我们hook到了。&lt;/p&gt;
&lt;p&gt;回到&lt;code&gt;aspect_prepareClassAndHookSelector&lt;/code&gt;（感觉从很深的子树回来真的很不容易），接下来我们获得了我们要hook的&lt;code&gt;Method&lt;/code&gt;和&lt;code&gt;IMP&lt;/code&gt;,我们要判断是否有对应的IMP&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static BOOL aspect_isMsgForwardIMP(IMP impl) {
    return impl == _objc_msgForward
#if !defined(__arm64__)
    || impl == (IMP)_objc_msgForward_stret
#endif
    ;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;_objc_msgForward_stret&lt;/code&gt;和&lt;code&gt;_objc_msgForward&lt;/code&gt;的区别在&lt;a href=&quot;http://sealiesoftware.com/blog/archive/2008/10/30/objc_explain_objc_msgSend_stret.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;里面有讲解，简单的引用JSPatch作者的解释&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大多数CPU在执行C函数时会把前几个参数放进寄存器里，对 obj_msgSend 来说前两个参数固定是 self / _cmd，它们会放在寄存器上，在最后执行完后返回值也会保存在寄存器上，取这个寄存器的值就是返回值。普通的返回值(int/pointer)很小，放在寄存器上没问题，但有些 struct 是很大的，寄存器放不下，所以要用另一种方式，在一开始申请一段内存，把指针保存在寄存器上，返回值往这个指针指向的内存写数据，所以寄存器要腾出一个位置放这个指针，self / _cmd 在寄存器的位置就变了。objc_msgSend 不知道 self / _cmd 的位置变了，所以要用另一个方法 objc_msgSend_stret 代替。原理大概就是这样。在 NSMethodSignature 的 debugDescription 上打出了是否 special struct，只能通过这字符串判断。所以最终的处理是，在非 arm64 下，是 special struct 就走 _objc_msgForward_stret，否则走 _objc_msgForward。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里如果IMP == _objc_msgForward，说明找不到 class / selector 对应的 IMP，如果能找到的话，我们就可以进行下一步了。&lt;/p&gt;
&lt;p&gt;首先要创建一个&lt;code&gt;aliasSelector&lt;/code&gt;选择器，用这个选择器去添加&lt;code&gt;targetMethod&lt;/code&gt;对应的&lt;code&gt;IMP&lt;/code&gt;。这个目的么，自然是保存下来将要被替换方法的实现。&lt;/p&gt;
&lt;p&gt;接下来，&lt;code&gt;class_replaceMethod&lt;/code&gt;替换掉我们需要hook的方法，使用了&lt;code&gt;aspect_getMsgForwardIMP&lt;/code&gt;如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static IMP aspect_getMsgForwardIMP(NSObject *self, SEL selector) {
    IMP msgForwardIMP = _objc_msgForward;
#if !defined(__arm64__)
    // As an ugly internal runtime implementation detail in the 32bit runtime, we need to determine of the method we hook returns a struct or anything larger than id.
    // https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/LowLevelABI/000-Introduction/introduction.html
    // https://github.com/ReactiveCocoa/ReactiveCocoa/issues/783
    // http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/IHI0042E_aapcs.pdf (Section 5.4)
    Method method = class_getInstanceMethod(self.class, selector);
    const char *encoding = method_getTypeEncoding(method);
    BOOL methodReturnsStructValue = encoding[0] == _C_STRUCT_B;
    if (methodReturnsStructValue) {
        @try {
            NSUInteger valueSize = 0;
            NSGetSizeAndAlignment(encoding, &amp;amp;valueSize, NULL);

            if (valueSize == 1 || valueSize == 2 || valueSize == 4 || valueSize == 8) {
                methodReturnsStructValue = NO;
            }
        } @catch (__unused NSException *e) {}
    }
    if (methodReturnsStructValue) {
        msgForwardIMP = (IMP)_objc_msgForward_stret;
    }
#endif
    return msgForwardIMP;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里对arm64做了特殊处理，原因就是上文提到实现问题，对返回的struct做特殊的处理。&lt;/p&gt;
&lt;p&gt;至此，整个hook的过程就结束了，我们已经将需要hook的方法替换成了我们需要的实现。&lt;/p&gt;
&lt;h3 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h3&gt;&lt;p&gt;写完后才发现整个思路虽然很清晰，但是跨越很大，如果去处理这个hook的类和方法需要做许多判断，然后将原有的类和方法的信息保存下来，以便于恢复，最后通过&lt;code&gt;class_replaceMethod&lt;/code&gt;的方法替换掉了&lt;code&gt;forwardInvocation:&lt;/code&gt;。这样通过实现了最后消息转发过程中hook，执行我们注入的方法了。&lt;/p&gt;
&lt;p&gt;至于恢复被hook的方法，思路也很简单了，从cache中获取origin method，替换掉hook方法就行了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Aspect&lt;/code&gt;的实现是基于对runtime强大的理解，通过hook&lt;code&gt;forwardInvocation&lt;/code&gt;方法，做到了对消息转发的改变，任何对象不能处理的方法最后都会到&lt;code&gt;forwardInvovation&lt;/code&gt;中，在这里我们能执行hook的方法和选择执行的时间，也达到了&lt;code&gt;AOP&lt;/code&gt;的思想。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Method Swizzle&lt;/code&gt;也好，&lt;code&gt;Aspect&lt;/code&gt;也好，都是依赖对runtime的认识理解，尤其是&lt;code&gt;Aspect&lt;/code&gt;，在学习代码的过程也增长了自己对语言的认知和理解。&lt;/p&gt;
&lt;p&gt;在此，项目中也用上了&lt;code&gt;JSPatch&lt;/code&gt;，试想如果结合&lt;code&gt;Aspect&lt;/code&gt;，通过runtime强大的功能，我们几乎能做到任何时间(坏坏的事情不要想哦)。未来如果有很好的用例，也会分享出来。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Method-Swizzle&quot;&gt;&lt;a href=&quot;#Method-Swizzle&quot; class=&quot;headerlink&quot; title=&quot;Method Swizzle&quot;&gt;&lt;/a&gt;Method Swizzle&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Method Swizzle&lt;/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>用GCD来实现个Timer</title>
    <link href="http://csbzhixing.github.io/2016/08/15/%E7%94%A8GCD%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%B8%AATimer/"/>
    <id>http://csbzhixing.github.io/2016/08/15/用GCD来实现个Timer/</id>
    <published>2016-08-14T16:04:39.000Z</published>
    <updated>2016-08-14T16:07:37.000Z</updated>
    
    <content type="html">&lt;p&gt;##少用NSTimer&lt;/p&gt;
&lt;p&gt;在iOS中开发中，定时器是经常用到的工具。一般情况下，我们都会去使用&lt;code&gt;NSTimer&lt;/code&gt;这个类。然而，这个类一旦使用不当的话，会给我们造成很多无法预见的坑。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSTimer&lt;/code&gt;有哪些坑，一个个来数一数&lt;/p&gt;
&lt;h3 id=&quot;Timer必须作用在一个运行中的runloop&quot;&gt;&lt;a href=&quot;#Timer必须作用在一个运行中的runloop&quot; class=&quot;headerlink&quot; title=&quot;Timer必须作用在一个运行中的runloop&quot;&gt;&lt;/a&gt;Timer必须作用在一个运行中的&lt;code&gt;runloop&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;用过&lt;code&gt;NSTimer&lt;/code&gt;的都知道，在创建了&lt;code&gt;NSTimer&lt;/code&gt;之后，必须将NSTimer加入到runloop中。如果是在主线程的还好，因为主线程默认是有runLoop的（实际上一般很少会在主线程开timer）。如果是在子线程，那么就要手动激活runLoop先，不然就调用时无效的。&lt;/p&gt;
&lt;h3 id=&quot;操作必须在同一个线程中&quot;&gt;&lt;a href=&quot;#操作必须在同一个线程中&quot; class=&quot;headerlink&quot; title=&quot;操作必须在同一个线程中&quot;&gt;&lt;/a&gt;操作必须在同一个线程中&lt;/h3&gt;&lt;p&gt;NSTimer的创建与撤销必须在同一个线程操作、performSelector的创建与撤销必须在同一个线程操作&lt;/p&gt;
&lt;h3 id=&quot;内存泄漏&quot;&gt;&lt;a href=&quot;#内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏&quot;&gt;&lt;/a&gt;内存泄漏&lt;/h3&gt;&lt;p&gt;一般用NSTimer最容易出现的问题。首先来分析为什么会出现这个情况。&lt;/p&gt;
&lt;p&gt;通常，我们创建一个&lt;code&gt;NSTimer&lt;/code&gt;的方法是调用以下的API：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;
+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;

- (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)ti target:(id)t selector:(SEL)s userInfo:(nullable id)ui repeats:(BOOL)rep NS_DESIGNATED_INITIALIZER;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个时候，target会被timer持有，引用计数+1。&lt;/p&gt;
&lt;p&gt;此时，如果直接销毁target，即使在target的deallco里面调用了[timer invaild]也无用。因为timer和target相关，因此必须提前调用[timer invaild]。这种BUG最常见的的就是一个&lt;code&gt;UIViewController&lt;/code&gt;pop的时候，timer没有被invaild，结果&lt;code&gt;UIViewController&lt;/code&gt;没有被销毁，导致了内存泄漏。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This method is the only way to remove a timer from an NSRunLoop object. The NSRunLoop object removes its strong reference to the timer, either just before the invalidate method returns or at some later point.&lt;/p&gt;
&lt;p&gt;If it was configured with target and user info objects, the receiver removes its strong references to those objects as well.&lt;br&gt;You must send this message from the thread on which the timer was installed. If you send this message from another thread, the input source associated with the timer may not be removed from its run loop, which could prevent the thread from exiting properly.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意到官方文档中提到，runLoop会持有NSTimer的引用，因此除了调用&lt;code&gt;invaild&lt;/code&gt;方法外，没有别的方法.&lt;/p&gt;
&lt;p&gt;##用GCD代替NSTimer&lt;/p&gt;
&lt;p&gt;用过GCD的都说好，可以说把GCD玩的很溜的话，很多异步并行问题都能解决，在这里我们就要去解决NSTimer的坑的问题。这里用三个开源库来抛砖引玉，讲讲不同的实现由什么优缺点。&lt;/p&gt;
&lt;p&gt;###RNTimer&lt;/p&gt;
&lt;p&gt;这个库很老了，12年后就没有更新了，内容也很简单，只有两个文件，因为代码很少，直接上源码了&lt;/p&gt;
&lt;h4 id=&quot;源码摘要&quot;&gt;&lt;a href=&quot;#源码摘要&quot; class=&quot;headerlink&quot; title=&quot;源码摘要&quot;&gt;&lt;/a&gt;源码摘要&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;Objective-C&quot;&gt;
@interface RNTimer : NSObject

/**---------------------------------------------------------------------------------------
 @name Creating a Timer
 -----------------------------------------------------------------------------------------
*/

/** Creates and returns a new repeating RNTimer object and starts running it

 After `seconds` seconds have elapsed, the timer fires, executing the block.
 You will generally need to use a weakSelf pointer to avoid a retain loop.
 The timer is attached to the main GCD queue.

 @param seconds The number of seconds between firings of the timer. Must be greater than 0.
 @param block Block to execute. Must be non-nil

 @return A new RNTimer object, configured according to the specified parameters.
*/
+ (RNTimer *)repeatingTimerWithTimeInterval:(NSTimeInterval)seconds block:(dispatch_block_t)block;


/**---------------------------------------------------------------------------------------
 @name Firing a Timer
 -----------------------------------------------------------------------------------------
*/

/** Causes the block to be executed.

 This does not modify the timer. It will still fire on schedule.
*/
- (void)fire;


/**---------------------------------------------------------------------------------------
 @name Stopping a Timer
 -----------------------------------------------------------------------------------------
*/

/** Stops the receiver from ever firing again

 Once invalidated, a timer cannot be reused.

*/


@interface RNTimer ()
@property (nonatomic, readwrite, copy) dispatch_block_t block;
@property (nonatomic, readwrite, assign) dispatch_source_t source;
@end

@implementation RNTimer
@synthesize block = _block;
@synthesize source = _source;

+ (RNTimer *)repeatingTimerWithTimeInterval:(NSTimeInterval)seconds
                                                                            block:(void (^)(void))block {
    NSParameterAssert(seconds);
    NSParameterAssert(block);

    RNTimer *timer = [[self alloc] init];
    timer.block = block;
    timer.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,
                                                                                0, 0,
                                                                                dispatch_get_main_queue());
    uint64_t nsec = (uint64_t)(seconds * NSEC_PER_SEC);
    dispatch_source_set_timer(timer.source,
                                                        dispatch_time(DISPATCH_TIME_NOW, nsec),
                                                        nsec, 0);
    dispatch_source_set_event_handler(timer.source, block);
    dispatch_resume(timer.source);
    return timer;
}

- (void)invalidate {
    if (self.source) {
        dispatch_source_cancel(self.source);
        dispatch_release(self.source);
        self.source = nil;
    }
    self.block = nil;
}

- (void)dealloc {
    [self invalidate];
}

- (void)fire {
    self.block();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;实现分析&quot;&gt;&lt;a href=&quot;#实现分析&quot; class=&quot;headerlink&quot; title=&quot;实现分析&quot;&gt;&lt;/a&gt;实现分析&lt;/h4&gt;&lt;p&gt;实现很简单，用的是最基本的方法，即创建了一个&lt;code&gt;dispatch_source_t&lt;/code&gt;，传入&lt;code&gt;block&lt;/code&gt;，然后通过&lt;code&gt;dispatch_source_set_timer&lt;/code&gt;将timer添加到&lt;code&gt;dispatch_source&lt;/code&gt;，设置事件处理为传入的block,然后执行timer。&lt;/p&gt;
&lt;p&gt;提供两个和&lt;code&gt;NSTimer&lt;/code&gt;一样的方法，&lt;code&gt;invalidate&lt;/code&gt;和&lt;code&gt;fire&lt;/code&gt;。&lt;code&gt;fire&lt;/code&gt;会立即执行block，但是不会使timer失效，依然会按照预定计划执行。&lt;/p&gt;
&lt;p&gt;在API定义上，保持了和&lt;code&gt;NSTimer&lt;/code&gt;一样的定义，所以切换起来没有压力。但是简单也以为这功能不完善。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无法暂停挂起timer&lt;/li&gt;
&lt;li&gt;无法指定线程&lt;/li&gt;
&lt;li&gt;无法添加新的任务到timer中&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;MSWeakTimer&quot;&gt;&lt;a href=&quot;#MSWeakTimer&quot; class=&quot;headerlink&quot; title=&quot;MSWeakTimer&quot;&gt;&lt;/a&gt;MSWeakTimer&lt;/h3&gt;&lt;p&gt;&lt;code&gt;MSWeakTimer&lt;/code&gt;的API设计成和&lt;code&gt;NSTimer&lt;/code&gt;一样，调用的方法也一致，直接使用并没有什么副作用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Objective-C&quot;&gt;
- (id)initWithTimeInterval:(NSTimeInterval)timeInterval
                                        target:(id)target
                                    selector:(SEL)selector
                                    userInfo:(id)userInfo
                                     repeats:(BOOL)repeats
                         dispatchQueue:(dispatch_queue_t)dispatchQueue;

                         /**
 * Creates an `MSWeakTimer` object and schedules it to start ticking inmediately.
 */
+ (instancetype)scheduledTimerWithTimeInterval:(NSTimeInterval)timeInterval
                                                                                target:(id)target
                                                                            selector:(SEL)selector
                                                                            userInfo:(id)userInfo
                                                                             repeats:(BOOL)repeats
                                                                 dispatchQueue:(dispatch_queue_t)dispatchQueue;

                                                                 /**
 * Starts the timer if it hadn&amp;#39;t been schedule yet.
 * @warning calling this method on an already scheduled timer results in undefined behavior.
 */
- (void)schedule;

/**
 * Sets the amount of time after the scheduled fire date that the timer may fire to the given interval.
 * @discussion Setting a tolerance for a timer allows it to fire later than the scheduled fire date, improving the ability of the system to optimize for increased power savings and responsiveness. The timer may fire at any time between its scheduled fire date and the scheduled fire date plus the tolerance. The timer will not fire before the scheduled fire date. For repeating timers, the next fire date is calculated from the original fire date regardless of tolerance applied at individual fire times, to avoid drift. The default value is zero, which means no additional tolerance is applied. The system reserves the right to apply a small amount of tolerance to certain timers regardless of the value of this property.
 As the user of the timer, you will have the best idea of what an appropriate tolerance for a timer may be. A general rule of thumb, though, is to set the tolerance to at least 10% of the interval, for a repeating timer. Even a small amount of tolerance will have a significant positive impact on the power usage of your application. The system may put a maximum value of the tolerance.
 */
@property (atomic, assign) NSTimeInterval tolerance;

/**
 * Causes the timer to be fired synchronously manually on the queue from which you call this method.
 * You can use this method to fire a repeating timer without interrupting its regular firing schedule.
 * If the timer is non-repeating, it is automatically invalidated after firing, even if its scheduled fire date has not arrived.
 */
- (void)fire;

/**
 * You can call this method on repeatable timers in order to stop it from running and trying
 * to call the delegate method.
 * @note `MSWeakTimer` won&amp;#39;t invoke the `selector` on `target` again after calling this method.
 * You can call this method from any queue, it doesn&amp;#39;t have to be the queue from where you scheduled it.
 * Since it doesn&amp;#39;t retain the delegate, unlike a regular `NSTimer`, your `dealloc` method will actually be called
 * and it&amp;#39;s easier to place the `invalidate` call there, instead of figuring out a safe place to do it.
 */
- (void)invalidate;

- (id)userInfo;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现&lt;/h4&gt;&lt;p&gt;先来看初始化方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (id)initWithTimeInterval:(NSTimeInterval)timeInterval
                                        target:(id)target
                                    selector:(SEL)selector
                                    userInfo:(id)userInfo
                                     repeats:(BOOL)repeats
                         dispatchQueue:(dispatch_queue_t)dispatchQueue
{
        NSParameterAssert(target);
        NSParameterAssert(selector);
        NSParameterAssert(dispatchQueue);

        if ((self = [super init]))
        {
                self.timeInterval = timeInterval;
                self.target = target;
                self.selector = selector;
                self.userInfo = userInfo;
                self.repeats = repeats;

                NSString *privateQueueName = [NSString stringWithFormat:@&amp;quot;com.mindsnacks.msweaktimer.%p&amp;quot;, self];
                self.privateSerialQueue = dispatch_queue_create([privateQueueName cStringUsingEncoding:NSASCIIStringEncoding], DISPATCH_QUEUE_SERIAL);
                dispatch_set_target_queue(self.privateSerialQueue, dispatchQueue);

                self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,
                                                                                        0,
                                                                                        0,
                                                                                        self.privateSerialQueue);
        }

        return self;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将传入的参数复制给当前类的属性，然后初始化&lt;code&gt;privateSerialQueue&lt;/code&gt;，&lt;code&gt;privateSerialQueue&lt;/code&gt;的名称是&lt;code&gt;privateQueueName&lt;/code&gt;，可变参数为当前对象的内存地址。调用&lt;code&gt;dispatch_set_target_queue&lt;/code&gt;将传参的&lt;code&gt;dispatchQueue&lt;/code&gt;优先级赋给&lt;code&gt;privateSerialQueue&lt;/code&gt;。最后，初始化&lt;code&gt;timer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后看执行函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)schedule
{
        [self resetTimerProperties];

        __weak MSWeakTimer *weakSelf = self;

        dispatch_source_set_event_handler(self.timer, ^{
                [weakSelf timerFired];
        });

        dispatch_resume(self.timer);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先调用了&lt;code&gt;resetTimerProperties&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)resetTimerProperties
{
        int64_t intervalInNanoseconds = (int64_t)(self.timeInterval * NSEC_PER_SEC);
        int64_t toleranceInNanoseconds = (int64_t)(self.tolerance * NSEC_PER_SEC);

        dispatch_source_set_timer(self.timer,
                                                            dispatch_time(DISPATCH_TIME_NOW, intervalInNanoseconds),
                                                            (uint64_t)intervalInNanoseconds,
                                                            toleranceInNanoseconds
                                                            );
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;resetTimerProperties&lt;/code&gt;重置&lt;code&gt;timer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;intervalInNanoseconds&lt;/code&gt;和&lt;code&gt;toleranceInNanoseconds&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;充当&lt;code&gt;interval&lt;/code&gt;和&lt;code&gt;leeway&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在执行完&lt;code&gt;resetTimerProperties&lt;/code&gt;后，&lt;code&gt;dispatch_source_set_event_handler&lt;/code&gt;一个block到&lt;code&gt;timer&lt;/code&gt;，执行&lt;code&gt;timerFired&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)timerFired
{
        // Checking attomatically if the timer has already been invalidated.
        if (OSAtomicAnd32OrigBarrier(1, &amp;amp;_timerFlags.timerIsInvalidated))
        {
                return;
        }

        // We&amp;#39;re not worried about this warning because the selector we&amp;#39;re calling doesn&amp;#39;t return a +1 object.
        #pragma clang diagnostic push
        #pragma clang diagnostic ignored &amp;quot;-Warc-performSelector-leaks&amp;quot;
                [self.target performSelector:self.selector withObject:self];
        #pragma clang diagnostic pop

        if (!self.repeats)
        {
                [self invalidate];
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里&lt;code&gt;OSAtomicAnd32OrigBarrier&lt;/code&gt;是个值得关注的函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OSAtomicAnd32OrigBarrier&lt;/code&gt;是一个原子操作的布尔与运算，且带有内存屏障。&lt;code&gt;OSAtomicAnd32OrigBarrier&lt;/code&gt;保证了在与操作之前数据结构的存储结构发生改变。&lt;/p&gt;
&lt;p&gt;详细的只是可以参考下面这篇文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;&quot;&gt;http://southpeak.github.io/blog/2014/10/17/osatomicyuan-zi-cao-zuo/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这里，&lt;code&gt;_timerFlags.timerIsInvalidated&lt;/code&gt;与1做与操作，如果返回return 则返回，如果不是，执行.&lt;/p&gt;
&lt;p&gt;这里如果不加入&lt;code&gt;invalidate&lt;/code&gt;的话，恐怕说不清楚为什么这里要做这个判断&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)invalidate
{
        // We check with an atomic operation if it has already been invalidated. Ideally we would synchronize this on the private queue,
        // but since we can&amp;#39;t know the context from which this method will be called, dispatch_sync might cause a deadlock.
        if (!OSAtomicTestAndSetBarrier(7, &amp;amp;_timerFlags.timerIsInvalidated))
        {
                dispatch_source_t timer = self.timer;
                dispatch_async(self.privateSerialQueue, ^{
                        dispatch_source_cancel(timer);
                        ms_release_gcd_object(timer);
                });
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;    if (!OSAtomicTestAndSetBarrier(7, &amp;amp;_timerFlags.timerIsInvalidated))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;OSAtomicTestAndSetBarrier&lt;/code&gt;和&lt;code&gt;OSAtomicAnd32OrigBarrier&lt;/code&gt;正好可以作为一个相对操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OSAtomicTestAndSetBarrier(7, &amp;amp;_timerFlags.timerIsInvalidated)&lt;/code&gt;会指定变量中的一个bit，把它设置为‘1’并返回旧值。如果要指定32bit integer最低位，n应该是7。因此如果第一次调用&lt;code&gt;OSAtomicTestAndSetBarrier&lt;/code&gt;的话，返回false同时话将&lt;code&gt;timerIsInvalidated&lt;/code&gt;置成1.由于原子操作和内存屏障，这个方法不会和&lt;code&gt;OSAtomicAnd32OrigBarrier&lt;/code&gt;一同执行。如果执行到&lt;code&gt;timerFired&lt;/code&gt;的时候，&lt;code&gt;OSAtomicAnd32OrigBarrier(1, &amp;amp;_timerFlags.timerIsInvalidated)&lt;/code&gt;返回true，就会返回了。通过这个方法保证了在调用&lt;code&gt;invalidate&lt;/code&gt;后将timer失效。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;timerFired&lt;/code&gt;如果能执行，则通过&lt;code&gt;performSelector&lt;/code&gt;来调用对用的&lt;code&gt;SEL&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;invalidate&lt;/code&gt;中，如果需要释放，需要调用&lt;code&gt;dispatch_async&lt;/code&gt;。原因是我们虽然通过原子操作保证了&lt;code&gt;invalidated&lt;/code&gt;，但是我们无法确定当前的上下文情况，使用&lt;code&gt;dispatch_async&lt;/code&gt;可能会造成死锁。&lt;/p&gt;
&lt;p&gt;主流程分析就是如此，&lt;code&gt;MSWeakTimer&lt;/code&gt;最值得关注的就是上面讲解决线程同步的方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MSWeakTimer&lt;/code&gt;解决了前面提到的问题中无法添加指定线程（实际上也不是添加到那个线程，而是新开了一个线程）。由于模仿的是&lt;code&gt;NSTimer&lt;/code&gt;的API，所以另外两个方法也没有解决。&lt;/p&gt;
&lt;h2 id=&quot;我的实现-–-ZXGCDTimer&quot;&gt;&lt;a href=&quot;#我的实现-–-ZXGCDTimer&quot; class=&quot;headerlink&quot; title=&quot;我的实现 – ZXGCDTimer&quot;&gt;&lt;/a&gt;我的实现 – ZXGCDTimer&lt;/h2&gt;&lt;p&gt;在参考了上面的两个开源库后，自己动手撸了一个简单的基于GCD的Timer。基本解决了上面提到了三个问题。&lt;/p&gt;
&lt;p&gt;代码地址：&lt;a href=&quot;&quot;&gt;https://github.com/csbzhixing/ZXGCDTimer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;思路是，通过&lt;code&gt;ZXGCDTimerManager&lt;/code&gt;提供对外操作包括创建，执行，取消，挂起，回复功能。每个timer通过&lt;code&gt;ZXGCDTimer&lt;/code&gt;为单位去管理，以&lt;code&gt;timerName&lt;/code&gt;去区分不同的timer。支持自定义线程，支持新增Action。&lt;/p&gt;
&lt;p&gt;由于是自己处于研究目的写的，可能存在各种问题，也欢迎大家提出批评和指正。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##少用NSTimer&lt;/p&gt;
&lt;p&gt;在iOS中开发中，定时器是经常用到的工具。一般情况下，我们都会去使用&lt;code&gt;NSTimer&lt;/code&gt;这个类。然而，这个类一旦使用不当的话，会给我们造成很多无法预见的坑。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSTimer&lt;/code&gt;有哪
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一年</title>
    <link href="http://csbzhixing.github.io/2016/04/07/post/"/>
    <id>http://csbzhixing.github.io/2016/04/07/post/</id>
    <published>2016-04-06T16:03:44.000Z</published>
    <updated>2016-04-06T16:04:24.000Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;转眼间，我已经实习一年了。
转眼间，要大学毕业了。

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果不看日历，不去想时间，似乎和一年前的这个时候也没有什么不同。一样的担心，一样的焦虑。&lt;br&gt;一年前，因为自己陷入了学习的盲区，不知道如何去提升自己，只好想办法找个实习，想说自己找找自己的学习的方向。这么一做，就是一年过去了。&lt;/p&gt;
&lt;p&gt;实习的一年，可以说很辛苦，也很充实。辛苦是因为不仅仅要完成自己学习上的东西，还要去完成工作上的事情，这点对我来说的确是不小的挑战。大学的前两年里面，每天白天上上课，晚上搞下作业，然后就可以快乐的玩耍了。然而到了实习，白天的工作就足以让自己心力交瘁，晚上回到学校后还有许多课业要补习。即使如此，我也没有后悔。如果不是实习，我现在可能还在盲目不知道怎么去找工作；如果不是实习，自己可能现在还在纠结自己未来在哪个方向前进；如果不是实习，可能现在还有改不掉的一堆学生气。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;时间不会让人成长，只有痛苦可以


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;还记得刚开始实习的时候特别痛苦。用学校那套学习方法进入工作肯定是行不通的。所以开始的一个月，在iOS上并没有什么长进。硬生生的啃了几本书也然并卵。到了第二个月，接触了项目，有了目标，一点点的去实现一个个目标，结合原理，才真正有了一点点突破。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;知识永远学不完，钱永远赚不完，找到自己的路就行


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;十月份换了个实习，回到了深圳。一个原因是原来的公司人员变动，自己也觉得平台太小已经没法接触更多的东西了，除此外回到深圳也可以解放自己更多时间来学习。于是乎很幸运的来到了现在的公司。在这里，从头开发了多个APP，接触了React Native。从一个辅助慢慢成为一个独立的开发。这个时候，很多同学已经确定下来了Offer.看着同学一个个比较自己的offer的时候，自己的心态也有点小小的波动。但是，最后，还是决定扎下来。现有的平台对于自己来说是足够的。一方面身边有足够厉害的人能够提携自己，一方面在项目和时间上能够让自己去深入学习和提高。比较1K,2k这点差距，技术积累和做人的学习恐怕才是最重要的。    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;一年后


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然前不久才写完新年总结，之后也好久没有更新什么技术文章，这个总结也算另开一个头。已经从毕设中解放的我有更多时间去深入iOS和js了。希望在一年后的今天，能够在两个技术栈上都有不小的成就。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;转眼间，我已经实习一年了。
转眼间，要大学毕业了。

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果不看日历，不去想时间，似乎和一年前的这个时候也没有什么不同。一样的担心，一样的焦虑。&lt;br&gt;一年前，因为自己陷入了学习的盲区，不知道如何去提升自己，只好想办法找个实习，
    
    </summary>
    
    
      <category term="心得" scheme="http://csbzhixing.github.io/tags/%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>2016</title>
    <link href="http://csbzhixing.github.io/2016/01/02/2016/"/>
    <id>http://csbzhixing.github.io/2016/01/02/2016/</id>
    <published>2016-01-01T16:51:17.000Z</published>
    <updated>2016-01-01T16:51:28.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Hello-2016-Goodbye-2015&quot;&gt;&lt;a href=&quot;#Hello-2016-Goodbye-2015&quot; class=&quot;headerlink&quot; title=&quot;Hello 2016, Goodbye 2015&quot;&gt;&lt;/a&gt;Hello 2016, Goodbye 2015&lt;/h1&gt;&lt;p&gt;转眼就一年过去了。感觉2015过的飞快。过年的时候去阳江好像就再前不久，如今已经是2016年。想起来今天过得特别快，大概是因为自己已经开始工作了吧。&lt;/p&gt;
&lt;p&gt;在三月份，也就是大三下学期的时候，发现自己学习进入了一个瓶颈。对待很多技术都感到很好奇，也感觉自己有想法在这个行业做下去，但是却找不到一个方向去深入地学习。于是乎，在妹子的鼓励下，决定找公司去实习，通过对实际商业生产的了解，调整自己的技术学习方向。然而就这么误打误撞地进入了iOS开发。在广州业速的六个月里面，我从一个只是听闻iOS开发和觉得macbook最牛逼的一个乡下人（好吧我承认这个是自嘲）到一个基本熟悉iOS的初级开发。在这过程中，得益于likid的指导和帮助，收获了许多学习上的心得。在之前自己的学习都是浅尝即止，并没有深入到技术的本质，所以导致了自己好像很多东西都知道，但是说起来却又好像什么都不太懂的样子。在学习iOS开发的过程中，也矫正了自己很多不良的习惯。其中是懂了baidu都是呵呵呵，要查资料还是谷歌大法好（好吧其实我学校不能翻墙，怎么去一个不存在的网站搜东西）。然后是github和stackoverflow两个社区了解也算知道了真正学技术应该去啥地方学习T T,原来我之前三年基本都白过了，还好知道的不晚。&lt;/p&gt;
&lt;p&gt;在十月的时候，在鹅厂无望后（主要是自己太水），决定回到深圳，来到了现在的这家公司。新公司给我最大的感受就是身边的大神特别多。其中最让我收益一个是charge对我在iOS开发上的指导，一个是春哥对我技术思考上的指导。在新公司里面，我不再把自己仅仅当做一个完成任务就好的实习生，而是更多地去作为一个团队的一份子。在这过程中，解决了之前很多从来都没思考也没有遇到过的问题，慢慢地能够更加独立地解决问题。虽然在新公司，加班的次数比起在广州多了不少，然而并没有让我觉得上班很无聊，似乎看来我还是适合干这行的，哈哈。在12月，新项目决定上React Native，这又给我了一个非常好的学习机会。在一周的时间学习了ES6和React Native的语法，写了几个简陋的组件，也算碰到了门槛。说不定2016年也会接触下安卓和前端开发。作为一个技术人，千万不能把自己限死在一个固定的平台上。掌握了基本的原则和思想，就应该能在所有的平台上都有所作为。学习能力和执行力永远是技术人的核心竞争力。&lt;/p&gt;
&lt;p&gt;得益于今年自己的实习有了一些小小的外快和大牛市一波行情。今年买了特别多得东西。从一堆耳机，几部手机，macbook和新台式，音响。虽然买了很多东西，但是基本上没有靠父母出什么钱。在消费观念上，一年里面也是波动了很多，从舍不得花钱，到乱花钱，到有目的的花钱。新一年里面，如果能顺利拿到offer，也要为未来考虑下了。虽然比起别人不用在外面租房省下了不少的开支，但不意味着自己能够乱花钱。希望能够在10年内尽早的完全独立。&lt;/p&gt;
&lt;p&gt;2015年，最大的收获就是想明白了，读书和锻炼这两样是绝对地收益终身的事情。于是乎，购入了kindle，买了跑鞋，开始了自己的精神和肉体的锻炼。这一年，读了杂七杂八的很多书，跑了快两百公里，感觉很不错，想在2016能够继续。只有保持健康的身体和清醒地大脑才能保持每天都能快乐地生活。&lt;/p&gt;
&lt;p&gt;2016年，是自己大学的最后一年。不出意外的话应该是在实习的过程中国不知不觉的结束自己的大学生涯。对于大学，对我个人而言，收获恐怕不多，唯有明白了自己没有选错自己未来从事的行业。想来，大学也算玩过，开心过，也不枉自己最后任性的青春。即将踏上社会，再也没有借口给自己找退路，只能和一切困难斗争下去。2016，应该是会是个值得纪念的年份。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hello-2016-Goodbye-2015&quot;&gt;&lt;a href=&quot;#Hello-2016-Goodbye-2015&quot; class=&quot;headerlink&quot; title=&quot;Hello 2016, Goodbye 2015&quot;&gt;&lt;/a&gt;Hello 2016, Good
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>让Xcode的控制台更给力点</title>
    <link href="http://csbzhixing.github.io/2015/12/03/xcode-color/"/>
    <id>http://csbzhixing.github.io/2015/12/03/xcode-color/</id>
    <published>2015-12-03T15:23:35.000Z</published>
    <updated>2016-04-04T06:10:25.000Z</updated>
    
    <content type="html">&lt;p&gt;用过Xcode的人都知道，Log是有多难堪多难堪，控制台各种蛋疼各种无语，看到APPCode的控制台后我时对xcode彻底无爱了。经过各种折腾，决定在当前的项目试验下增强log的功能，使用CocoaLumberjack和XcodeColors来使我们的控制台达到能看的效果。&lt;/p&gt;
&lt;p&gt;首先 打开CocoaLumberjack的github地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CocoaLumberjack/CocoaLumberjack&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/CocoaLumberjack/CocoaLumberjack&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用cocospod 安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;platform :ios, &amp;#39;8.0&amp;#39;
pod &amp;#39;CocoaLumberjack&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在自己工程文件下.pch下加入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define LOG_LEVEL_DEF ddLogLevel
#import &amp;lt;CocoaLumberjack/CocoaLumberjack.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在APPDelegate里面初始化log&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)initLogger
{

    // Standard lumberjack initialization
    [DDLog addLogger:[DDTTYLogger sharedInstance]];

    // And we also enable colors
    [[DDTTYLogger sharedInstance] setColorsEnabled:YES];

    [DDTTYLogger sharedInstance].logFormatter = [[DFCustomFormatter alloc] init];

    DDFileLogger *fileLogger = [[DDFileLogger alloc] init]; // File Logger
    fileLogger.rollingFrequency = 60 * 60 * 24; // 24 hour rolling
    fileLogger.logFileManager.maximumNumberOfLogFiles = 7;
    [DDLog addLogger:fileLogger];

    [self setConsoleColor];


}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到这里就完成了ddlog的初始化，但是到这里还没结束，因为这样仅仅是让框架运行起来，还没有到我们要的效果。&lt;/p&gt;
&lt;p&gt;我们想要的，应该是达到以下的目的&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;能够打印Log的发生位置，方法，时间&lt;/li&gt;
&lt;li&gt;能够根据不同Log级别有不同的颜色对应&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;完成第一点很简单，我们只需要实现自己的formatter就可以了&lt;/p&gt;
&lt;p&gt;实现&lt;code&gt;DDLogFormatter&lt;/code&gt;的协议&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;
#import &amp;quot;DDLog.h&amp;quot;

@interface DFCustomFormatter : NSObject &amp;lt;DDLogFormatter&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;@implementation DFCustomFormatter

- (NSString *)formatLogMessage:(DDLogMessage *)logMessage {
    NSString *logLevel;
    switch (logMessage-&amp;gt;_flag) {
        case DDLogFlagError    : logLevel = @&amp;quot;E&amp;quot;; break;
        case DDLogFlagWarning  : logLevel = @&amp;quot;W&amp;quot;; break;
        case DDLogFlagInfo     : logLevel = @&amp;quot;I&amp;quot;; break;
        case DDLogFlagDebug    : logLevel = @&amp;quot;D&amp;quot;; break;
        default                : logLevel = @&amp;quot;V&amp;quot;; break;
    }

    NSString *formatStr = [NSString stringWithFormat:@&amp;quot;[%@ %@][line %lu] %@&amp;quot;,
                            logMessage.fileName, logMessage-&amp;gt;_function,
                           (unsigned long)logMessage-&amp;gt;_line, logMessage-&amp;gt;_message];
    return formatStr;

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样我们就打印了需要的信息，更多的方法可以到DDLogMessage里面看提供了什么属性。&lt;/p&gt;
&lt;p&gt;完成第二点，就要借助XcodeColors&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://github.com/robbiehanson/XcodeColors&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/robbiehanson/XcodeColors&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装后，在APPDelegate中初始化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 打开颜色支持
[[DDTTYLogger sharedInstance] setColorsEnabled:YES];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后我们可以根据自己的喜好设置不同级别的Log的颜色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)setConsoleColor
{
#if TARGET_OS_IPHONE
    UIColor *pink = [UIColor colorWithRed:(255/255.0) green:(58/255.0) blue:(159/255.0) alpha:1.0];

#else
    NSColor *pink = [NSColor colorWithCalibratedRed:(255/255.0) green:(58/255.0) blue:(159/255.0) alpha:1.0];
#endif

    [[DDTTYLogger sharedInstance] setForegroundColor:pink backgroundColor:nil forFlag:DDLogFlagInfo];
    [[DDTTYLogger sharedInstance] setForegroundColor:[UIColor redColor] backgroundColor:nil forFlag:DDLogFlagError];
    [[DDTTYLogger sharedInstance] setForegroundColor:[UIColor orangeColor] backgroundColor:nil forFlag:DDLogFlagWarning];


}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到这里，还不能让控制台显示出颜色，要设置对应schema&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14491562929176.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;添加后，就可以让xcode的控制显示我们要的效果了。&lt;/p&gt;
&lt;p&gt;如果自己的项目本身有对应的log方法，可以用宏直接替换&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;用过Xcode的人都知道，Log是有多难堪多难堪，控制台各种蛋疼各种无语，看到APPCode的控制台后我时对xcode彻底无爱了。经过各种折腾，决定在当前的项目试验下增强log的功能，使用CocoaLumberjack和XcodeColors来使我们的控制台达到能看的效果。
    
    </summary>
    
      <category term="Xcode" scheme="http://csbzhixing.github.io/categories/Xcode/"/>
    
    
  </entry>
  
  <entry>
    <title>一周刷题总结 - 2</title>
    <link href="http://csbzhixing.github.io/2015/11/13/leetcode2/"/>
    <id>http://csbzhixing.github.io/2015/11/13/leetcode2/</id>
    <published>2015-11-13T14:08:35.000Z</published>
    <updated>2015-11-13T16:03:13.000Z</updated>
    
    <content type="html">&lt;p&gt;又到了一周题目总结时间。到现在为止总共完成了三十道题，每天大概做1-3题。感觉这个步骤还是比较适合自己的进度的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;leetcode 9&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给出一个Int值，判断是否是回文数字。&lt;/p&gt;
&lt;p&gt;我们可以想到，如果是字符串的话，我们可以通过字符串的处理方式来处理，但这里是一个数字。我们可以从回文的定义知道，如果我们将整个数字反转过来，如果仍然等于原来的数字，那么这个数字就是回文数。&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;bool isPalindrome(int x) {
    if(x&amp;lt;0) return false;
    if(x&amp;lt;10) return true;

    int y=0,temp = x;

    while(temp)
    {
        y = y*10 + (temp%10);
        temp/=10;
    }

    return x==y;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;leetcode 26&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;移除一个数组中重复的数字。&lt;/p&gt;
&lt;p&gt;根据题意，我们只需要将重复的数字不停地移动到数组末尾，然后缩短数组大小就可以了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;int removeDuplicates(int* nums, int numsSize) {

    if(numsSize&amp;lt;2) return numsSize;

    int cur = 0;int temp = nums[0];

    for(int i = 1;i&amp;lt;numsSize;i++)
    {
        if(nums[i] == temp) continue;
        else
        {
            nums[cur+1] = nums[i];
            cur++;
            temp = nums[i];
        }
    }    
    return cur+1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;leetcode 136&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给出一个数组，找出数组中唯一一个只出现了一次的数，其他的数都出现了两次，要求线性时间内完成且不能用额外的空间。&lt;/p&gt;
&lt;p&gt;这道题给的难度分类是中等，但是我看了下题目的通过率很高，说明又很巧妙地方法。我自己在开始做得时候想到的都都要用额外的存储空间。在看了别人的方法后才知道原来可以用异或方法，因为异或方法相当于交换了两个数。所以我们要做得就是遍历一次数组，用一个数与每个数组的数异或，最后保留的数就是唯一一个出现了一次的数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;int removeDuplicates(int* nums, int numsSize) {

    if(numsSize&amp;lt;2) return numsSize;

    int cur = 0;int temp = nums[0];

    for(int i = 1;i&amp;lt;numsSize;i++)
    {
        if(nums[i] == temp) continue;
        else
        {
            nums[cur+1] = nums[i];
            cur++;
            temp = nums[i];
        }
    }

    return cur+1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样地,leetcode还给出了一道相似的题目，就是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;leetcode 260&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这道题目和上面的题目基本一样，唯独不同的是给出的数组中有两个数只出现了一次。&lt;/p&gt;
&lt;p&gt;题目中提到了，要在线性时间内完成，我们还是要考虑从上面的题目中怎么改进就可以完成这道题目。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;int* singleNumber(int* nums, int numsSize, int* returnSize) {
    int i, *result = calloc(*returnSize = 2, sizeof(int));
    for(i = 0; i &amp;lt; numsSize; result[0] ^= nums[i++]);
    for(i = 0; i &amp;lt; numsSize; i++)
        if(nums[i] &amp;amp; result[0] &amp;amp; -result[0])
            result[1] ^= nums[i];
    result[0] ^= result[1];
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个方法，首先找出了一个result[0]，这个是保存了两个出现了一次的的数字的异或结果a xor b;&lt;br&gt;我们知道 如果a != b的话，那么a xor b就会保准他们每个数字的一部分的二进制。&lt;br&gt;那么第二部我们通过异或就可以刷选出一个结果。&lt;br&gt;通过 a xor b的结果再异或，就可以得出另一个结果。&lt;/p&gt;
&lt;p&gt;通过上面两道题目可以得出，简简单单的异或有时候可是非常强大的。&lt;/p&gt;
&lt;p&gt;##小结&lt;/p&gt;
&lt;p&gt;虽然每周做得题目不止这么多，但是受限时间，只能慢慢整理，优先整理我觉得值得思考的题目。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;又到了一周题目总结时间。到现在为止总共完成了三十道题，每天大概做1-3题。感觉这个步骤还是比较适合自己的进度的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;leetcode 9&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给出一个Int值，判断是否是回文数字。&lt;/p&gt;
&lt;p&gt;我们可以想到，如果是字符串的话
    
    </summary>
    
      <category term="数据结构" scheme="http://csbzhixing.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>rac</title>
    <link href="http://csbzhixing.github.io/2015/11/10/rac/"/>
    <id>http://csbzhixing.github.io/2015/11/10/rac/</id>
    <published>2015-11-09T16:39:45.000Z</published>
    <updated>2015-11-09T16:46:26.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;RAC学习&quot;&gt;&lt;a href=&quot;#RAC学习&quot; class=&quot;headerlink&quot; title=&quot;RAC学习&quot;&gt;&lt;/a&gt;RAC学习&lt;/h1&gt;&lt;p&gt;RAC，ReactiveCocoa,是github上一个非常有名的开源库，实习了在iOS上的函数式编程。在2.x版本之前库是使用Objective-C 实现的，在3.x版本之后使用swift实现。目前最新的版本是4.04;&lt;/p&gt;
&lt;p&gt;##RAC的改变&lt;/p&gt;
&lt;p&gt;RAC通过信号将不同的部分联系在了一起。&lt;/p&gt;
&lt;p&gt;RAC统一了对KVO、UI Event、Network request、Async work的处理，因为它们本质上都是值的变化(Values over time)。&lt;/p&gt;
&lt;p&gt;###KVO&lt;/p&gt;
&lt;p&gt;RAC通过监测属性的值的改变来做相关的操作。不过使用的是block。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Objective-C&quot;&gt;[RACAble(self.username) subscribeNext:^(NSString *newName) {
    NSLog(@&amp;quot;%@&amp;quot;, newName);
}];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看起来比KVO要容易的多，我们不用关注去创建和释放KVO。同时，我们还可以将信号串联起来，达成更多的目的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Objective-C&quot;&gt;// 只有当名字以&amp;#39;j&amp;#39;开头，才会被记录
[[RACAble(self.username)
   filter:^(NSString *newName) {
       return [newName hasPrefix:@&amp;quot;j&amp;quot;];
   }]
   subscribeNext:^(NSString *newName) {
       NSLog(@&amp;quot;%@&amp;quot;, newName);
   }];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###UI Event&lt;/p&gt;
&lt;p&gt;根据UI发生的改变做相应的处理，如果不用RAC的话，我们可能需要有很多步骤。比如检查输入框中的输入是否合法的时候，我们可以通过添加action，当键入的时候就讲输入框的值拿出来检查。这里我们只需要很简单的一段block就可以了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Objective-C&quot;&gt;RAC(self.logInButton, enabled) = [RACSignal
        combineLatest:@[
            self.usernameTextField.rac_textSignal,
            self.passwordTextField.rac_textSignal,
            RACObserve(LoginManager.sharedManager, loggingIn),
            RACObserve(self, loggedIn)
        ] reduce:^(NSString *username, NSString *password, NSNumber *loggingIn, NSNumber *loggedIn) {
            return @(username.length &amp;gt; 0 &amp;amp;&amp;amp; password.length &amp;gt; 0 &amp;amp;&amp;amp; !loggingIn.boolValue &amp;amp;&amp;amp; !loggedIn.boolValue);
        }];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每次当text的值改变的时候，自动向数据流中添加新的数据。如果有subscriber订阅者的时候，就会自动触发。&lt;/p&gt;
&lt;p&gt;###网络异步&lt;/p&gt;
&lt;p&gt;当我们有需求的时候，可以自己创建&lt;code&gt;RACSubject&lt;/code&gt;类型。我们可以认为&lt;code&gt;RACSubject&lt;/code&gt;是一个具有高度自定义的信号(是RACSignal的子类)；&lt;/p&gt;
&lt;p&gt;当我们要进行一个网络请求的时候，可以通过创建信号的方式，让相关的成员订阅该信号，就可以在请求返回的时候执行相关的方法了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Objective-C&quot;&gt;
- (void)doTest
{
    RACSubject *subject = [self doRequest];

    [subject subscribeNext:^(NSString *value){
        NSLog(@&amp;quot;value:%@&amp;quot;, value);
    }];
}

- (RACSubject *)doRequest
{
    RACSubject *subject = [RACSubject subject];
    // 模拟2秒后得到请求内容
    // 只触发1次
    // 尽管subscribeNext什么也没做，但如果没有的话map是不会执行的
    // subscribeNext就是定义了一个接收体
    [[[[RACSignal interval:2] take:1] map:^id(id _){
        // the value is from url request
        NSString *value = @&amp;quot;content fetched from web&amp;quot;;
        [subject sendNext:value];
        return nil;
    }] subscribeNext:^(id _){}];
    return subject;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##常见的概念&lt;/p&gt;
&lt;p&gt;###Signal and Subscriber&lt;/p&gt;
&lt;p&gt;在RAC中，最重要的概念就是信号和订阅者。信号必须有了订阅者才会被获取到（热信号），如果不是，则是处于冷藏状态（冷信号）。&lt;/p&gt;
&lt;p&gt;当信号获得了相关数据后，就会执行订阅者的&lt;code&gt;sendNext, sendComplete, sendError&lt;/code&gt;方法。订阅者也有相关的方法来获取相关的数据，比如&lt;code&gt;[signal subscribeNext:error:completed]&lt;/code&gt;。这个时候只要没有&lt;code&gt;sendError&lt;/code&gt;和&lt;code&gt;sendComplete&lt;/code&gt;传过来，就会有源源不断的数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Objective-C&quot;&gt;[RACObserve(self, username) subscribeNext: ^(NSString *newName){
    NSLog(@&amp;quot;newName:%@&amp;quot;, newName);
}];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;RACObserve使用了KVO来监听property的变化，只要username被自己或外部改变，block就会被执行。但不是所有的property都可以被RACObserve，该property必须支持KVO，比如NSURLCache的currentDiskUsage就不能被RACObserve。&lt;/p&gt;
&lt;p&gt;信号是可以被处理的，通常有以下几种处理信号的方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;map 修改&lt;/li&gt;
&lt;li&gt;filter 过滤&lt;/li&gt;
&lt;li&gt;combine 组合&lt;/li&gt;
&lt;li&gt;chain 串联&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;Objective-C&quot;&gt;
RAC(self.logInButton, enabled) = [RACSignal
        combineLatest:@[
            self.usernameTextField.rac_textSignal,
            self.passwordTextField.rac_textSignal,
            RACObserve(LoginManager.sharedManager, loggingIn),
            RACObserve(self, loggedIn)
        ] reduce:^(NSString *username, NSString *password, NSNumber *loggingIn, NSNumber *loggedIn) {
            return @(username.length &amp;gt; 0 &amp;amp;&amp;amp; password.length &amp;gt; 0 &amp;amp;&amp;amp; !loggingIn.boolValue &amp;amp;&amp;amp; !loggedIn.boolValue);
        }];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面这个例子就是通过组合了四个信号来处理一个复杂的兴矿。&lt;/p&gt;
&lt;p&gt;###冷信号和热信号&lt;/p&gt;
&lt;p&gt;上面提到过冷热信号的问题，简单的来说就是一个信号是否有订阅者的关系。&lt;/p&gt;
&lt;p&gt;注意，如果一个信号有多个订阅者的时候，signal里面的block会被执行多次，要控制的话就要通过replay的方法去控制。&lt;/p&gt;
&lt;p&gt;###UI Category&lt;/p&gt;
&lt;p&gt;RAC提供了很多category的方法来为我们增加了便利，比如上文的rac_textSignal就是对label的一个方法。具体的可以通过自己在实践中摸索，这里有两个要特别注意的。&lt;/p&gt;
&lt;p&gt;我们知道常用的组件当中，最麻烦的就是tableview 的应用。在RAC中，我们可以通过跟踪&lt;code&gt;NSArray&lt;/code&gt;来跟踪数据源，这样在新的数据增加的时候或者旧的数据被移除的时候我们就可以更新tableview。&lt;/p&gt;
&lt;p&gt;还有个很特殊的情况就是cell在重载时候。RAC提供了一个方法&lt;code&gt;rac_prepareForReuseSignal&lt;/code&gt;，它的作用是在cell即将被重用的时候，告诉cell。我们可以想多，如果每个cell上面都有多个button，每次重载的时候都要去addTarget,被重用的时候又要去移除这些target，下面是我看到的一个实例代码，可以很好地解决这个问题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Objective-C&quot;&gt;[[[self.cancelButton
    rac_signalForControlEvents:UIControlEventTouchUpInside]
    takeUntil:self.rac_prepareForReuseSignal]
    subscribeNext:^(UIButton *x) {
    // do other things
}];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有个很常用的地方就是button。我们知道button的点击可能会根据不同的状态有不同的行为。RAC提供了一个category，有一个方法&lt;code&gt;rac_command&lt;/code&gt;。这样每次button按下后都是返回一个信号，这样我们可以更灵活地处理这个button的状态。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Objective-C&quot;&gt;
voteButton.rac_command = [[RACCommand alloc] initWithEnabled:self.viewModel.voteCommand.enabled signalBlock:^RACSignal *(id input) {
    // Assume that we&amp;#39;re logged in at first. We&amp;#39;ll replace this signal later if not.
    RACSignal *authSignal = [RACSignal empty];

    if ([[PXRequest apiHelper] authMode] == PXAPIHelperModeNoAuth) {
        // Not logged in. Replace signal.
        authSignal = [[RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
            @strongify(self);

            FRPLoginViewController *viewController = [[FRPLoginViewController alloc] initWithNibName:@&amp;quot;FRPLoginViewController&amp;quot; bundle:nil];
            UINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:viewController];

            [self presentViewController:navigationController animated:YES completion:^{
                [subscriber sendCompleted];
            }];

            return nil;
        }]];
    }

    return [authSignal then:^RACSignal *{
        @strongify(self);
        return [[self.viewModel.voteCommand execute:nil] ignoreValues];
    }];
}];
[voteButton.rac_command.errors subscribeNext:^(id x) {
    [x subscribeNext:^(NSError *error) {
        [SVProgressHUD showErrorWithStatus:[error localizedDescription]];
    }];
}];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的这段代码提供了一个投票的按钮的事件处理。首先判断是否已经登录了，如果没有登录，则弹出登陆框。如果登录了，就发送HTTP请求。&lt;/p&gt;
&lt;p&gt;对于数据结构，通知中心，NSObject都有不同的category。不过我还没研究那么深，所以有心得的时候会再来说说。&lt;/p&gt;
&lt;p&gt;##小结&lt;br&gt;由于刚好要做毕设，本来大家的建议最好是拿以前的项目来提交，这样的话比较省事，但是我觉得这个是一个机会，能够让自己去研究一些新的技术，也可以让自己去接触一些可能在公司中接触的不到的方面。通过一周的学习，对RAC已经有了一点点心得，接下来会在毕设项目中大量使用。&lt;/p&gt;
&lt;p&gt;后面可能还是想结合网络请求来看看怎么使用RAC，毕竟多数的业务都是网络请求-&amp;gt;数据组织-&amp;gt;页面展示-&amp;gt;交互的过程。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RAC学习&quot;&gt;&lt;a href=&quot;#RAC学习&quot; class=&quot;headerlink&quot; title=&quot;RAC学习&quot;&gt;&lt;/a&gt;RAC学习&lt;/h1&gt;&lt;p&gt;RAC，ReactiveCocoa,是github上一个非常有名的开源库，实习了在iOS上的函数式编程。在2.x版本
    
    </summary>
    
      <category term="Objective-C" scheme="http://csbzhixing.github.io/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>一周刷题总结 - 1</title>
    <link href="http://csbzhixing.github.io/2015/11/06/week-code-1/"/>
    <id>http://csbzhixing.github.io/2015/11/06/week-code-1/</id>
    <published>2015-11-06T14:36:06.000Z</published>
    <updated>2015-11-06T14:36:56.000Z</updated>
    
    <content type="html">&lt;p&gt;上周开始复习算法和数据结构，一周每天在睡前都拿出不少时间去学习，做了一些题目，想来每周都应该把相关的题目总结一下，才能更好的去学习。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;237    Delete Node in a Linked List&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是上次笔记里面写过的内容，但是我自己写得时候又出现了问题，看来简单的问题业不能去忽略。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
void deleteNode(struct ListNode* node) {
    if(node == NULL) return;
    struct ListNode *temp = node-&amp;gt;next;
    node-&amp;gt;val = temp-&amp;gt;val;
    node-&amp;gt;next = temp-&amp;gt;next;
    free(temp);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;171    Excel Sheet Column Number&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单的来说就是一个26进制的数，没什么难点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int titleToNumber(char* s) {
    int length = strlen(s);

    int all = 0;

    for(int i=0;i&amp;lt;length;i++)
    {
        all=((s[i]-&amp;#39;A&amp;#39;)+1) + all * 26;
    }

    return all;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;169    Majority Element&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;出现超过n/2的数，通过遍历就可以了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;
int majorityElement(int* nums, int numsSize) {
    int time=0,maj;
    for(int i=0;i&amp;lt;numsSize;i++)
    {
        if(time == 0)
        {
            maj = nums[i];
        }
        if(nums[i]==maj) 
        {
            time++;
        }
       else{
         time--;  
       } 
    }
    return maj;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;206    Reverse Linked List&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;反转链表，基础题目&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* reverseList(struct ListNode* head) {

    struct ListNode* pre = NULL;
    struct ListNode* cur = head;
    struct ListNode* next = NULL;

    while(cur)
    {
        next = cur-&amp;gt;next;
        cur-&amp;gt;next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;263    Ugly Number&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单的递归问题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;
bool isUgly(int num) {

    if(num&amp;lt;1) return false;

    if(num%2==0)
    {
        num/=2;
        return isUgly(num);
    }

     if(num%3==0)
    {
        num/=3;
        return isUgly(num);
    }

     if(num%5==0)
    {
        num/=5;
        return isUgly(num);
    }

    if(num == 1) return true;

    return false;

}
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;上周开始复习算法和数据结构，一周每天在睡前都拿出不少时间去学习，做了一些题目，想来每周都应该把相关的题目总结一下，才能更好的去学习。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;237    Delete Node in a Linked List&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是上次笔记里
    
    </summary>
    
      <category term="数据结构" scheme="http://csbzhixing.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>runtime</title>
    <link href="http://csbzhixing.github.io/2015/11/01/runtime/"/>
    <id>http://csbzhixing.github.io/2015/11/01/runtime/</id>
    <published>2015-11-01T02:07:27.000Z</published>
    <updated>2015-11-01T16:57:36.000Z</updated>
    
    <content type="html">&lt;p&gt;从开始写博客的时候，就由一个准备把Runtime好好研究整理出来。后来发现写runtime得文章太多了，而且自己研究的也算不上有多么深入，写出来估计很多错误- —–（因为主要是给自己看得）。最近在项目中，第一次用到了runtime解决了一个实际问题，这启发我，我的文章应该从怎么利用runtime去解决实际的问题，给自己提供一个解决问题的新思路。&lt;/p&gt;
&lt;p&gt;##runtime 关联对象&lt;/p&gt;
&lt;p&gt;从关联对象说起，是因为在最近的项目中用到了这个方法。当时的场景是，我需要创建一个category，里面需要一个block对象。然而我们知道，我们不能在category中添加成员变量。如果我们尝试添加的话，编译器会报错。当然，使用全局变量能解决这个问题，但明显是一个很优雅的方法，也很容易造成错误。Objective-C针对这一中问题，提供了一个解决方案，就是&lt;code&gt;关联对象(Associated Object)。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们可以想象，关联对象就是一个key - value的模型，把对象通过特定的Key链接到相关的实例上。不过由于使用的是C的借口，所以key是一个void指针。同时，我们要需要为这个关联对象设定内存管理策略。相关的内存的管理策略如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;OBJC_ASSOCIATION_ASSIGN

OBJC_ASSOCIATION_RETAIN_NONATOMIC

OBJC_ASSOCIATION_COPY_NONATOMIC

OBJC_ASSOCIATION_RETAIN

OBJC_ASSOCIATION_COPY
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对&lt;code&gt;OBJC_ASSOCIATION_ASSIGN&lt;/code&gt;的，当关联对象所关联的实例被释放掉后，对象不会被释放掉。而&lt;code&gt;OBJC_ASSOCIATION_RETAIN&lt;/code&gt;和&lt;code&gt;OBJC_ASSOCIATION_COPY&lt;/code&gt;两个的话，在实例被释放掉同时，关联对象也会被release掉。当我们用同一个key去关联另外的实例对象的时候，也会自动释放掉之前关联的对象。这种情况下，先前的关联对象会被妥善地处理掉，并且新的对象会使用它的内存。&lt;/p&gt;
&lt;p&gt;关联对象的的runtime函数如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 设置关联对象

void objc_setAssociatedObject ( id object, const void *key, id value, objc_AssociationPolicy policy );



// 获取关联对象

id objc_getAssociatedObject ( id object, const void *key );



// 移除关联对象

void objc_removeAssociatedObjects ( id object );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面就给出在项目中实际遇到的问题给做一个例子。&lt;/p&gt;
&lt;p&gt;首先在头文件中定义了以下内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14463463210542.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，这个category是为了扩展vc，让vc具有一个弹出系统通讯录的功能。&lt;/p&gt;
&lt;p&gt;在.m文件中，如下实现block关联对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14463464447032.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后就像正常的对象一样操作就行了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14463464914602.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14463464837182.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上面看到，我对关联对象使用的key是用了&lt;code&gt;@selector()&lt;/code&gt;。那为什么可以使用SEL来代替设定一个固定的key呢？&lt;/p&gt;
&lt;h2 id=&quot;方法与消息&quot;&gt;&lt;a href=&quot;#方法与消息&quot; class=&quot;headerlink&quot; title=&quot;方法与消息&quot;&gt;&lt;/a&gt;方法与消息&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SEL&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;又叫选择器，是表示一个方法的selector的指针，其定义如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;typedef struct objc_selector *SEL;&lt;/code&gt;&lt;br&gt;objc_selector结构体的详细定义没有在&amp;lt;objc/runtime.h&amp;gt;头文件中找到。方法的selector用于表示运行时方法的名字。Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IMP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过SEL找到函数后，就可以获取到该函数的IMP。IMP实际上是一个函数指针，指向方法实现的首地址。其定义如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;id (*IMP)(id, SEL, ...)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过取得IMP，我们可以跳过runtime的消息传递机制，直接通过IMP执行指向的函数实现。这样一来可以提高效率，省去了消息传递中的一系列过程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;回答上面的问题

我们知道，在同一个类文件里面，不能存在同一个名字的方法，即使是参数类型不同业不行。同理，同一个类文件里面不能存在同一个名字的对象，所以set方法是唯一的，所以可以使用SEL来获取唯一的整理标识来作为key。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##下面是看的一些文章的摘录和自己的一项心得，主要是给自己做一个备忘。&lt;/p&gt;
&lt;p&gt;选择器相关的操作函数包括：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回给定选择器指定的方法的名称
const char * sel_getName ( SEL sel );
// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器

SEL sel_registerName ( const char *str );



// 在Objective-C Runtime系统中注册一个方法

SEL sel_getUid ( const char *str );



// 比较两个选择器

BOOL sel_isEqual ( SEL lhs, SEL rhs );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法操作的函数如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 调用指定方法的实现
// receiver不能为空
// 比method_getImplementation和method_getName更快

id method_invoke ( id receiver, Method m, ... );



// 调用返回一个数据结构的方法的实现

void method_invoke_stret ( id receiver, Method m, ... );



// 获取方法名
// 返回一个SEL。如果要获取方法名得C字符串，要用sel_getName(method_getName(method))。

SEL method_getName ( Method m );



// 返回方法的实现
// 注意该函数返回值是方法之前的实现。
IMP method_getImplementation ( Method m );



// 获取描述方法参数和返回值类型的字符串

const char * method_getTypeEncoding ( Method m );



// 获取方法的返回值类型的字符串

char * method_copyReturnType ( Method m );



// 获取方法的指定位置参数的类型字符串

char * method_copyArgumentType ( Method m, unsigned int index );



// 通过引用返回方法的返回值类型字符串

void method_getReturnType ( Method m, char *dst, size_t dst_len );



// 返回方法的参数的个数

unsigned int method_getNumberOfArguments ( Method m );



// 通过引用返回方法指定位置参数的类型字符串

void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );



// 返回指定方法的方法描述结构体

struct objc_method_description * method_getDescription ( Method m );



// 设置方法的实现

IMP method_setImplementation ( Method m, IMP imp );



// 交换两个方法的实现

void method_exchangeImplementations ( Method m1, Method m2 );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##方法调用流程&lt;/p&gt;
&lt;p&gt;在Objective-C中，消息会一直到运行时绑定的方法实现上。我们常用的[receiver message]会被runtime转换为一个函数调用&lt;code&gt;objc_msgSend&lt;/code&gt;。如下&lt;/p&gt;
&lt;p&gt;&lt;code&gt;objc_msgSend(receiver, selector)&lt;/code&gt;&lt;br&gt;如果消息中还有其它参数，则该方法的形式如下所示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;objc_msgSend(receiver, selector, arg1, arg2, ...)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个函数在执行的过程中完成了所有动态绑定的过程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找到SEL对应的方法实现。由于一个方法可能在不同的类有不同的实现，所有我们要依赖于接受者的类来确定确切的实现。&lt;/li&gt;
&lt;li&gt;调用方法的实现，将参数传入。&lt;/li&gt;
&lt;li&gt;将方法的返回这作为的自己的返回值。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一个基本消息的框架&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14463917464901.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意到，在&lt;code&gt;objc_msgSend&lt;/code&gt;中有两个隐藏参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消息接受对象&lt;/li&gt;
&lt;li&gt;方法的selecor&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;隐藏是以为内在定义的方法中没有申明，是在编译期被插入实现代码的。&lt;/p&gt;
&lt;p&gt;##消息转发&lt;/p&gt;
&lt;p&gt;当一个对象能接受一个消息的时候，那么一切都会按照我们想得去做，但是如果不能接受消息的时候，会发生什么？一般情况下，如果不能相应[object message],编译期会报错。如果是以perform来调用的，那么在运行时才会确定object是否会接收消息，如果不行的话，就会造成程序崩溃。&lt;/p&gt;
&lt;p&gt;当然，我们可以通过&lt;code&gt;respondsToSelector:&lt;/code&gt;来判断一下是否会响应这个消息，但是我们要用runtime来搞一搞，所以我们应该从&lt;code&gt;消息转发机制&lt;/code&gt;来考虑。&lt;/p&gt;
&lt;p&gt;消息转发机制基本分为三个步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动态方法解析&lt;/li&gt;
&lt;li&gt;备用接收者&lt;/li&gt;
&lt;li&gt;完成转发&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;###动态方法解析&lt;/p&gt;
&lt;p&gt;当当对象接收到位置的消息时，首先会调用类的&lt;code&gt;+resolveInstanceMethod:(实例方法)&lt;/code&gt;或者&lt;code&gt;+resolveClassMethod:(类方法)&lt;/code&gt;。因此，我们可以去增加一个处理方法。在消息不能被对象接收的时候就运行这个方法，前提是这个方法已经被实现了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void functionForMethod1(id self, SEL _cmd) {

   NSLog(@&amp;quot;%@, %p&amp;quot;, self, _cmd);

}



+ (BOOL)resolveInstanceMethod:(SEL)sel {



    NSString *selectorString = NSStringFromSelector(sel);



    if ([selectorString isEqualToString:@&amp;quot;method1&amp;quot;]) {

        class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &amp;quot;@:&amp;quot;);

    }



    return [super resolveInstanceMethod:sel];

}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;备用接收者&quot;&gt;&lt;a href=&quot;#备用接收者&quot; class=&quot;headerlink&quot; title=&quot;备用接收者&quot;&gt;&lt;/a&gt;备用接收者&lt;/h3&gt;&lt;p&gt;当我们的对象不能处理消息的时候，我们将消息转发到一个备用的对象，只要这个对象的类实现了这个方法&lt;br&gt;&lt;code&gt;- (id)forwardingTargetForSelector:(SEL)aSelector&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果返回的不是一个nil的话，那么这个对象就会被作为消息的心的接收者。而在外部看来，这个消息仍然被我们的发送的对象处理了。注意，这个方法返回的对象不是self自身，不然就是个无限循环了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface SUTRuntimeMethodHelper : NSObject



- (void)method2;



@end



@implementation SUTRuntimeMethodHelper



- (void)method2 {

    NSLog(@&amp;quot;%@, %p&amp;quot;, self, _cmd);

}



@end



#pragma mark -



@interface SUTRuntimeMethod () {

    SUTRuntimeMethodHelper *_helper;

}



@end



@implementation SUTRuntimeMethod



+ (instancetype)object {

    return [[self alloc] init];

}



- (instancetype)init {

    self = [super init];

    if (self != nil) {

        _helper = [[SUTRuntimeMethodHelper alloc] init];

    }



    return self;

}



- (void)test {

    [self performSelector:@selector(method2)];

}



- (id)forwardingTargetForSelector:(SEL)aSelector {



    NSLog(@&amp;quot;forwardingTargetForSelector&amp;quot;);



    NSString *selectorString = NSStringFromSelector(aSelector);



    // 将消息转发给_helper来处理

    if ([selectorString isEqualToString:@&amp;quot;method2&amp;quot;]) {

        return _helper;

    }



    return [super forwardingTargetForSelector:aSelector];

}



@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###完成的消息转发&lt;/p&gt;
&lt;p&gt;如果上述的行为都不能解决的话，runtime在这时候会给对象最后一次机会：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)forwardInvocation:(NSInvocation *)anInvocation
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;这个时候，消息的所有未处理的内容都被封装到了anInvocation中，包括SEL,target，参数。我们在这里可以选着将消息转发给其他的对象。&lt;/p&gt;
&lt;p&gt;forwardInvocation:方法的实现有两个任务：&lt;/p&gt;
&lt;p&gt;定位可以响应封装在anInvocation中的消息的对象。这个对象不需要能处理所有未知消息。&lt;br&gt;使用anInvocation作为参数，将消息发送到选中的对象。anInvocation将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于这一块，还没有具体的实践，毕竟到这一步，用runtime来解决不如好好回去check以下代码吧。&lt;/p&gt;
&lt;p&gt;##Method Swizze&lt;/p&gt;
&lt;p&gt;Method Swizzling是改变一个selector的实际实现的技术.这样，我们可以在runtime的时候修改类分发的队形的函数，修改对应的实现。&lt;/p&gt;
&lt;p&gt;例如，我们想在每一个&lt;code&gt;viewDidAppear&lt;/code&gt;增加一个跟踪代码，观察哪个vc被调用了，那么我们就可以通过&lt;code&gt;Method Swizzling&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;###Swizzling 注意事项&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Swizzling应该总是在+load中执行&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证—事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。&lt;/p&gt;
&lt;p&gt;+load在父类，子类，分类的实现都会分别调用，所以+load更适合&lt;/p&gt;
&lt;p&gt;###Swizzling应该总是在dispatch_once中执行&lt;/p&gt;
&lt;p&gt;与上面相同，因为swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的dispatch_once可以确保这种行为，我们应该将其作为method swizzling的最佳实践。&lt;/p&gt;
&lt;p&gt;###特别的地方&lt;/p&gt;
&lt;p&gt;&amp;gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;总是调用方法的原始实现(除非有更好的理由不这么做)：API提供了一个输入与输出约定，但其内部实现是一个黑盒。Swizzle一个方法而不调用原始实现可能会打破私有状态底层操作，从而影响到程序的其它部分。&lt;/li&gt;
&lt;li&gt;避免冲突：给自定义的分类方法加前缀，从而使其与所依赖的代码库不会存在命名冲突。&lt;/li&gt;
&lt;li&gt;明白是怎么回事：简单地拷贝粘贴swizzle代码而不理解它是如何工作的，不仅危险，而且会浪费学习Objective-C运行时的机会。阅读Objective-C Runtime Reference和查看&amp;lt;objc/runtime.h&amp;gt;头文件以了解事件是如何发生的。&lt;/li&gt;
&lt;li&gt;小心操作：无论我们对Foundation, UIKit或其它内建框架执行Swizzle操作抱有多大信心，需要知道在下一版本中许多事可能会不一样。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##总结&lt;/p&gt;
&lt;p&gt;runtime到这里，大概讲了下两个问题，方法转发和关联对象。觉得还是不够，因为很多东西写起来发现自己也不是很了解，暂且做一个笔记。&lt;/p&gt;
&lt;p&gt;这里感谢南峰子，写得runtime教程非常详细，给了我很多帮助。&lt;/p&gt;
&lt;p&gt;本文参考了大量下面三篇文章的内容。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://southpeak.github.io/blog/2014/11/06/objective-c-runtime-yun-xing-shi-zhi-si-:method-swizzling/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://southpeak.github.io/blog/2014/11/03/objective-c-runtime-yun-xing-shi-zhi-san-:fang-fa-yu-xiao-xi-zhuan-fa/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://southpeak.github.io/blog/2014/10/30/objective-c-runtime-yun-xing-shi-zhi-er-:cheng-yuan-bian-liang-yu-shu-xing/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;从开始写博客的时候，就由一个准备把Runtime好好研究整理出来。后来发现写runtime得文章太多了，而且自己研究的也算不上有多么深入，写出来估计很多错误- —–（因为主要是给自己看得）。最近在项目中，第一次用到了runtime解决了一个实际问题，这启发我，我的文章应该从
    
    </summary>
    
      <category term="Objective-C" scheme="http://csbzhixing.github.io/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>list</title>
    <link href="http://csbzhixing.github.io/2015/10/25/list/"/>
    <id>http://csbzhixing.github.io/2015/10/25/list/</id>
    <published>2015-10-25T15:38:26.000Z</published>
    <updated>2015-10-27T16:42:39.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;开始内功！&quot;&gt;&lt;a href=&quot;#开始内功！&quot; class=&quot;headerlink&quot; title=&quot;开始内功！&quot;&gt;&lt;/a&gt;开始内功！&lt;/h1&gt;&lt;p&gt;前几日和前老大谈了谈，总结起来内功不能不练。实习以来有三次想好好复习数据结构和算法，但是最后都半途而废。现在不应该再有任何理由了，不然以后再也没有时间好好去复习这些东西。从现在开始刷好题目，打好基础。&lt;/p&gt;
&lt;p&gt;##链表&lt;/p&gt;
&lt;p&gt;链表是线性表的一种。&lt;/p&gt;
&lt;p&gt;线性表是最简单基础的一种数据结构。线性表中的数据元素之间的关系是一对一的，除了头元素和尾元素之外，其他元素首尾相连。线性表有两种存储方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;顺序存储方式&lt;/li&gt;
&lt;li&gt;链式存储方式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数组是典型的顺序存储方式。链表是典型的链式存储方式。&lt;/p&gt;
&lt;p&gt;链式存储结构，指的是相邻的两个元素在内存中可能不是相邻的，每一个元素都有一个指针域，指针域存放的是下一个元素的指针。&lt;/p&gt;
&lt;p&gt;链式结构的优缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;优点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;插入和删除的复杂度为O(1)&lt;/li&gt;
&lt;li&gt;不会浪费太多内存，在需要添加元素的时候才会申请内存，删除元素后释放内存。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;缺点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;访问元素的时间复杂度最坏为O(N)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;链表就是链式存储的线性表。根据指针域的不同，链表分为单项链表，双向链表，循环链表等等&lt;/p&gt;
&lt;p&gt;一个简单的List定义&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;struct list {
int ver;
struct list *next;
};
typedef struct list *listLink;
// 插入
void insert_list(listLink *, int);
// 打印
void print_list(listLink *, int);
// 链表长
int list_length(listLink);
// 搜索一个特定的值
listLink search_list(listLink, int);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;四个方法的实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14459585444278.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;##指针常出现的问题&lt;/p&gt;
&lt;p&gt;###反转链表&lt;/p&gt;
&lt;p&gt;反转链表，分为两种情况讨论，单向链表和双向链表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;单向链表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;考虑到访问某个节点的时候，要检查下一个节点是否为空。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;要把反转后的最后一个节点（头节点）的指针指向null&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现代码如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14459590472638.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双向链表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;双向链表比较麻烦的地方在于Next和pre要呼唤，需要主要当前节点和上个节点的问题。&lt;/p&gt;
&lt;p&gt;###删除节点&lt;/p&gt;
&lt;p&gt;删除节点必须要知道被删除节点的前置节点，时间复杂度为O(1)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14459596886157.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;###循环链表&lt;/p&gt;
&lt;p&gt;循环链表表现于尾元素的next指针指向head元素，所以我们可以通过快慢指针去校验。具体的方法会在下面的链表的技巧中提到.&lt;/p&gt;
&lt;h2 id=&quot;链表的技巧&quot;&gt;&lt;a href=&quot;#链表的技巧&quot; class=&quot;headerlink&quot; title=&quot;链表的技巧&quot;&gt;&lt;/a&gt;链表的技巧&lt;/h2&gt;&lt;p&gt;###鲁棒性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当访问链表中某个节点的next节点的时候，一点要先判断当前节点是否为空。&lt;/li&gt;
&lt;li&gt;全部操作结束后，判断是否有环。若有环，则置其中一端为Null;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Dummy-Node&quot;&gt;&lt;a href=&quot;#Dummy-Node&quot; class=&quot;headerlink&quot; title=&quot;Dummy Node&quot;&gt;&lt;/a&gt;Dummy Node&lt;/h3&gt;&lt;p&gt;假节点，伪头节点。Dummy &lt;code&gt;Node&lt;/code&gt; 可以认为是一个假的头结点。我们可以构造一个&lt;code&gt;Dummy Node&lt;/code&gt; ，使他的next指针指向Head node。使用&lt;code&gt;Dummy Node&lt;/code&gt;目的是，在单向链表中，保正head不会再删除操作中丢失。此外，比较特殊的方法是用来进行删除head。&lt;/p&gt;
&lt;p&gt;Dummy Node可以处理对于head Node变化的情况。&lt;/p&gt;
&lt;h2 id=&quot;快慢指针&quot;&gt;&lt;a href=&quot;#快慢指针&quot; class=&quot;headerlink&quot; title=&quot;快慢指针&quot;&gt;&lt;/a&gt;快慢指针&lt;/h2&gt;&lt;p&gt;快慢指针式解决很多链表的问题的关键。快慢指的是指针每次移动的步长。常用的快指针步长为2，慢指针步长为1.快慢指针同时从头结点开始移动陪你过。&lt;/p&gt;
&lt;p&gt;快慢指针的应用可以解决以下问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;快速找出为止长度的链表的中间节点。我们让快指针的步长是慢指针的两倍。当快指针到达尾节点的时候，慢指针所指向的节点就是中间节点。&lt;/li&gt;
&lt;li&gt;判断单向链表是否成环。同样的原理，如果快指针 &lt;code&gt;*fase =NULL&lt;/code&gt;的时候，说明链表是NULL结尾的。如果快指针等于慢指针的时候，则说明该链表成环。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;开始内功！&quot;&gt;&lt;a href=&quot;#开始内功！&quot; class=&quot;headerlink&quot; title=&quot;开始内功！&quot;&gt;&lt;/a&gt;开始内功！&lt;/h1&gt;&lt;p&gt;前几日和前老大谈了谈，总结起来内功不能不练。实习以来有三次想好好复习数据结构和算法，但是最后都半途而废。现在不应该再
    
    </summary>
    
      <category term="数据结构" scheme="http://csbzhixing.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>AFNetworking 学习笔记 1</title>
    <link href="http://csbzhixing.github.io/2015/10/23/afnetworking-1/"/>
    <id>http://csbzhixing.github.io/2015/10/23/afnetworking-1/</id>
    <published>2015-10-23T02:31:15.000Z</published>
    <updated>2015-10-23T02:37:00.000Z</updated>
    
    <content type="html">&lt;p&gt;##从3.0开始&lt;/p&gt;
&lt;p&gt;一转眼，AF已经更新到了3.0版本。目前cocoapods上的最新版本是3.0 beta1。在3.0的版本里面，AF全面地使用&lt;code&gt;NSURLSession&lt;/code&gt;代替了&lt;code&gt;NSURLConnection&lt;/code&gt;。之前花了一些时间学习&lt;code&gt;NSURLSession&lt;/code&gt;，在这里的学习终于派上了用场。在这里主要学习3.0版本的使用。希望在项目中能够顺利地过度到AFNetwoking 3.0版本。此外，随着Objective-c慢慢被Swift替代，AFNetworking 3.0可能是最后一个大版本更新。本文会一直随着AN的更新继续更新，也是一个不断学习的过程。&lt;/p&gt;
&lt;p&gt;##结构&lt;/p&gt;
&lt;p&gt;在3.0时代，AFN精简了结构，全面使用了&lt;code&gt;NSURLSession&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14451531667191.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;beta1里面只剩下了当前几个Manager。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AFHTTPSessionManager&lt;/code&gt;是&lt;code&gt;AFURLSessionManager&lt;/code&gt;的子类。&lt;/p&gt;
&lt;p&gt;##AFURLSessionManager&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AFURLSessionManager&lt;/code&gt;实现了以下几种&lt;code&gt;NSURLSession&lt;/code&gt;的代理方法&lt;/p&gt;
&lt;h4 id=&quot;NSURLSessionDelegate&quot;&gt;&lt;a href=&quot;#NSURLSessionDelegate&quot; class=&quot;headerlink&quot; title=&quot;NSURLSessionDelegate&quot;&gt;&lt;/a&gt;&lt;code&gt;NSURLSessionDelegate&lt;/code&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;URLSession:didBecomeInvalidWithError:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URLSession:didReceiveChallenge:completionHandler:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URLSessionDidFinishEventsForBackgroundURLSession:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;NSURLSessionTaskDelegate&quot;&gt;&lt;a href=&quot;#NSURLSessionTaskDelegate&quot; class=&quot;headerlink&quot; title=&quot;NSURLSessionTaskDelegate&quot;&gt;&lt;/a&gt;&lt;code&gt;NSURLSessionTaskDelegate&lt;/code&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;URLSession:willPerformHTTPRedirection:newRequest:completionHandler:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URLSession:task:didReceiveChallenge:completionHandler:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URLSession:task:didCompleteWithError:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;NSURLSessionDataDelegate&quot;&gt;&lt;a href=&quot;#NSURLSessionDataDelegate&quot; class=&quot;headerlink&quot; title=&quot;NSURLSessionDataDelegate&quot;&gt;&lt;/a&gt;&lt;code&gt;NSURLSessionDataDelegate&lt;/code&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;URLSession:dataTask:didReceiveResponse:completionHandler:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URLSession:dataTask:didBecomeDownloadTask:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URLSession:dataTask:didReceiveData:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URLSession:dataTask:willCacheResponse:completionHandler:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;NSURLSessionDownloadDelegate&quot;&gt;&lt;a href=&quot;#NSURLSessionDownloadDelegate&quot; class=&quot;headerlink&quot; title=&quot;NSURLSessionDownloadDelegate&quot;&gt;&lt;/a&gt;&lt;code&gt;NSURLSessionDownloadDelegate&lt;/code&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;URLSession:downloadTask:didFinishDownloadingToURL:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesWritten:totalBytesExpectedToWrite:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;###成员&lt;/p&gt;
&lt;p&gt;####属性&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;AFURLSessionManager&lt;/code&gt;中，主要的三个属性如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14451544109695.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;session&lt;/code&gt;实现了会话，&lt;code&gt;operationQueue&lt;/code&gt;是一个操作队列。&lt;code&gt;responseSerializer&lt;/code&gt;是实现了&lt;code&gt;AFURLResponseSerialization&lt;/code&gt;协议的一个对象。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Manager中还包括了安全协议的对象和连通性的对象。这两个类将在后面谈到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14451545558576.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下面是Task的内容，包含与当前&lt;code&gt;Session&lt;/code&gt;中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14451547233232.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;回调块队列，包括了在主队列和私有队列的两个部分&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14451548418504.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;####方法&lt;/p&gt;
&lt;p&gt; 初始化方法&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/media/14455211888103.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;创建一个&lt;code&gt;NSURLSessionDataTask&lt;/code&gt;数据性任务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455212385758.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;创建&lt;code&gt;`NSURLSessionUploadTask&lt;/code&gt; 上传任务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455213126912.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/media/14455213190110.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;创建&lt;code&gt;NSURLSessionDownloadTask&lt;/code&gt; 下载任务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455213738134.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/media/14455213826398.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;获得一个特定任务的&lt;code&gt;progress进度&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455214651069.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/media/14455214692883.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/media/14455214742512.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;Session Delegate Callbacks 设置会话代理回调&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455217046547.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/media/14455217113671.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Task Delegate Callbacks 设置任务代理回调&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当任务需要一个新的请求体发送给服务器的时候。&lt;br&gt;&lt;img src=&quot;/media/14455219470133.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当HTTP请求回调有重定向的的话设置这个Block&lt;br&gt;&lt;img src=&quot;/media/14455219533707.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当一个请求需要特别的鉴权的时候设置这个challenge&lt;br&gt;&lt;img src=&quot;/media/14455219599178.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设置一个block去追踪上传进度&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455658294340.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设置一个block当任务完成后执行&lt;br&gt;&lt;img src=&quot;/media/14455658635389.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;####&lt;code&gt;Setting Data Task Delegate Callbacks 设置数据任务代理的回调&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置一个在数据任务获得response的时候回调block&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455662011592.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设置一个block当数据任务变成下载的任务的时候执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455662317310.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设置一个block当数据任务获得到数据的时候&lt;br&gt;&lt;img src=&quot;/media/14455662434172.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设置一个block绝对是否缓存数据任务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455662958106.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;####&lt;code&gt;Download Task Delegate Callbacks 下载任务代理回调&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置block当下载任务完成下载后&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455666105437.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设置block去追踪下载任务进度情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455666301025.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设置block当下载任务执行/恢复的时候 执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14455666958363.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;头文件的内容基本就是以上的了。可以看到整个AF的体系非常清晰完整，没有多余的东西，头文件只暴露了应该暴露的东西，值得我们去学习。&lt;/p&gt;
&lt;p&gt;##使用的例子&lt;/p&gt;
&lt;p&gt;###使用&lt;code&gt;AFURLSessionManager&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从源码中可以看到，&lt;code&gt;AFURLSessionManager&lt;/code&gt;实现了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Objective-c&quot;&gt;NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate, NSSecureCoding, NSCopying
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先需要设置url和NSURLConfirguration&lt;/p&gt;
&lt;p&gt;这里是使用百度API商店的公开API&lt;br&gt;&lt;img src=&quot;/media/14453928846040.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后初始化Manager&lt;img src=&quot;/media/14453929237373.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设置ResponseSerializer&lt;br&gt;&lt;img src=&quot;/media/14453931412125.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;初始化request&lt;br&gt;&lt;img src=&quot;/media/14453932169242.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;对request进行相关设置&lt;br&gt;&lt;img src=&quot;/media/14453932396509.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;根据request生成对应的&lt;code&gt;NSURLSessionTask&lt;/code&gt;。&lt;br&gt;&lt;img src=&quot;/media/14453935717679.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;执行任务&lt;br&gt;&lt;img src=&quot;/media/14453936154108.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;来看看执行后的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14453937344699.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里由于使用的&lt;code&gt;AFHTTPResponseSerializer&lt;/code&gt;(API的问题，仅仅支持text/plain)所以在获取的数据后，我们自己要json序列化。如果是设计好的API,直接使用&lt;code&gt;AFJSONRequestSerializer&lt;/code&gt;就可以在回调中获取到json格式的数据了。&lt;/p&gt;
&lt;p&gt;可以看到，整个使用还是很方便的。我们可以根据自己的需求配置不同设置。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##从3.0开始&lt;/p&gt;
&lt;p&gt;一转眼，AF已经更新到了3.0版本。目前cocoapods上的最新版本是3.0 beta1。在3.0的版本里面，AF全面地使用&lt;code&gt;NSURLSession&lt;/code&gt;代替了&lt;code&gt;NSURLConnection&lt;/code&gt;。之
    
    </summary>
    
      <category term="Network" scheme="http://csbzhixing.github.io/categories/Network/"/>
    
    
  </entry>
  
  <entry>
    <title>改变，一刻都不能停止</title>
    <link href="http://csbzhixing.github.io/2015/10/09/other/"/>
    <id>http://csbzhixing.github.io/2015/10/09/other/</id>
    <published>2015-10-09T05:36:46.000Z</published>
    <updated>2015-10-09T06:03:11.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;杂谈，生活，学习&quot;&gt;&lt;a href=&quot;#杂谈，生活，学习&quot; class=&quot;headerlink&quot; title=&quot;杂谈，生活，学习&quot;&gt;&lt;/a&gt;杂谈，生活，学习&lt;/h1&gt;&lt;p&gt;##从iTunes store说起&lt;/p&gt;
&lt;p&gt;9.30号凌晨，在我半睡半醒的时候，准备更新下一些APP。然后就发现了iTunes 提醒我要同意新的协议，当时很困就睡着了，没有想太多。早上起来，发现apple music可以用了！没错！免费三个月，续费十块钱一个月！然后看了下电影。一堆一块钱的正版电影你相信吗？？！。&lt;/p&gt;
&lt;p&gt;好吧，为何我那么激动吗，对于很多人是不理解的。相对于一些必须消费的商品。图书，音乐，电影，游戏，软件这些虚拟服务，在许多人眼里就是免费的午餐。从来没想到过我们为何要去为这些东西掏钱。所以，很多人并不看好苹果这次在大陆推行的这些服务。然而我认为，苹果这是以一己之力，将要改变中国人对版权的认识。为什么这么说？价格说明一切。&lt;/p&gt;
&lt;p&gt;如今，出去吃顿饭一个人动不动上百，一杯果汁奶茶都几十块钱的时代，却还在为一个优秀APP几十块钱而烦恼。入手新手机后，买了几款APP。其中有一个第三方微博客户端墨客。我家里很不理解为什么有微博客户端我还会去选择掏钱去买。我觉得，仅仅是干净舒适的UI设计就足够我花这个钱，而且再不用看到一大堆乱七八糟的推广，能够最快的看到自己需要的内容，这一切仅仅18块钱，难道不比买一包烟，喝一杯果汁来的值得吗？&lt;/p&gt;
&lt;h2 id=&quot;新的工作，一样的生活&quot;&gt;&lt;a href=&quot;#新的工作，一样的生活&quot; class=&quot;headerlink&quot; title=&quot;新的工作，一样的生活&quot;&gt;&lt;/a&gt;新的工作，一样的生活&lt;/h2&gt;&lt;p&gt;国庆第一天，把宿舍几乎所有的东西都带回家了。8号到了新公司报道。在国庆的时候，好好的回顾了下以前的堕落的生活，顺便整理了下自己的学习和工作上的问题。发现自己任然有许多地方的欠缺。牛逼的人，总是有强迫症的。而我，似乎不能称为牛逼的人，就是因为没有强迫症。面对代码，能Copy/Paste的话就做了，没有想到怎么去重构，去思考怎么做的更好。面对重复的东西，总是尽可能去避免。不愿意耐心的去解决的困难的问题，总是想依赖其他的人的经验来解决。不踏过千千万万个坑，怎么能说自己是个出色的工程师？总不能一辈子都在搬砖吧。养成强迫症，才不会总是固守原来的生活。&lt;/p&gt;
&lt;p&gt;##深度和广度&lt;/p&gt;
&lt;p&gt;在面试的时候，和这家公司的团队老大有一番交流让我感触很深。搞技术的，除了要有深度，还要有广度。对于广度和深度，之前也和某老大谈过。全栈好不好，这个话恐怕只有自己到了那个层次才能谈谈。毕竟现在，哪怕仅仅是一个方面，自己都很难保证能解决多数的问题。如今进入到了这个团队，感受到了身边的牛人还真的很多，许多都是多面手。看来不能仅仅把自己的困在一个方面。多学多用给你才是王道。后面打算整理下自己的技能树，然后根据轻重来设计自己的学习路线。&lt;/p&gt;
&lt;p&gt;##让思维和身体都跑起来吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14443703278870.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;坚持跑步已经有了两个月。虽然中间因为各种原因停顿了几次，这个月的跑量一直没上去。然而现在固定了下来，也要恢复到之前的运动模式。身体的运动，也改善了我思考的模式。不再会因为因为小小的事情而去分心。执行力也越来越好，也容易控制自己的情绪了。思维跟随的身体，一起奔跑的感觉，实在是太好不过了。&lt;/p&gt;
&lt;p&gt;最后一句话，送给自己。&lt;/p&gt;
&lt;p&gt;##一切不变的，就是改变&lt;/p&gt;
&lt;p&gt;˙&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;杂谈，生活，学习&quot;&gt;&lt;a href=&quot;#杂谈，生活，学习&quot; class=&quot;headerlink&quot; title=&quot;杂谈，生活，学习&quot;&gt;&lt;/a&gt;杂谈，生活，学习&lt;/h1&gt;&lt;p&gt;##从iTunes store说起&lt;/p&gt;
&lt;p&gt;9.30号凌晨，在我半睡半醒的时候，准备更
    
    </summary>
    
      <category term="personal" scheme="http://csbzhixing.github.io/categories/personal/"/>
    
    
  </entry>
  
  <entry>
    <title>个人知识管理</title>
    <link href="http://csbzhixing.github.io/2015/09/29/update-self/"/>
    <id>http://csbzhixing.github.io/2015/09/29/update-self/</id>
    <published>2015-09-29T06:27:00.000Z</published>
    <updated>2015-09-29T08:00:42.000Z</updated>
    
    <content type="html">&lt;p&gt;9月25号上周五收到了新的iphone6s plus。在折腾了几天后，整理了出自己的一套效率工作系统，目前看来效果良好，不知道未来使用几个月是否会给自己带来不一样的体验。&lt;/p&gt;
&lt;p&gt;下面是系统大纲&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14435106554403.jpg&quot; alt=&quot;大纲&quot;&gt;&lt;/p&gt;
&lt;p&gt;##效率工具&lt;/p&gt;
&lt;p&gt;好的计划是成功的一般。在之前由于国内安卓机无法使用谷歌服务，许多需要谷歌服务框架的软件都用不了，一直以来都没有建立一个体系工具。入手iPhone之后，借助于VPN，能够很好的结合谷歌服务和苹果云服务了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sunrise。我能找到免费的日历里面最好的。能够同步iCloud和谷歌日历。能够跨平台。界面也很美观。能够同步iCloud日历就不用手动在sunrise上面添加行程，只需要在mac或者iPhone上面添加提醒事项就可以了。&lt;/li&gt;
&lt;li&gt;Noti:Do 限免入手的。小而美的TODO软件。能够同步到系统的提醒事项。使用简单方便。&lt;/li&gt;
&lt;li&gt;apple的提醒事项。系统内置的软件，对比了几个大而全的第三方软件后，我发现提醒事项已经能够满足多数的需求了，能够iCloud同步，非常方便。&lt;/li&gt;
&lt;li&gt;SimpleNote。简单好用的第三方笔记软件。没有使用自带note是因为同步出现了一些问题。SimpleNote同步也很方便，能够在web上使用也使得在Windows上也能使用。将一些需要备忘的比如邮箱，账号放入非常好。同时在iPhone上支持使用Touch ID加密，感觉太棒了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##存储&lt;/p&gt;
&lt;p&gt;网盘的使用参考了许多，最终选择了国内的坚果云和国外的DropBox&lt;/p&gt;
&lt;p&gt;##邮件&lt;/p&gt;
&lt;p&gt;在大学的时候，并没有很注意使用邮件，所有要邮件订阅的地方都是一个QQ邮箱就搞定了。后来发现其实邮件用处实在是太大了。不仅可以订阅消息，注册，沟通，还可以做计划，安排，备份（网盘）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GMail。这估计是所有Geek的第一选择。唯一的缺点就是要翻墙。而且我发现GMail的SMTP的服务器在mac上特别不好连接。GMail的账号可以通行所有谷歌服务，而且可以很便捷地登陆国外的网站服务。&lt;/li&gt;
&lt;li&gt;QQ。综合来看，现在国内邮箱服务做的最好的就是QQ邮箱了。没什么太大的槽点，后缀稍微low点，但是可以改成foxmail。&lt;/li&gt;
&lt;li&gt;apple mail.app 。苹果自带的邮箱软件。在这上面找了几个免费的，感觉都不是很好。许多人也说其实自带的就已经能够满足需求了。嗯，还是原生的好。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##资讯&lt;/p&gt;
&lt;p&gt;网络时代是信息大爆炸的时代，怎么根据自己的需求去订制整理咨询是很重要的。在辗转了一大咨询类APP以后，发现要么太复杂要么内容单一。最后决定通过RSS订阅来自己调整信息源。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;微博客户端 Moke。收费的客户端，18元人民币，少数几个花钱的APP。没有广告真的很清爽，有许多手势但是还没有掌握好。&lt;/li&gt;
&lt;li&gt;Pocket。对于Pocket，我是作为文档存放整理的地方。好的文章先加入到Pocket中，然后根据内容分类，后面决定每周花时间整理一个分类。&lt;/li&gt;
&lt;li&gt;知乎。上了知乎身体一天不如一天了。。。开玩笑的。知乎还是有很多干货，需要自己去挖掘，但是随着用户群体的扩大，感觉回答的质量下降的很厉害，太多的耍机灵简直浪费我生命。。&lt;/li&gt;
&lt;li&gt;Feedly。RSS订阅软件。看中的就是他跨平台的能力。缺点是要翻墙。。。而且很多功能必须付费才开通（我想分享我的订阅都要付费。。。）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;写作&quot;&gt;&lt;a href=&quot;#写作&quot; class=&quot;headerlink&quot; title=&quot;写作&quot;&gt;&lt;/a&gt;写作&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;MWeb。又是一个付费应用，而且很不便宜。。9.9刀。但是我感觉物超所值。功能很强大的MarkDown写作软件。现在习惯了用MWeb觉得Word真的。。跟不上他的设计了。&lt;/li&gt;
&lt;li&gt;SimpleNote。一些简单的备忘，临时的灵感记录，上面已经讲过了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##为什么要建立个人知识管理系统&lt;/p&gt;
&lt;p&gt;在最近几个月的学习中，我发现自己接收了太多的信息而不能很好的吸收，时间安排也太随性浪费了很多时间。既然买了新手机，不能和一般人一样作为一个娱乐工具，也应该去帮助自己提高。所以在做了一番工作后，自己设计了这一个系统，可能不完善，很简单，但也是个开始。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;9月25号上周五收到了新的iphone6s plus。在折腾了几天后，整理了出自己的一套效率工作系统，目前看来效果良好，不知道未来使用几个月是否会给自己带来不一样的体验。&lt;/p&gt;
&lt;p&gt;下面是系统大纲&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/144351065544
    
    </summary>
    
      <category term="personal" scheme="http://csbzhixing.github.io/categories/personal/"/>
    
    
  </entry>
  
  <entry>
    <title>多线程开发详谈</title>
    <link href="http://csbzhixing.github.io/2015/09/25/thread/"/>
    <id>http://csbzhixing.github.io/2015/09/25/thread/</id>
    <published>2015-09-25T01:49:52.000Z</published>
    <updated>2015-10-23T02:36:56.000Z</updated>
    
    <content type="html">&lt;p&gt;按照计划，这篇文章主要谈iOS下的并发编程。&lt;/p&gt;
&lt;p&gt;之前的文章已经谈过了GCD的实现，包括苹果在GCD之上实现的NSOperation。但是在几次面试后发现，仅仅了解API还不够，要去深入的了解整个运行的机制。只有对整个系统有了更深刻的了解，才能不被API给限制住。&lt;/p&gt;
&lt;p&gt;##并发&lt;/p&gt;
&lt;p&gt;并发，概念就是同时运行多个任务。这些任务可以以分时的方式运行在单核CPU上面，也可以以真正的并发运行在多核CPU上面。&lt;/p&gt;
&lt;p&gt;实现并发，不仅可以最大化地利用硬件的性能，也可以提高程序的功能。&lt;/p&gt;
&lt;p&gt;###线程&lt;/p&gt;
&lt;p&gt;&lt;code&gt;线程(thread)&lt;/code&gt;是组成进程的子单元，操作系统可以对线程进行单独的调用。在苹果系统上的API都是以线程为单元进行调度的。&lt;/p&gt;
&lt;p&gt;多线程运行不仅能够在多核CPU上运行，也可以仅仅运行在单核CPU上。通过CPU分时，系统将极小的时间片分配给不同线程，让用户以为是多任务运行的。但是通过分时的效果不如多线程直接运行在多核CPU上。&lt;/p&gt;
&lt;p&gt;通过使用&lt;code&gt;Instruments&lt;/code&gt;中的&lt;code&gt;CPU strategy view&lt;/code&gt;可以观察代码如何在多核CPU运行的。&lt;/p&gt;
&lt;p&gt;##并发变成的API&lt;/p&gt;
&lt;p&gt;在之前的文章已经谈过了高层封装的两种，这里的重点不是如何使用API。&lt;/p&gt;
&lt;p&gt;在苹果的多线程中，有以下API供我们使用，从底层到高层一次如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;pthread&lt;/li&gt;
&lt;li&gt;NSThread, 苹果在pthread上的封装&lt;/li&gt;
&lt;li&gt;Grand Central Dispatch（GCD）&lt;/li&gt;
&lt;li&gt;Operation Queues&lt;/li&gt;
&lt;li&gt;Run Loops&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里想重点谈一下Run Loops。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Run Loops&lt;/code&gt;不同于&lt;code&gt;GCD&lt;/code&gt;或者&lt;code&gt;Operation Queues&lt;/code&gt;一样的并发机制，因为&lt;code&gt;Run Loops&lt;/code&gt;并不能并行执行任务。不过在主dispatch/operation中，Run Loops提供了一种异步执行代码的机制。通过Run Loops，我们不必担心并发中的各种陷阱，就能&lt;code&gt;异步&lt;/code&gt;执行任务。&lt;/p&gt;
&lt;p&gt;在主线程中，每一个 Cocoa 和 CocoaTouch 程序中，Main run loop都是扮演了最重要的角色。因为是run loop 来处理相关的内核事件的。&lt;/p&gt;
&lt;p&gt;线程和run loop是一一对应的。线程在创建的时候并没有run loop，如果不主动获取，那run loop就不会存在。Run Loop的创建在第一次获取的时候，销毁在线程结束的时候。除了主线程外，只能在一个线程的内部获取run loop。&lt;/p&gt;
&lt;p&gt;对于run loop的详细，又是一篇很长的文章来说了。这里就不详细说了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;按照计划，这篇文章主要谈iOS下的并发编程。&lt;/p&gt;
&lt;p&gt;之前的文章已经谈过了GCD的实现，包括苹果在GCD之上实现的NSOperation。但是在几次面试后发现，仅仅了解API还不够，要去深入的了解整个运行的机制。只有对整个系统有了更深刻的了解，才能不被API给限制住。
    
    </summary>
    
      <category term="base" scheme="http://csbzhixing.github.io/categories/base/"/>
    
    
  </entry>
  
  <entry>
    <title>json&amp;amp;xml</title>
    <link href="http://csbzhixing.github.io/2015/09/24/json-and-xml/"/>
    <id>http://csbzhixing.github.io/2015/09/24/json-and-xml/</id>
    <published>2015-09-24T08:44:36.000Z</published>
    <updated>2015-09-24T09:07:01.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;网络传输格式-JSON-amp-XML&quot;&gt;&lt;a href=&quot;#网络传输格式-JSON-amp-XML&quot; class=&quot;headerlink&quot; title=&quot;网络传输格式 JSON &amp;amp; XML&quot;&gt;&lt;/a&gt;网络传输格式 JSON &amp;amp; XML&lt;/h1&gt;&lt;p&gt;第一次接触这两个格式还是在学校做一个财务管理系统的时候。在之前变成都是纯粹的单机编程，不设计到网络数据传输的问题。到了这个项目才开始考虑如何在服务器和客户端之间传输数据。项目中使用的是JSON，所以在这里先讲JSON的部分。&lt;/p&gt;
&lt;p&gt;##JSON&lt;/p&gt;
&lt;p&gt;JSON是一种轻量化的数据格式。他的特点就是方便已用。目前90%的网络传输都是依赖于JSON格式。&lt;/p&gt;
&lt;p&gt;首先来看看JSON格式是怎么样的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;
&amp;quot;access_token&amp;quot;: &amp;quot;ACCESS_TOKEN&amp;quot;,

   &amp;quot;expires_in&amp;quot;: 1234,

   &amp;quot;remind_in&amp;quot;:&amp;quot;798114&amp;quot;,

   &amp;quot;uid&amp;quot;:&amp;quot;12341234&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是一个常见的JSON格式。比较容易的看出，其实就是一种key-value的形式。&lt;/p&gt;
&lt;p&gt;key我们都好了解，是一个string。那么value就会有不一样的值。通过对比OC的对象，我们可以更容易的理解JSON中的数据类型。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;            JSON                    OC

            {}                        NSDictionary

            []                        NSArray

            &amp;quot;&amp;quot;                        NSString

           数字                      NSNumber


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;知道了JSON所对应的OC对象，我们就可以通过解析JSON对象，将相关的数据转换成OC对象来存储。在这里，介绍一种能够在本地模拟API的方式，这也是由于自己找不到很好的开发API所以想在本地能够模拟API的方式。&lt;/p&gt;
&lt;p&gt;##JSON Server 模拟 API&lt;/p&gt;
&lt;p&gt;###第一步 安装&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装Homebrew。这个可是个神器，能够管理mac上的第三方的库的工具。据说被作者写不出反转二叉树个谷歌拒了然后去了苹果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装node.js&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;brew install node&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装json-server&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;npm install -g json-server&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;根据需求创建JSON&quot;&gt;&lt;a href=&quot;#根据需求创建JSON&quot; class=&quot;headerlink&quot; title=&quot;根据需求创建JSON&quot;&gt;&lt;/a&gt;根据需求创建JSON&lt;/h2&gt;&lt;p&gt;安装完毕后，随便找个你喜欢的文件夹，创建一个JSON格式的文件，如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;JSON&quot;&gt;{
  &amp;quot;posts&amp;quot;: [
    { &amp;quot;id&amp;quot;: 1, &amp;quot;title&amp;quot;: &amp;quot;json-server&amp;quot;, &amp;quot;author&amp;quot;: &amp;quot;typicode&amp;quot; }
  ],
  &amp;quot;comments&amp;quot;: [
    { &amp;quot;id&amp;quot;: 1, &amp;quot;body&amp;quot;: &amp;quot;some comment&amp;quot;, &amp;quot;postId&amp;quot;: 1 }
  ],
  &amp;quot;profile&amp;quot;: { &amp;quot;name&amp;quot;: &amp;quot;typicode&amp;quot; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后保存。&lt;/p&gt;
&lt;p&gt;###启动JSON-Server&lt;/p&gt;
&lt;p&gt;通过命令&lt;code&gt;json-server --watch JSON文件的名字.json&lt;/code&gt;来启动Server&lt;/p&gt;
&lt;p&gt;到这里，我们就相当于在本地创建了一个服务器能够相应我们想对应的请求。&lt;/p&gt;
&lt;p&gt;以上面的的JSON文件为例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430769630713.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当然，功能不止这么一点，JSON-Server还有更多方式，详见github&lt;a href=&quot;https://github.com/typicode/json-server&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;json-server&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;##OC对象和JSON对象的转换&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过&lt;code&gt;NSJSONSerialization&lt;/code&gt;来序列化JSON.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;![](/media/14430773793672.jpg)


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出的结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430774045308.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;对比上面的JSON数据，我们可以看出解析的结果是正确的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过第三方库JSONKit来解析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 下载地址 &lt;a href=&quot;https://github.com/johnezang/JSONKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JSONKit&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/media/14430745214364.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用Mantle&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在项目中用的最多的方法，也觉得非常好用&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://github.com/Mantle/Mantle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mantle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在本地创建对应的OC类&lt;br&gt;&lt;img src=&quot;/media/14430784491980.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;实现相关的方法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430794069120.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;第三种是直接将JSON通过一定的方法转成了OC的类对象。在使用的时候感觉更方便。&lt;/p&gt;
&lt;p&gt;##XML&lt;/p&gt;
&lt;p&gt;虽然JSON在网络传输中有90%的使用率，但是我们依然不能放弃10%的XML是吧。&lt;/p&gt;
&lt;p&gt;XML全称是Extensible Markup Language，译作“可扩展标记语言”&lt;br&gt;跟JSON一样，也是常用的一种用于交互的数据格式&lt;br&gt;一般也叫XML文档（XML Document）&lt;/p&gt;
&lt;p&gt;下面是一个典型的XML文件的结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;一个元素包括了开始标签和结束标签
拥有元素内容：&amp;lt;city&amp;gt;上海&amp;lt;/city&amp;gt;
没有元素内容：&amp;lt;city&amp;gt;&amp;lt;/city&amp;gt;
没有元素内容的简写：&amp;lt;city/&amp;gt; 

一个元素可以嵌套若干个子元素（不能出现交叉嵌套）
&amp;lt;citys&amp;gt;
    &amp;lt;city&amp;gt;
        &amp;lt;name&amp;gt;上海&amp;lt;/name&amp;gt;
        &amp;lt;weather&amp;gt;大暴雨&amp;lt;/weather&amp;gt;
          &amp;lt;air&amp;gt;舒适&amp;lt;/air&amp;gt;
    &amp;lt;/city&amp;gt;
&amp;lt;/citys&amp;gt;

规范的XML文档最多只有1个根元素，其他元素都是根元素的子孙元素
XML中的所有空格和换行，都会当做具体内容处理

一个元素可以拥有多个属性，属性值必须用 双引号&amp;quot;&amp;quot; 或者 单引号&amp;#39;&amp;#39; 括住。
&amp;lt;city name=&amp;quot;上海&amp;quot; weather=&amp;quot;大暴雨&amp;quot; air=&amp;quot;舒适&amp;quot; /&amp;gt;


属性表示的信息也可以用子元素来表示，比如

   &amp;lt;city&amp;gt;
        &amp;lt;weather&amp;gt;大暴雨&amp;lt;/weather&amp;gt;
          &amp;lt;air&amp;gt;舒适&amp;lt;/air&amp;gt;
    &amp;lt;/city&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解析XML有两种方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DOM解析：一次性将整个XML文档加载进内存，比较适合解析小文件&lt;/li&gt;
&lt;li&gt;SAX解析：从根元素开始，按顺序一个元素一个元素往下解析，比较适合解析大文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在iOS SDK里面，提供了两种解析的框架&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;NSXMLParser：它是基于objective-c语言的sax解析框架，是ios sdk默认的xml解析框架，不支持dom模式。&lt;/li&gt;
&lt;li&gt;libxml2: 它是基于c语言的xml解析器，被苹果整合在ios sdk中，支持sax和dom模式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同样，第三方也有许多解析XML的库。这里不打算讲第三方的，一个XML使用的比较少，一个使用SDK自身的效率往往已经非常好了。&lt;/p&gt;
&lt;p&gt;###NSXMLParser&lt;/p&gt;
&lt;p&gt;NSXMLParser属于SAX解析，是从上往下依次解析每个元素，在解析到每个元素的时候会通知代理，所以使用NSXMLParser必须遵守他的协议。&lt;br&gt;使用非常简单&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430815879826.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;从当前项目读取XML文件，读出数据，穿件解析器，设置代理，开始解析。&lt;/p&gt;
&lt;p&gt;XML文件内容如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430816475695.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;设置代理后，我们要实现代理方法，主要有以下方法，直接上图了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430816906329.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430817012681.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430833160910.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430833236999.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;###libxml2&lt;/p&gt;
&lt;p&gt;重点在于导入libxml2的库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430836046841.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430836140287.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430836178120.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430836230051.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14430836285068.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;编译项目，通过了就没问题了。&lt;/p&gt;
&lt;p&gt;用法参见&lt;a href=&quot;https://github.com/neonichu/GDataXML&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;##总结&lt;/p&gt;
&lt;p&gt;在实际使用中，还JSON用的更多，所以对于JSON的解析过程要更加了解。对于XML，有一些公司任然会使用，而一些现存的数据也会用XML存储，所有也要有一定的了解。&lt;/p&gt;
&lt;p&gt;这篇文章讲解了在网络通信中数据的格式。下一篇的话就进入iOS内如何进行网络通信了。虽然使用AFNetWorking已经有段时间了，但是对内部整个机制并不了解，要好好补课了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;网络传输格式-JSON-amp-XML&quot;&gt;&lt;a href=&quot;#网络传输格式-JSON-amp-XML&quot; class=&quot;headerlink&quot; title=&quot;网络传输格式 JSON &amp;amp; XML&quot;&gt;&lt;/a&gt;网络传输格式 JSON &amp;amp; XML&lt;/h1&gt;&lt;
    
    </summary>
    
      <category term="Network" scheme="http://csbzhixing.github.io/categories/Network/"/>
    
    
  </entry>
  
  <entry>
    <title>重新认识ARC</title>
    <link href="http://csbzhixing.github.io/2015/09/22/arc/"/>
    <id>http://csbzhixing.github.io/2015/09/22/arc/</id>
    <published>2015-09-22T09:48:06.000Z</published>
    <updated>2015-09-24T09:04:36.000Z</updated>
    
    <content type="html">&lt;p&gt;第一次接触ARC还是在第一次拿到项目的时候。学习OC的时候使用的教材主要是通过MRC来讲解Retain Counting(引用计数)的。后面只是简单的了解了下ARC是编译器在编译的过程中自动去估算对象的生命周期来自动添加retain和realse的。解放了双手，也就没有什么动力去研究了。现在得空了，是时候增强自己的技能树。当前的目标如下&lt;/p&gt;
&lt;p&gt;&amp;lt;!--more--&amp;gt;  
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;增加网络编程的相关知识&lt;ul&gt;
&lt;li&gt;TCP/IP HTTP HTTPS 协议的学习和了解&lt;/li&gt;
&lt;li&gt;JSON和XML的解析&lt;/li&gt;
&lt;li&gt;iOS自身关于网络请求相关的类和API&lt;/li&gt;
&lt;li&gt;第三方库AFNetWorking源码阅读&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;增加iOS内核方面的知识&lt;ul&gt;
&lt;li&gt;内存基本知识和管理方式&lt;/li&gt;
&lt;li&gt;ARC&lt;/li&gt;
&lt;li&gt;进程线程&lt;/li&gt;
&lt;li&gt;RunTime&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单的看是两个大类七个点，但是感觉每一个点都非常多东西。目前暂时把1.1的点给补完了。不过任然需要投入大量的时间去复习。这里打算整合2.1和2.2。&lt;/p&gt;
&lt;p&gt;##内存管理&lt;br&gt;学过计算机基础的人对于内存都不陌生，哪怕是没有计算机基础的人也明白内存对于电脑（终端）的重要性。内存管理，就是在程序运行的过程中，申请，使用，释放内存的过程。程序写的好不好，就看你在完成功能的同时是不是使用了尽可能少的内存。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;堆和栈&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在内存中，有两个重要的概念，分别是&lt;code&gt;堆和栈&lt;/code&gt;。这里不仅仅指代他们的数据结构。我们知道，一个函数执行的时候，他会被压入栈中。栈中的内存单元保存了函数的返回地址，局部变量，传参等数据。当函数被弹出栈的时候，一切数据都会被销毁。而&lt;code&gt;堆&lt;/code&gt;上的数据是由开发者自行申请管理的，生命周期由开发者自行掌握。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;引用计数&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;学过OC的人都知道，在OC中管理内存的方法是&lt;code&gt;引用计数&lt;/code&gt;(Retain Counting)。通过对堆和栈的了解，我们可以得出OC上的对象&lt;em&gt;都是在堆上&lt;/em&gt;的。&lt;/p&gt;
&lt;p&gt;在苹果开发文档里面有一张图很好的说明的通过引用计数来管理对象生命周期的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14429735006902.jpg&quot; alt=&quot;引用计数&quot;&gt;&lt;/p&gt;
&lt;p&gt;同样，引用计数也遵循几大内存管理原则&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;谁申请谁拥有&lt;/li&gt;
&lt;li&gt;肯以申请拥有一个存在的对象&lt;/li&gt;
&lt;li&gt;当不需要的再拥有对象的时候，申请释放&lt;/li&gt;
&lt;li&gt;不能释放不属于自己没有拥有的对象&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##Automatic Reference Counting (ARC)&lt;/p&gt;
&lt;p&gt;在学习iOS开发半年后，ARC给我留下了很深的印象。ARC是苹果在引用计数的基础上改善了编译器实现的功能。要了解ARC，首先要看看在没有ARC之前开发者是怎么去通过引用计数管理的。&lt;/p&gt;
&lt;p&gt;在ARC之前，我们统称为&lt;code&gt;MRC（Manual Reference Counting&lt;/code&gt;，即手动引用技术。通过调用&lt;code&gt;retain&lt;/code&gt;和&lt;code&gt;release&lt;/code&gt;来管理对象的生命周期。有了ARC之后，在编译的过程中，编译器可以根据上下文估算对象的生命周期，以此来自动的添加&lt;code&gt;retain&lt;/code&gt;和&lt;code&gt;release&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;注意，ARC只对OC对象有作用，对于C的类型对象不则按照C的内存管理的方法去管理。&lt;/p&gt;
&lt;p&gt;如果在工程中开启了使用ARC，那么就要遵循ARC定义的一些规范&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不能显示的调用&lt;code&gt;dealloc&lt;/code&gt;,&lt;code&gt;ratain&lt;/code&gt;,&lt;code&gt;release&lt;/code&gt;,&lt;code&gt;retainCount&lt;/code&gt;,&lt;code&gt;autoRelease&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果要复写&lt;code&gt;dealloc&lt;/code&gt;方法，不需要显示调用&lt;code&gt;[super dealloc]&lt;/code&gt;方法。&lt;/li&gt;
&lt;li&gt;不能再使用&lt;code&gt;AutoReleasepool&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;ARC下的修饰符&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在@Property 中，有四种修饰符是ARC提供的，他们分别是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;strong&lt;/li&gt;
&lt;li&gt;weak&lt;/li&gt;
&lt;li&gt;unsafe_unretained&lt;/li&gt;
&lt;li&gt;__autoreleasing&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中，重点来谈谈strong和weak&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;strong。我们理解为强引用。当前的对象实际拥有这个对象。默认情况下ARC使用的strong来修饰。&lt;/li&gt;
&lt;li&gt;weak。相对于strong的强引用，weak指的是弱引用。当引用的对象被释放掉的时候，当前引用对象会被自动置nil。weak通常被用来解决循环引用的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;__autoreleasing&lt;/code&gt;和&lt;code&gt;__unsafe_unretained&lt;/code&gt;在实际应用中是很少的。&lt;code&gt;__unsafe_unretained&lt;/code&gt;是为了兼容iOS4之前的版本，现在基本上不会使用了，主要是为了实现weak的功能。&lt;code&gt;__autoreleasing&lt;/code&gt;是表示在autorelease pool中自动释放对象的引用。&lt;/p&gt;
&lt;h2 id=&quot;block-在ARC下&quot;&gt;&lt;a href=&quot;#block-在ARC下&quot; class=&quot;headerlink&quot; title=&quot;block 在ARC下&quot;&gt;&lt;/a&gt;block 在ARC下&lt;/h2&gt;&lt;p&gt;block在之前已经小小的讨论过了，出现的几个问题都有谈论到，这里主要从ARC的角度上再谈一谈。&lt;/p&gt;
&lt;p&gt;block在ARC下最特殊的地方就是怎么去解决循环引用。在block的篇章中没有很详细讨论，原因也是没从内存的角度来看。这里详细讲下循环引用产生原因和在ARC下解决循环引用的方法。&lt;/p&gt;
&lt;p&gt;&amp;gt;&lt;br&gt;You can use lifetime qualifiers to avoid strong reference cycles. For example, typically if you have a graph of objects arranged in a parent-child hierarchy and parents need to refer to their children and vice versa, then you make the parent-to-child relationship strong and the child-to-parent relationship weak. Other situations may be more subtle, particularly when they involve block objects.&lt;br&gt;&amp;gt;&lt;br&gt;In manual reference counting mode, &lt;strong&gt;block id x; has the effect of not retaining x. In ARC mode, &lt;/strong&gt;block id x; defaults to retaining x (just like all other values). To get the manual reference counting mode behavior under ARC, you could use &lt;strong&gt;unsafe_unretained &lt;/strong&gt;block id x;. As the name &lt;strong&gt;unsafe_unretained implies, however, having a non-retained variable is dangerous (because it can dangle) and is therefore discouraged. Two better options are to either use &lt;/strong&gt;weak (if you don’t need to support iOS 4 or OS X v10.6), or set the __block value to nil to break the retain cycle.&lt;br&gt;&amp;gt;&lt;br&gt;The following code fragment illustrates this issue using a pattern that is sometimes used in manual reference counting.&lt;/p&gt;
&lt;p&gt;上面是苹果官方文档对循环引用的解释。通过引用计数，我们了解到，如果有两个对象，对彼此都是强引用的话，双方都无法释放对方，也就无法释放delloc对象，最终就造成了死循环。在iOS5以下的版本里面，我们可以通过手动使用&lt;code&gt;unsafe_unretained&lt;/code&gt;来使其中一个变量变成野指针。而在ARC下，我们通过使用weak来修饰其中一个变量，这样在block中就不存在双方强引用的抢矿。&lt;/p&gt;
&lt;p&gt;但是，上面的处理方法有个问题。我们不知道weak修饰的对象什么时候会被释放掉了，有可能在执行block里面的对象在之前就已经被释放掉了。在AFNetWorking中，提供了一个非常好的解决思路&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14429947239639.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面方法中，在block外先将self用&lt;code&gt;weak&lt;/code&gt;引用一个weakSelf，进入block后再使用一个&lt;code&gt;_strong_typeof&lt;/code&gt;去创建一个strong引用对象。这样的做法既能避免产生循环引用，也能避免weak对象提前被释放掉。&lt;/p&gt;
&lt;p&gt;##ARC与Toll-Free Bridging&lt;/p&gt;
&lt;p&gt;Toll-Free Briding保证了在程序中，可以方便和谐的使用Core Foundation类型的对象和Objective-C类型的对象。但是，我们知道，到了ARC的时候，两者的内存管理方法不同了。对于一种对象，我们不能用该两种内存管理方法去管理。所以在进入ARC之后，Toll-Free Bridging也进行了相应的变化。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;__bridge&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;只是申明了类型转变，并没有改变内存管理方法。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;__bridge_retained（修饰符） or CFBridgingRetain（函数）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;表示将指针类型转变的同时，将内存管理的责任由原来的Objective-C交给Core Foundation来处理，也就是，将ARC转变为MRC。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;__bridge_transfer（修饰符） or CFBridgingRelease（函数）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这个修饰符和函数的功能和上面那个__bridge_retained相反，它表示将管理的责任由Core Foundation转交给Objective-C，即将管理方式由MRC转变为ARC。&lt;/p&gt;
&lt;p&gt;上面就是要谈的ARC的内容了。其实ARC的坑比起MRC已经少了很多了，对于我们可怜的程序员来说已经是很大的解放了。&lt;/p&gt;
&lt;p&gt;这里对于内存管理仅仅是基于OC简单的谈了谈，觉得还是不够深刻，主要是自己在这方面的知识的确很欠缺。读了&lt;br&gt;&lt;a href=&quot;http://casatwy.com/ccheng-xu-de-nei-cun-guan-li.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;C程序的内存管理&lt;/a&gt;这篇文章学到了很多，在这里也安利一下。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;第一次接触ARC还是在第一次拿到项目的时候。学习OC的时候使用的教材主要是通过MRC来讲解Retain Counting(引用计数)的。后面只是简单的了解了下ARC是编译器在编译的过程中自动去估算对象的生命周期来自动添加retain和realse的。解放了双手，也就没有什么
    
    </summary>
    
      <category term="Objective-C" scheme="http://csbzhixing.github.io/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>IP TCP HTTPs 随便谈</title>
    <link href="http://csbzhixing.github.io/2015/09/18/title/"/>
    <id>http://csbzhixing.github.io/2015/09/18/title/</id>
    <published>2015-09-18T08:48:55.000Z</published>
    <updated>2015-09-24T09:04:35.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;IP-TCP-HTTPs-随便谈&quot;&gt;&lt;a href=&quot;#IP-TCP-HTTPs-随便谈&quot; class=&quot;headerlink&quot; title=&quot;IP TCP HTTPs 随便谈&quot;&gt;&lt;/a&gt;IP TCP HTTPs 随便谈&lt;/h1&gt;&lt;p&gt;在总结自己的技能书的缺点后，决定优先补充自己在计算机网络上知识的漏洞。现在互联网企业，离开了互联网什么都不是。对互联网，普通人可能停留在概念和使用上，而开发人员应该去深入的了解运行进制，进而去优化自己开发的产品。这篇文章，主要是记录自己最近看的一些资料的笔记。&lt;br&gt;&amp;lt;!--more--&amp;gt;  &lt;/p&gt;
&lt;p&gt;##IP 协议&lt;/p&gt;
&lt;p&gt;IP协议，是网络协议（Internet Protocol）的缩写。IP协议是互联网众多协议的基础。&lt;/p&gt;
&lt;p&gt;IP协议实现了解&lt;code&gt;*分组交换网络*&lt;/code&gt;。在协议下，每个机器被称为&lt;code&gt;*主机*&lt;/code&gt;，IP协议明确了主机之间数据包的传输方式。&lt;/p&gt;
&lt;p&gt;数据包，也就是一段二进制数据，包含了传输源的主机的信息。IP协议的特点是&lt;code&gt;*尽力服务*&lt;/code&gt;（best effort），提供有效的服务并尽可能的传输。这说明，在传输过程中，可能会丢失数据包，也可能传输了多个相同的数据包。&lt;/p&gt;
&lt;p&gt;IP 网络中的主机都配有自己的地址，被称为&lt;code&gt;*IP 地址*&lt;/code&gt;。每个数据包中都包含了源主机和目标主机的 IP 地址。IP 协议负责路径计算，即 IP 数据包在网络中的传输传输时，数据包所经过的每一个主机节点都会读取数据包中的目标主机地址信息，以便选择朝什么地方传送数据包。&lt;/p&gt;
&lt;p&gt;##蛋疼的IPv4&lt;/p&gt;
&lt;p&gt;如今，多数数据包任然使用的是IPv4（版本4），每一个IP地址都是32位的。比如192.168.1.1就是一个IPV4地址。我们可以算下，IPv4有多少个地址。。嗯，好像很多有43亿吗。。但是呢，到了10年的时候，就已经不到8%的了。。&lt;/p&gt;
&lt;p&gt;人们发现IPV4不够用啊，快用完了啊，用完了就不能加主机了啊！！！那怎么办，启用新的协议版本啊，所以除了个IPv6，将地址扩充到128位了。比如&lt;code&gt;2001:0db8:85a3:0042:1000:8a2e:0370:7334&lt;/code&gt;&lt;br&gt;就是一个IPv6的地址了。&lt;/p&gt;
&lt;p&gt;128位就是2的128次方个，据说够地球上每个沙子配一个IP了。但是呢，这个协议转换的很慢，目前基本国内的都是还是使用IPv4协议。。看来也不是很着急么。。&lt;/p&gt;
&lt;p&gt;##IP数据包的结构&lt;br&gt;一个IP数据包通常包括一个数据头部（header）和有效数据（payload）。有效数据自然是数据包中要传送的数据。而数据头部就是包含了一些传输数据相关的数据。&lt;/p&gt;
&lt;p&gt;####我们先来看个IPv4的头部&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/Screen%20Shot%202015-09-20%20at%2020.15.59.png&quot; alt=&quot;Screen Shot 2015-09-20 at 20.15.59&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，头部信息包含了当前版本的信息，payload采用的协议。Total Length 表明是有效数据加上头部信息长度的总长度。&lt;/p&gt;
&lt;p&gt;####在来看看一个IPv6的报头信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14427519874258.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;IPv6的头部长度固定到了40.同时IPv6可以链接下一个头部信息（Next Header）。&lt;/p&gt;
&lt;p&gt;##数据传输&lt;/p&gt;
&lt;p&gt;我们知道，在数据链路层对对所传输的数据帧数有限制，&lt;code&gt;*（MTU，最大传输单元）*&lt;/code&gt;。在IPv4的上，使用&lt;code&gt;*分片*&lt;/code&gt;来对数据包进行处理。具体来说，我们可以认为如果数据超过了最大传输单元，那么就会将数据切成几片。当数据到达目标主机后，可以根据分片的信息进行重组。当然，发送源可以选择不进行对数据进行&lt;code&gt;*分片*&lt;/code&gt;。如果超过了链路层最大传输单元又不进行&lt;code&gt;*分片*&lt;/code&gt;的话，发送源就会收到ICMP（Internet Control Message Protocol，Internet报文控制协议）的数据帧超长报告信息。&lt;/p&gt;
&lt;p&gt;在IPv6中，如果数据包超过了长度限制，路由会直接丢弃数据包（好狠）并且向ICMP6报告数据帧过长。然后数据源和目标源会根据这个特性来进行&lt;code&gt;路由发现&lt;/code&gt;，就是寻找两端之间最大传输单元的路由。找到最大传输单元的路由后，仅当此时数据包任然超过最大传输单元的时候，IPv6才会进行分片。`对于IPv6下的TCP来说，不会造成什么影响。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;到此，IP协议就到了一个段落了。IP协议是TCP协议的基础，因此了解是必须的。&lt;/p&gt;
&lt;p&gt;##TCP协议&lt;/p&gt;
&lt;p&gt;TCP协议是重头戏。TCP协议是重头戏。TCP协议是重头戏。重要的事情要说三遍。&lt;/p&gt;
&lt;p&gt;上面说了，IP协议是基于&lt;code&gt;尽可能服务&lt;/code&gt;的，那么TCP协议就是要基于IP协议，解决IP协议采用的不可靠传输引起的复杂的问题。因此，下面的重点就是来谈谈TCP连接的三个部分：建立连接，传输数据，断开连接的详细过程&lt;/p&gt;
&lt;p&gt;####TCP建立连接&lt;/p&gt;
&lt;p&gt;首先，我们要知道TCP连接是全双工的,是建立在两个主机之间的。每个连接都存在两种角色：&lt;code&gt;服务器端，监听连接&lt;/code&gt;，&lt;code&gt;客户端，主动连接服务器端&lt;/code&gt;。客户端主动连接服务器端被称为&lt;code&gt;active open(主动打开)&lt;/code&gt;。而服务器端这种监听连接的行为被称为&lt;code&gt;passive open(被动打开)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三次握手&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCP建立连接是一个确认和反复确认的过程，我们习惯统称为三次握手。这个地方也是几乎所有面试会问的地方，需要注意了。&lt;/p&gt;
&lt;p&gt;三次连接，具体的过程有语言描述为以下的过程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;客服端向服务器端发送SYN包和一个随机序列号X，表示本次的连接的身份。&lt;/li&gt;
&lt;li&gt;服务器端收到客服端发送的连接的请求以后，发送一个SYN-ACK包和一个确认ack号X+1(确认序列号X的连接请求确认)。此时服务器还会发送一个随机序列号Y，表示向客户端连接的请求。&lt;/li&gt;
&lt;li&gt;客户端收到服务器的回复后，会发送一个ACK包，一个确认号Y+1和序列号X+1给服务器。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;SYN包，为&lt;code&gt;synchronize sequence numbers (同步序列号)&lt;/code&gt;。用于确认两段传输数据的身份，确保数据包最后都达到了应该到的地方。在建立连接的时候，源和目标都需要确认&lt;code&gt;同步序列号&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;ACK包，为&lt;code&gt;acknowledgment (确认)&lt;/code&gt;。某一端接到数据后，通过回传序列号来确认收到报文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14428004882999.jpg&quot; alt=&quot;三次握手&quot;&gt;&lt;/p&gt;
&lt;p&gt;####传输数据&lt;/p&gt;
&lt;p&gt;建立连接，就是为了传输数据。发送端发出的报文都会带有一个序列号，与当前已传送的字节总数有关。接受端会根据已经接收的报文给发送端传送确认报文，确认信息同样在头部的缩写带的ACK。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14427976037921.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意的整个过程是双向的。两端都会持续的发送数据。X端发送的数据不会等到Y端发送确认后才发送下一个报文。&lt;/p&gt;
&lt;p&gt;TCP协议是可靠的传输协议，所以有一系列复杂的机制来进行具体的的拥塞控制。需要处理的问题如下:&lt;code&gt;丢失报文重发&lt;/code&gt;，&lt;code&gt;动态调整发送报文的频率&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流量控制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;流量控制的原则就是发送数据的一方的速度不能比接受数据一方的速度要快。接收方，也就是&lt;code&gt;接收窗口&lt;/code&gt;会告诉发送方自身&lt;code&gt;接收窗口&lt;/code&gt;数据缓冲区的大小。在tcp包，通过两个两个关键的字段可以得出接收窗口的大小:&lt;code&gt;win -- 窗口大小&lt;/code&gt;和&lt;code&gt;wscale -- 窗口发大因子&lt;/code&gt; 。如果win=65535 , wscale = 4，那么我们可以计算出接收窗口的大小是 64kB * 4 = 256kB。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拥塞控制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拥塞控制相比于流量控制要复杂一些。拥塞控制就是根据当前网络情况计算出当前网络数据传输的最佳速度。首先我们要认识到，最佳速度不一定就是要最快。一方面，我们希望以更快的速度传输数据。另一方面，由于传输的速度过快，导致大量的数据传入会使处理性能受到影响。在分组交换网络中有一个特点就是&lt;code&gt;超负荷崩溃&lt;/code&gt;。当负载过大的时候，数据包之间会产生拥塞，直接导致丢包率上升。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;拥塞控制需要充分考虑对流量的影响。RFC 5681 中对 TCP 拥塞控制有 6,000 字左右的阐述。发送方要时刻关注来自接收方的确认信息。要做到这点并不简单，有的时候还需要一定的妥协。要知道底部 IP 协议数据包是无序传输的，数据包会丢失也会重复。发送方需要评估 RTT 往返时间，然后基于 RTT 去确定是否收到了接收方的确认信息。重发数据包也有很大代价，除了连接延迟问题，网络的负载也会发生明显的波动。导致 TCP 需要不停的去适应当前网络情况。&lt;/p&gt;
&lt;p&gt;更重要的是，TCP 连接本身是易变的。除了数据传输，连接的两端还会不时的发送一些提醒和确认信息以便可以适当的调整状态来维持连接。&lt;/p&gt;
&lt;p&gt;基于这种一直在相互协调中的连接关系，TCP 连接往往会是短暂而低效的。在建立连接的初期，TCP 协议算法还不能完全了解当前网络状况。而在连接将要结束的时候，反馈给发送方的信息又可能不充分，这样就很难对连接状况做出实时的合理的评估。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;四次挥手，断开连接&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;建立连接是通过&lt;code&gt;三次握手&lt;/code&gt;，而释放连接是通过&lt;code&gt;四次握手&lt;/code&gt;。在最下方有图示解释整个过程。那么为什么需要四次握手才能释放连接呢？&lt;/p&gt;
&lt;p&gt;上文提到了，TCP是全双工的，因此每个方向上的连接需要单独关闭。这个原则就是当一方没有数据可以传送的时候，发送FIN来终止这一方的连接，但是另一方向上的数据仍然可以发送。当另一方向也发送了FIN的时候，整个连接才完全的关闭了。无论服务器端还是客户端都可以发送来FIN来主动关闭连接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/14428004433668.jpg&quot; alt=&quot;四次挥手&quot;&gt;&lt;/p&gt;
&lt;p&gt;##HTTPS&lt;/p&gt;
&lt;p&gt;之前的博文谈到了HTTP（超文本传输协议）。如今苹果操作系统iOS也升级到了iOS9。在iOS9中强制所有网络传输协议使用HTTPS。看来对HTTPS的了解是势在必行的了。&lt;/p&gt;
&lt;p&gt;HTTPS,实际上可以看作HTTP的加密版本。HTTPS将HTTP协议数据包放到SSL/TSL层加密后，在TCP/IP蹭去传输。到了目标源后，在SST/TSL将数据包解密，传递到HTTP层就是普通的HTTP数据包了。&lt;/p&gt;
&lt;p&gt;HTTPS = HTTP + SSL/TSL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SSL/TSL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于SSL/TSL，我们可以参考下面两篇文章：&lt;/p&gt;
&lt;p&gt;!&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;!&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单的来说，通过SSL/TSL四次握手，来解决下面三个问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数字证书：该证书包含了公钥等信息，一般是由服务器发给客户端，接收方通过验证这个证书是不是由信赖的CA签发，或者与本地的证书相对比，来判断证书是否可信；假如需要双向验证，则服务器和客户端都需要发送数字证书给对方验证；&lt;/li&gt;
&lt;li&gt;三个随机数：这三个随机数构成了后续通信过程中用来对数据进行对称加密解密的“对话密钥”。&lt;br&gt;首先客户端先发第一个随机数N1，然后服务器回了第    二个随机数N2（这个过程同时把之前提到的证书发给    客户端），这两个随机数都是明文的；而第三个随机    数N3（这个随机数被称为Premaster secret），    客户端用数字证书的公钥进行非对称加密，发给服务    器；而服务器用只有自己知道的私钥来解密，获取第    三个随机数。这样，服务端和客户端都有了三个随机    数N1+N2+N3，然后两端就使用这三个随机数来生    成“对话密钥”，在此之后的通信都是使用这个“对话    密钥”来进行对称加密解密。因为这个过程中，服务端    的私钥只用来解密第三个随机数，从来没有在网络中    传输过，这样的话，只要私钥没有被泄露，那么数据    就是安全的。&lt;/li&gt;
&lt;li&gt;加密通信协议：就是双方商量使用哪一种加密方式，假如两者支持的加密方式不匹配，则无法进行通信；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体的可以参考上面两篇文章的内容，去了解SSL/TSL加密的过程。在这里想重点说的是在iOS中使用HTTPS。&lt;/p&gt;
&lt;p&gt;在iOS中，常用的是&lt;code&gt;NSURLConnection&lt;/code&gt;支持HTTPS的实现。而常用的第三方库&lt;code&gt;AFNetworking&lt;/code&gt;封装了使用&lt;code&gt;NSURLConnection&lt;/code&gt;实现的逻辑代码，更加完善。在&lt;code&gt;AFNetworking&lt;/code&gt;中使用的方法如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Objective-C

NSURL * url = [NSURL URLWithString:@&amp;quot;https://www.google.com&amp;quot;];
AFHTTPRequestOperationManager * requestOperationManager = [[AFHTTPRequestOperationManager alloc] initWithBaseURL:url];
dispatch_queue_t requestQueue = dispatch_create_serial_queue_for_name(&amp;quot;kRequestCompletionQueue&amp;quot;);
requestOperationManager.completionQueue = requestQueue;

AFSecurityPolicy * securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];

//allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO
//如果是需要验证自建证书，需要设置为YES
securityPolicy.allowInvalidCertificates = YES;

//validatesDomainName 是否需要验证域名，默认为YES；
//假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。
//置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。
//如置为NO，建议自己添加对应域名的校验逻辑。
securityPolicy.validatesDomainName = YES;

//validatesCertificateChain 是否验证整个证书链，默认为YES
//设置为YES，会将服务器返回的Trust Object上的证书链与本地导入的证书进行对比，这就意味着，假如你的证书链是这样的：
//GeoTrust Global CA 
//    Google Internet Authority G2
//        *.google.com
//那么，除了导入*.google.com之外，还需要导入证书链上所有的CA证书（GeoTrust Global CA, Google Internet Authority G2）；
//如是自建证书的时候，可以设置为YES，增强安全性；假如是信任的CA所签发的证书，则建议关闭该验证，因为整个证书链一一比对是完全没有必要（请查看源代码）；
securityPolicy.validatesCertificateChain = NO;

requestOperationManager.securityPolicy = securityPolicy;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##杂谈&lt;/p&gt;
&lt;p&gt;关于连接。TCP连接容易在两个地方出问题：初始设置，以及通过连接传输最后一部分的内容。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;建立连接的时候，TCP由于要进行三次握手，所以在这过程中会有一定的时间损耗。一般一个移动终端向服务发送一个数据包普遍需要250ms, 三次握手的话就是需要750ms。而在HTTPS中则更加夸张。因为HTTPS需要四次握手。。。嗯，在TCP和HTTPS都握手完后，大概需要1750ms.是建立一个HTTP连接的两倍。为了安全，就肯定要牺牲时间效率。&lt;/p&gt;
&lt;p&gt;此外，由于TCP需要侦测当前最佳的转发路由，所以在传送大量的数据时，需要不停地去调整以便得到最佳速度。这种算法被称为&lt;code&gt;慢启动&lt;/code&gt;。注意到，慢启动在数据链路层传输质量差的网络上表现的更差，无线网络就是典型的例子。(4G说，怪我咯)。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;通过TCP释放连接的过程，我们也知道可能存在问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果发送方完成数据发送，接受方自然会停止发送 ACK 确认。在最后四个报文传输的过程中，快速重发算法是没有办法处理这四个报文的数据包的丢失问题的（因为不会收到三个相同的确认 ACK，所以不能界定传输丢包）。在常规网络环境下，四个数据包相当于 5.7kB 的数据规模。总之，在这最后 5.7kB 的传输的过程中，快速重发机制是无效的。针对这种情况，TCP 会启用其他机制来侦测丢包问题。对于这种情况，重传操作可能要消耗几秒钟去执行，这并不奇怪&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;超时处理&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在APP实际处理中，经常发生网络请求超时的现象。许多APP大概在15秒后收不到反馈就会提示超时信息。这种设计其实并不是很友好。我们知道，只有TCP连接还在，TCP都会保证将请求发送出去并会等待响应的返回，只是时间长短的问题。&lt;/p&gt;
&lt;p&gt;个人在这里参考了一些APP的做法，觉得应该在每次请求的时候设置一个计时器，当计时器到达倒数完成后，可以提示用户是否继续网络请求，如果取消就将TCP连接断开，如果继续就继续等待网络请求响应。&lt;/p&gt;
&lt;p&gt;##最后&lt;/p&gt;
&lt;p&gt;了解了IP TCP HTTPS后，接下来想阅读一些文章怎么从这些方面入手去优化网络请求。在互联网时代，数据和网络是承载产品的基础。因此，网络，怎么深入学习都不过分。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IP-TCP-HTTPs-随便谈&quot;&gt;&lt;a href=&quot;#IP-TCP-HTTPs-随便谈&quot; class=&quot;headerlink&quot; title=&quot;IP TCP HTTPs 随便谈&quot;&gt;&lt;/a&gt;IP TCP HTTPs 随便谈&lt;/h1&gt;&lt;p&gt;在总结自己的技能书的缺点后，
    
    </summary>
    
      <category term="Network" scheme="http://csbzhixing.github.io/categories/Network/"/>
    
    
  </entry>
  
</feed>
