<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[之行海涯]]></title>
  <link href="http://csbzhixing.github.io/atom.xml" rel="self"/>
  <link href="http://csbzhixing.github.io/"/>
  <updated>2015-09-24T16:52:33+08:00</updated>
  <id>http://csbzhixing.github.io/</id>
  <author>
    <name><![CDATA[之行]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[json&amp;xml]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/24/json-and-xml/"/>
    <updated>2015-09-24T16:44:36+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/24/json-and-xml</id>
    <content type="html"><![CDATA[<h1>网络传输格式 JSON &amp; XML</h1>

<p>第一次接触这两个格式还是在学校做一个财务管理系统的时候。在之前变成都是纯粹的单机编程，不设计到网络数据传输的问题。到了这个项目才开始考虑如何在服务器和客户端之间传输数据。项目中使用的是JSON，所以在这里先讲JSON的部分。</p>

<h2>JSON</h2>

<p>JSON是一种轻量化的数据格式。他的特点就是方便已用。目前90%的网络传输都是依赖于JSON格式。</p>

<p>首先来看看JSON格式是怎么样的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="s2">&quot;access_token&quot;</span><span class="err">:</span> <span class="s2">&quot;ACCESS_TOKEN&quot;</span><span class="err">,</span>
</span><span class='line'>
</span><span class='line'>   <span class="s2">&quot;expires_in&quot;</span><span class="err">:</span> <span class="mi">1234</span><span class="err">,</span>
</span><span class='line'>
</span><span class='line'>   <span class="s2">&quot;remind_in&quot;</span><span class="err">:</span><span class="s2">&quot;798114&quot;</span><span class="err">,</span>
</span><span class='line'>
</span><span class='line'>   <span class="s2">&quot;uid&quot;</span><span class="err">:</span><span class="s2">&quot;12341234&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是一个常见的JSON格式。比较容易的看出，其实就是一种key-value的形式。</p>

<p>key我们都好了解，是一个string。那么value就会有不一样的值。通过对比OC的对象，我们可以更容易的理解JSON中的数据类型。</p>

<pre><code>            JSON                    OC

            {}                      NSDictionary

            []                      NSArray

            ""                      NSString

           数字                     NSNumber
</code></pre>

<p>知道了JSON所对应的OC对象，我们就可以通过解析JSON对象，将相关的数据转换成OC对象来存储。在这里，介绍一种能够在本地模拟API的方式，这也是由于自己找不到很好的开发API所以想在本地能够模拟API的方式。</p>

<h2>JSON Server 模拟 API</h2>

<h3>第一步 安装</h3>

<ul>
<li>安装Homebrew。这个可是个神器，能够管理mac上的第三方的库的工具。据说被作者写不出反转二叉树个谷歌拒了然后去了苹果。</li>
</ul>


<p><code>ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</code></p>

<ul>
<li>安装node.js</li>
</ul>


<p><code>brew install node</code></p>

<ul>
<li>安装json-server</li>
</ul>


<p><code>npm install -g json-server  
</code></p>

<h2>根据需求创建JSON</h2>

<p>安装完毕后，随便找个你喜欢的文件夹，创建一个JSON格式的文件，如下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='JSON'><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="nt">&quot;posts&quot;</span><span class="p">:</span> <span class="p">[</span>
</span><span class='line'>    <span class="p">{</span> <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nt">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;json-server&quot;</span><span class="p">,</span> <span class="nt">&quot;author&quot;</span><span class="p">:</span> <span class="s2">&quot;typicode&quot;</span> <span class="p">}</span>
</span><span class='line'>  <span class="p">],</span>
</span><span class='line'>  <span class="nt">&quot;comments&quot;</span><span class="p">:</span> <span class="p">[</span>
</span><span class='line'>    <span class="p">{</span> <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nt">&quot;body&quot;</span><span class="p">:</span> <span class="s2">&quot;some comment&quot;</span><span class="p">,</span> <span class="nt">&quot;postId&quot;</span><span class="p">:</span> <span class="mi">1</span> <span class="p">}</span>
</span><span class='line'>  <span class="p">],</span>
</span><span class='line'>  <span class="nt">&quot;profile&quot;</span><span class="p">:</span> <span class="p">{</span> <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;typicode&quot;</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后保存。</p>

<h3>启动JSON-Server</h3>

<p>通过命令<code>json-server --watch JSON文件的名字.json</code>来启动Server</p>

<p>到这里，我们就相当于在本地创建了一个服务器能够相应我们想对应的请求。</p>

<p>以上面的的JSON文件为例</p>

<p><img src="http://csbzhixing.github.io/media/14430769630713.jpg" alt="" /></p>

<p>当然，功能不止这么一点，JSON-Server还有更多方式，详见github<a href="https://github.com/typicode/json-server">json-server</a></p>

<h2>OC对象和JSON对象的转换</h2>

<ul>
<li><p>通过<code>NSJSONSerialization</code>来序列化JSON.</p>

<p>  <img src="http://csbzhixing.github.io/media/14430773793672.jpg" alt="" /></p></li>
</ul>


<p>输出的结果</p>

<p><img src="http://csbzhixing.github.io/media/14430774045308.jpg" alt="" /></p>

<p>对比上面的JSON数据，我们可以看出解析的结果是正确的</p>

<ul>
<li>通过第三方库JSONKit来解析</li>
</ul>


<p> 下载地址 <a href="https://github.com/johnezang/JSONKit">JSONKit</a></p>

<p> <img src="http://csbzhixing.github.io/media/14430745214364.jpg" alt="" /></p>

<ul>
<li>使用Mantle</li>
</ul>


<p>在项目中用的最多的方法，也觉得非常好用</p>

<p>下载地址：<a href="https://github.com/Mantle/Mantle">Mantle</a></p>

<p>使用的方法：</p>

<ol>
<li><p>在本地创建对应的OC类
<img src="http://csbzhixing.github.io/media/14430784491980.jpg" alt="" /></p></li>
<li><p>实现相关的方法</p></li>
</ol>


<p><img src="http://csbzhixing.github.io/media/14430794069120.jpg" alt="" /></p>

<p>第三种是直接将JSON通过一定的方法转成了OC的类对象。在使用的时候感觉更方便。</p>

<h2>XML</h2>

<p>虽然JSON在网络传输中有90%的使用率，但是我们依然不能放弃10%的XML是吧。</p>

<p>XML全称是Extensible Markup Language，译作“可扩展标记语言”
跟JSON一样，也是常用的一种用于交互的数据格式
一般也叫XML文档（XML Document）</p>

<p>下面是一个典型的XML文件的结构</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='JSON'><span class='line'><span class="err">一个元素包括了开始标签和结束标签</span>
</span><span class='line'><span class="err">拥有元素内容：&lt;city&gt;上海&lt;/city&gt;</span>
</span><span class='line'><span class="err">没有元素内容：&lt;city&gt;&lt;/city&gt;</span>
</span><span class='line'><span class="err">没有元素内容的简写：&lt;city/&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="err">一个元素可以嵌套若干个子元素（不能出现交叉嵌套）</span>
</span><span class='line'><span class="err">&lt;citys&gt;</span>
</span><span class='line'>    <span class="err">&lt;city&gt;</span>
</span><span class='line'>        <span class="err">&lt;name&gt;上海&lt;/name&gt;</span>
</span><span class='line'>        <span class="err">&lt;weather&gt;大暴雨&lt;/weather&gt;</span>
</span><span class='line'>          <span class="err">&lt;air&gt;舒适&lt;/air&gt;</span>
</span><span class='line'>    <span class="err">&lt;/city&gt;</span>
</span><span class='line'><span class="err">&lt;/citys&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="err">规范的XML文档最多只有</span><span class="mi">1</span><span class="err">个根元素，其他元素都是根元素的子孙元素</span>
</span><span class='line'><span class="err">XML中的所有空格和换行，都会当做具体内容处理</span>
</span><span class='line'>
</span><span class='line'><span class="err">一个元素可以拥有多个属性，属性值必须用</span> <span class="err">双引号</span><span class="s2">&quot;&quot;</span> <span class="err">或者</span> <span class="err">单引号&#39;&#39;</span> <span class="err">括住。</span>
</span><span class='line'><span class="err">&lt;city</span> <span class="err">name=</span><span class="s2">&quot;上海&quot;</span> <span class="err">weather=</span><span class="s2">&quot;大暴雨&quot;</span> <span class="err">air=</span><span class="s2">&quot;舒适&quot;</span> <span class="err">/&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="err">属性表示的信息也可以用子元素来表示，比如</span>
</span><span class='line'>
</span><span class='line'>   <span class="err">&lt;city&gt;</span>
</span><span class='line'>        <span class="err">&lt;weather&gt;大暴雨&lt;/weather&gt;</span>
</span><span class='line'>          <span class="err">&lt;air&gt;舒适&lt;/air&gt;</span>
</span><span class='line'>    <span class="err">&lt;/city&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>解析XML有两种方式</p>

<ol>
<li>DOM解析：一次性将整个XML文档加载进内存，比较适合解析小文件</li>
<li>SAX解析：从根元素开始，按顺序一个元素一个元素往下解析，比较适合解析大文件</li>
</ol>


<p>在iOS SDK里面，提供了两种解析的框架</p>

<ol>
<li>NSXMLParser：它是基于objective-c语言的sax解析框架，是ios sdk默认的xml解析框架，不支持dom模式。</li>
<li>libxml2: 它是基于c语言的xml解析器，被苹果整合在ios sdk中，支持sax和dom模式。</li>
</ol>


<p>同样，第三方也有许多解析XML的库。这里不打算讲第三方的，一个XML使用的比较少，一个使用SDK自身的效率往往已经非常好了。</p>

<h3>NSXMLParser</h3>

<p>NSXMLParser属于SAX解析，是从上往下依次解析每个元素，在解析到每个元素的时候会通知代理，所以使用NSXMLParser必须遵守他的协议。
使用非常简单</p>

<p><img src="http://csbzhixing.github.io/media/14430815879826.jpg" alt="" />
从当前项目读取XML文件，读出数据，穿件解析器，设置代理，开始解析。</p>

<p>XML文件内容如下</p>

<p><img src="http://csbzhixing.github.io/media/14430816475695.jpg" alt="" />
设置代理后，我们要实现代理方法，主要有以下方法，直接上图了</p>

<p><img src="http://csbzhixing.github.io/media/14430816906329.jpg" alt="" /></p>

<p><img src="http://csbzhixing.github.io/media/14430817012681.jpg" alt="" /></p>

<p><img src="http://csbzhixing.github.io/media/14430833160910.jpg" alt="" /></p>

<p><img src="http://csbzhixing.github.io/media/14430833236999.jpg" alt="" /></p>

<h3>libxml2</h3>

<p>重点在于导入libxml2的库</p>

<p><img src="http://csbzhixing.github.io/media/14430836046841.jpg" alt="" /></p>

<p><img src="http://csbzhixing.github.io/media/14430836140287.jpg" alt="" /></p>

<p><img src="http://csbzhixing.github.io/media/14430836178120.jpg" alt="" /></p>

<p><img src="http://csbzhixing.github.io/media/14430836230051.jpg" alt="" /></p>

<p><img src="http://csbzhixing.github.io/media/14430836285068.jpg" alt="" /></p>

<p>编译项目，通过了就没问题了。</p>

<p>用法参见<a href="https://github.com/neonichu/GDataXML"></a></p>

<h2>总结</h2>

<p>在实际使用中，还JSON用的更多，所以对于JSON的解析过程要更加了解。对于XML，有一些公司任然会使用，而一些现存的数据也会用XML存储，所有也要有一定的了解。</p>

<p>这篇文章讲解了在网络通信中数据的格式。下一篇的话就进入iOS内如何进行网络通信了。虽然使用AFNetWorking已经有段时间了，但是对内部整个机制并不了解，要好好补课了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重新认识ARC]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/22/arc/"/>
    <updated>2015-09-22T17:48:06+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/22/arc</id>
    <content type="html"><![CDATA[<p>第一次接触ARC还是在第一次拿到项目的时候。学习OC的时候使用的教材主要是通过MRC来讲解Retain Counting(引用计数)的。后面只是简单的了解了下ARC是编译器在编译的过程中自动去估算对象的生命周期来自动添加retain和realse的。解放了双手，也就没有什么动力去研究了。现在得空了，是时候增强自己的技能树。当前的目标如下</p>

<ol>
<li>增加网络编程的相关知识

<ul>
<li>TCP/IP HTTP HTTPS 协议的学习和了解</li>
<li>JSON和XML的解析</li>
<li>iOS自身关于网络请求相关的类和API</li>
<li>第三方库AFNetWorking源码阅读</li>
</ul>
</li>
<li>增加iOS内核方面的知识

<ul>
<li>内存基本知识和管理方式</li>
<li>ARC</li>
<li>进程线程</li>
<li>RunTime</li>
</ul>
</li>
</ol>


<p>简单的看是两个大类七个点，但是感觉每一个点都非常多东西。目前暂时把1.1的点给补完了。不过任然需要投入大量的时间去复习。这里打算整合2.1和2.2。</p>

<h2>内存管理</h2>

<p>学过计算机基础的人对于内存都不陌生，哪怕是没有计算机基础的人也明白内存对于电脑（终端）的重要性。内存管理，就是在程序运行的过程中，申请，使用，释放内存的过程。程序写的好不好，就看你在完成功能的同时是不是使用了尽可能少的内存。</p>

<p><em>堆和栈</em></p>

<p>在内存中，有两个重要的概念，分别是<code>堆和栈</code>。这里不仅仅指代他们的数据结构。我们知道，一个函数执行的时候，他会被压入栈中。栈中的内存单元保存了函数的返回地址，局部变量，传参等数据。当函数被弹出栈的时候，一切数据都会被销毁。而<code>堆</code>上的数据是由开发者自行申请管理的，生命周期由开发者自行掌握。</p>

<p><em>引用计数</em></p>

<p>学过OC的人都知道，在OC中管理内存的方法是<code>引用计数</code>(Retain Counting)。通过对堆和栈的了解，我们可以得出OC上的对象<em>都是在堆上</em>的。</p>

<p>在苹果开发文档里面有一张图很好的说明的通过引用计数来管理对象生命周期的过程。</p>

<p><img src="http://csbzhixing.github.io/media/14429735006902.jpg" alt="引用计数" /></p>

<p>同样，引用计数也遵循几大内存管理原则</p>

<ol>
<li>谁申请谁拥有</li>
<li>肯以申请拥有一个存在的对象</li>
<li>当不需要的再拥有对象的时候，申请释放</li>
<li>不能释放不属于自己没有拥有的对象</li>
</ol>


<h2>Automatic Reference Counting (ARC)</h2>

<p>在学习iOS开发半年后，ARC给我留下了很深的印象。ARC是苹果在引用计数的基础上改善了编译器实现的功能。要了解ARC，首先要看看在没有ARC之前开发者是怎么去通过引用计数管理的。</p>

<p>在ARC之前，我们统称为<code>MRC（Manual Reference Counting</code>，即手动引用技术。通过调用<code>retain</code>和<code>release</code>来管理对象的生命周期。有了ARC之后，在编译的过程中，编译器可以根据上下文估算对象的生命周期，以此来自动的添加<code>retain</code>和<code>release</code>。</p>

<p>注意，ARC只对OC对象有作用，对于C的类型对象不则按照C的内存管理的方法去管理。</p>

<p>如果在工程中开启了使用ARC，那么就要遵循ARC定义的一些规范</p>

<ol>
<li>不能显示的调用<code>dealloc</code>,<code>ratain</code>,<code>release</code>,<code>retainCount</code>,<code>autoRelease</code>。</li>
<li>如果要复写<code>dealloc</code>方法，不需要显示调用<code>[super dealloc]</code>方法。</li>
<li>不能再使用<code>AutoReleasepool</code></li>
</ol>


<p><em>ARC下的修饰符</em></p>

<p>在@Property 中，有四种修饰符是ARC提供的，他们分别是
1. strong
2. weak
3. unsafe_unretained
4. __autoreleasing</p>

<p>其中，重点来谈谈strong和weak</p>

<ul>
<li>strong。我们理解为强引用。当前的对象实际拥有这个对象。默认情况下ARC使用的strong来修饰。</li>
<li>weak。相对于strong的强引用，weak指的是弱引用。当引用的对象被释放掉的时候，当前引用对象会被自动置nil。weak通常被用来解决循环引用的问题。</li>
</ul>


<p><code>__autoreleasing</code>和<code>__unsafe_unretained</code>在实际应用中是很少的。<code>__unsafe_unretained</code>是为了兼容iOS4之前的版本，现在基本上不会使用了，主要是为了实现weak的功能。<code>__autoreleasing</code>是表示在autorelease pool中自动释放对象的引用。</p>

<h2>block 在ARC下</h2>

<p>block在之前已经小小的讨论过了，出现的几个问题都有谈论到，这里主要从ARC的角度上再谈一谈。</p>

<p>block在ARC下最特殊的地方就是怎么去解决循环引用。在block的篇章中没有很详细讨论，原因也是没从内存的角度来看。这里详细讲下循环引用产生原因和在ARC下解决循环引用的方法。</p>

<blockquote><p>You can use lifetime qualifiers to avoid strong reference cycles. For example, typically if you have a graph of objects arranged in a parent-child hierarchy and parents need to refer to their children and vice versa, then you make the parent-to-child relationship strong and the child-to-parent relationship weak. Other situations may be more subtle, particularly when they involve block objects.</p>

<p>In manual reference counting mode, <strong>block id x; has the effect of not retaining x. In ARC mode, </strong>block id x; defaults to retaining x (just like all other values). To get the manual reference counting mode behavior under ARC, you could use <strong>unsafe_unretained </strong>block id x;. As the name <strong>unsafe_unretained implies, however, having a non-retained variable is dangerous (because it can dangle) and is therefore discouraged. Two better options are to either use </strong>weak (if you don’t need to support iOS 4 or OS X v10.6), or set the __block value to nil to break the retain cycle.</p>

<p>The following code fragment illustrates this issue using a pattern that is sometimes used in manual reference counting.</p></blockquote>

<p>上面是苹果官方文档对循环引用的解释。通过引用计数，我们了解到，如果有两个对象，对彼此都是强引用的话，双方都无法释放对方，也就无法释放delloc对象，最终就造成了死循环。在iOS5以下的版本里面，我们可以通过手动使用<code>unsafe_unretained</code>来使其中一个变量变成野指针。而在ARC下，我们通过使用weak来修饰其中一个变量，这样在block中就不存在双方强引用的抢矿。</p>

<p>但是，上面的处理方法有个问题。我们不知道weak修饰的对象什么时候会被释放掉了，有可能在执行block里面的对象在之前就已经被释放掉了。在AFNetWorking中，提供了一个非常好的解决思路</p>

<p><img src="http://csbzhixing.github.io/media/14429947239639.jpg" alt="" /></p>

<p>上面方法中，在block外先将self用<code>weak</code>引用一个weakSelf，进入block后再使用一个<code>_strong_typeof</code>去创建一个strong引用对象。这样的做法既能避免产生循环引用，也能避免weak对象提前被释放掉。</p>

<h2>ARC与Toll-Free Bridging</h2>

<p>Toll-Free Briding保证了在程序中，可以方便和谐的使用Core Foundation类型的对象和Objective-C类型的对象。但是，我们知道，到了ARC的时候，两者的内存管理方法不同了。对于一种对象，我们不能用该两种内存管理方法去管理。所以在进入ARC之后，Toll-Free Bridging也进行了相应的变化。</p>

<p><em>__bridge</em></p>

<p>只是申明了类型转变，并没有改变内存管理方法。</p>

<p><em>__bridge_retained（修饰符） or CFBridgingRetain（函数）</em></p>

<p>表示将指针类型转变的同时，将内存管理的责任由原来的Objective-C交给Core Foundation来处理，也就是，将ARC转变为MRC。</p>

<p><em>__bridge_transfer（修饰符） or CFBridgingRelease（函数）</em></p>

<p>这个修饰符和函数的功能和上面那个__bridge_retained相反，它表示将管理的责任由Core Foundation转交给Objective-C，即将管理方式由MRC转变为ARC。</p>

<p>上面就是要谈的ARC的内容了。其实ARC的坑比起MRC已经少了很多了，对于我们可怜的程序员来说已经是很大的解放了。</p>

<p>这里对于内存管理仅仅是基于OC简单的谈了谈，觉得还是不够深刻，主要是自己在这方面的知识的确很欠缺。读了
<a href="http://casatwy.com/ccheng-xu-de-nei-cun-guan-li.html">C程序的内存管理</a>这篇文章学到了很多，在这里也安利一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IP TCP HTTPs 随便谈]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/18/title/"/>
    <updated>2015-09-18T16:48:55+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/18/title</id>
    <content type="html"><![CDATA[<h1>IP TCP HTTPs 随便谈</h1>

<p>在总结自己的技能书的缺点后，决定优先补充自己在计算机网络上知识的漏洞。现在互联网企业，离开了互联网什么都不是。对互联网，普通人可能停留在概念和使用上，而开发人员应该去深入的了解运行进制，进而去优化自己开发的产品。这篇文章，主要是记录自己最近看的一些资料的笔记。</p>

<h2>IP 协议</h2>

<p>IP协议，是网络协议（Internet Protocol）的缩写。IP协议是互联网众多协议的基础。</p>

<p>IP协议实现了解<code>*分组交换网络*</code>。在协议下，每个机器被称为<code>*主机*</code>，IP协议明确了主机之间数据包的传输方式。</p>

<p>数据包，也就是一段二进制数据，包含了传输源的主机的信息。IP协议的特点是<code>*尽力服务*</code>（best effort），提供有效的服务并尽可能的传输。这说明，在传输过程中，可能会丢失数据包，也可能传输了多个相同的数据包。</p>

<p>IP 网络中的主机都配有自己的地址，被称为<code>*IP 地址*</code>。每个数据包中都包含了源主机和目标主机的 IP 地址。IP 协议负责路径计算，即 IP 数据包在网络中的传输传输时，数据包所经过的每一个主机节点都会读取数据包中的目标主机地址信息，以便选择朝什么地方传送数据包。</p>

<h2>蛋疼的IPv4</h2>

<p>如今，多数数据包任然使用的是IPv4（版本4），每一个IP地址都是32位的。比如192.168.1.1就是一个IPV4地址。我们可以算下，IPv4有多少个地址。。嗯，好像很多有43亿吗。。但是呢，到了10年的时候，就已经不到8%的了。。</p>

<p>人们发现IPV4不够用啊，快用完了啊，用完了就不能加主机了啊！！！那怎么办，启用新的协议版本啊，所以除了个IPv6，将地址扩充到128位了。比如<code>2001:0db8:85a3:0042:1000:8a2e:0370:7334</code>
就是一个IPv6的地址了。</p>

<p>128位就是2的128次方个，据说够地球上每个沙子配一个IP了。但是呢，这个协议转换的很慢，目前基本国内的都是还是使用IPv4协议。。看来也不是很着急么。。</p>

<h2>IP数据包的结构</h2>

<p>一个IP数据包通常包括一个数据头部（header）和有效数据（payload）。有效数据自然是数据包中要传送的数据。而数据头部就是包含了一些传输数据相关的数据。</p>

<h4>我们先来看个IPv4的头部</h4>

<p><img src="http://csbzhixing.github.io/media/Screen%20Shot%202015-09-20%20at%2020.15.59.png" alt="Screen Shot 2015-09-20 at 20.15.59" /></p>

<p>可以看到，头部信息包含了当前版本的信息，payload采用的协议。Total Length 表明是有效数据加上头部信息长度的总长度。</p>

<h4>在来看看一个IPv6的报头信息</h4>

<p><img src="http://csbzhixing.github.io/media/14427519874258.jpg" alt="" /></p>

<p>IPv6的头部长度固定到了40.同时IPv6可以链接下一个头部信息（Next Header）。</p>

<h2>数据传输</h2>

<p>我们知道，在数据链路层对对所传输的数据帧数有限制，<code>*（MTU，最大传输单元）*</code>。在IPv4的上，使用<code>*分片*</code>来对数据包进行处理。具体来说，我们可以认为如果数据超过了最大传输单元，那么就会将数据切成几片。当数据到达目标主机后，可以根据分片的信息进行重组。当然，发送源可以选择不进行对数据进行<code>*分片*</code>。如果超过了链路层最大传输单元又不进行<code>*分片*</code>的话，发送源就会收到ICMP（Internet Control Message Protocol，Internet报文控制协议）的数据帧超长报告信息。</p>

<p>在IPv6中，如果数据包超过了长度限制，路由会直接丢弃数据包（好狠）并且向ICMP6报告数据帧过长。然后数据源和目标源会根据这个特性来进行<code>路由发现</code>，就是寻找两端之间最大传输单元的路由。找到最大传输单元的路由后，仅当此时数据包任然超过最大传输单元的时候，IPv6才会进行分片。`对于IPv6下的TCP来说，不会造成什么影响。</p>

<hr />

<p>到此，IP协议就到了一个段落了。IP协议是TCP协议的基础，因此了解是必须的。</p>

<h2>TCP协议</h2>

<p>TCP协议是重头戏。TCP协议是重头戏。TCP协议是重头戏。重要的事情要说三遍。</p>

<p>上面说了，IP协议是基于<code>尽可能服务</code>的，那么TCP协议就是要基于IP协议，解决IP协议采用的不可靠传输引起的复杂的问题。因此，下面的重点就是来谈谈TCP连接的三个部分：建立连接，传输数据，断开连接的详细过程</p>

<h4>TCP建立连接</h4>

<p>首先，我们要知道TCP连接是全双工的,是建立在两个主机之间的。每个连接都存在两种角色：<code>服务器端，监听连接</code>，<code>客户端，主动连接服务器端</code>。客户端主动连接服务器端被称为<code>active open(主动打开)</code>。而服务器端这种监听连接的行为被称为<code>passive open(被动打开)</code>。</p>

<p><strong>三次握手</strong></p>

<p>TCP建立连接是一个确认和反复确认的过程，我们习惯统称为三次握手。这个地方也是几乎所有面试会问的地方，需要注意了。</p>

<p>三次连接，具体的过程有语言描述为以下的过程。</p>

<blockquote><ol>
<li>客服端向服务器端发送SYN包和一个随机序列号X，表示本次的连接的身份。</li>
<li>服务器端收到客服端发送的连接的请求以后，发送一个SYN-ACK包和一个确认ack号X+1(确认序列号X的连接请求确认)。此时服务器还会发送一个随机序列号Y，表示向客户端连接的请求。</li>
<li>客户端收到服务器的回复后，会发送一个ACK包，一个确认号Y+1和序列号X+1给服务器。</li>
</ol>
</blockquote>

<p>SYN包，为<code>synchronize sequence numbers (同步序列号)</code>。用于确认两段传输数据的身份，确保数据包最后都达到了应该到的地方。在建立连接的时候，源和目标都需要确认<code>同步序列号</code>。</p>

<p>ACK包，为<code>acknowledgment (确认)</code>。某一端接到数据后，通过回传序列号来确认收到报文。</p>

<p><img src="http://csbzhixing.github.io/media/14428004882999.jpg" alt="三次握手" /></p>

<h4>传输数据</h4>

<p>建立连接，就是为了传输数据。发送端发出的报文都会带有一个序列号，与当前已传送的字节总数有关。接受端会根据已经接收的报文给发送端传送确认报文，确认信息同样在头部的缩写带的ACK。</p>

<p><img src="http://csbzhixing.github.io/media/14427976037921.jpg" alt="" /></p>

<p>注意的整个过程是双向的。两端都会持续的发送数据。X端发送的数据不会等到Y端发送确认后才发送下一个报文。</p>

<p>TCP协议是可靠的传输协议，所以有一系列复杂的机制来进行具体的的拥塞控制。需要处理的问题如下:<code>丢失报文重发</code>，<code>动态调整发送报文的频率</code></p>

<p><strong>流量控制</strong></p>

<p>流量控制的原则就是发送数据的一方的速度不能比接受数据一方的速度要快。接收方，也就是<code>接收窗口</code>会告诉发送方自身<code>接收窗口</code>数据缓冲区的大小。在tcp包，通过两个两个关键的字段可以得出接收窗口的大小:<code>win -- 窗口大小</code>和<code>wscale -- 窗口发大因子</code> 。如果win=65535 , wscale = 4，那么我们可以计算出接收窗口的大小是 64kB * 4 = 256kB。</p>

<p><strong>拥塞控制</strong></p>

<p>拥塞控制相比于流量控制要复杂一些。拥塞控制就是根据当前网络情况计算出当前网络数据传输的最佳速度。首先我们要认识到，最佳速度不一定就是要最快。一方面，我们希望以更快的速度传输数据。另一方面，由于传输的速度过快，导致大量的数据传入会使处理性能受到影响。在分组交换网络中有一个特点就是<code>超负荷崩溃</code>。当负载过大的时候，数据包之间会产生拥塞，直接导致丢包率上升。</p>

<blockquote><p>拥塞控制需要充分考虑对流量的影响。RFC 5681 中对 TCP 拥塞控制有 6,000 字左右的阐述。发送方要时刻关注来自接收方的确认信息。要做到这点并不简单，有的时候还需要一定的妥协。要知道底部 IP 协议数据包是无序传输的，数据包会丢失也会重复。发送方需要评估 RTT 往返时间，然后基于 RTT 去确定是否收到了接收方的确认信息。重发数据包也有很大代价，除了连接延迟问题，网络的负载也会发生明显的波动。导致 TCP 需要不停的去适应当前网络情况。</p>

<p>更重要的是，TCP 连接本身是易变的。除了数据传输，连接的两端还会不时的发送一些提醒和确认信息以便可以适当的调整状态来维持连接。</p>

<p>基于这种一直在相互协调中的连接关系，TCP 连接往往会是短暂而低效的。在建立连接的初期，TCP 协议算法还不能完全了解当前网络状况。而在连接将要结束的时候，反馈给发送方的信息又可能不充分，这样就很难对连接状况做出实时的合理的评估。</p></blockquote>

<p><em>四次挥手，断开连接</em></p>

<p>建立连接是通过<code>三次握手</code>，而释放连接是通过<code>四次握手</code>。在最下方有图示解释整个过程。那么为什么需要四次握手才能释放连接呢？</p>

<p>上文提到了，TCP是全双工的，因此每个方向上的连接需要单独关闭。这个原则就是当一方没有数据可以传送的时候，发送FIN来终止这一方的连接，但是另一方向上的数据仍然可以发送。当另一方向也发送了FIN的时候，整个连接才完全的关闭了。无论服务器端还是客户端都可以发送来FIN来主动关闭连接。</p>

<p><img src="http://csbzhixing.github.io/media/14428004433668.jpg" alt="四次挥手" /></p>

<h2>HTTPS</h2>

<p>之前的博文谈到了HTTP（超文本传输协议）。如今苹果操作系统iOS也升级到了iOS9。在iOS9中强制所有网络传输协议使用HTTPS。看来对HTTPS的了解是势在必行的了。</p>

<p>HTTPS,实际上可以看作HTTP的加密版本。HTTPS将HTTP协议数据包放到SSL/TSL层加密后，在TCP/IP蹭去传输。到了目标源后，在SST/TSL将数据包解密，传递到HTTP层就是普通的HTTP数据包了。</p>

<p>HTTPS = HTTP + SSL/TSL</p>

<p><strong>SSL/TSL</strong></p>

<p>关于SSL/TSL，我们可以参考下面两篇文章：</p>

<p>!<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>

<p>!<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a></p>

<p>简单的来说，通过SSL/TSL四次握手，来解决下面三个问题。</p>

<ol>
<li>数字证书：该证书包含了公钥等信息，一般是由服务器发给客户端，接收方通过验证这个证书是不是由信赖的CA签发，或者与本地的证书相对比，来判断证书是否可信；假如需要双向验证，则服务器和客户端都需要发送数字证书给对方验证；</li>
<li>三个随机数：这三个随机数构成了后续通信过程中用来对数据进行对称加密解密的“对话密钥”。
 首先客户端先发第一个随机数N1，然后服务器回了第    二个随机数N2（这个过程同时把之前提到的证书发给    客户端），这两个随机数都是明文的；而第三个随机   数N3（这个随机数被称为Premaster secret），  客户端用数字证书的公钥进行非对称加密，发给服务   器；而服务器用只有自己知道的私钥来解密，获取第   三个随机数。这样，服务端和客户端都有了三个随机   数N1+N2+N3，然后两端就使用这三个随机数来生 成“对话密钥”，在此之后的通信都是使用这个“对话    密钥”来进行对称加密解密。因为这个过程中，服务端    的私钥只用来解密第三个随机数，从来没有在网络中   传输过，这样的话，只要私钥没有被泄露，那么数据   就是安全的。</li>
<li>加密通信协议：就是双方商量使用哪一种加密方式，假如两者支持的加密方式不匹配，则无法进行通信；</li>
</ol>


<p>具体的可以参考上面两篇文章的内容，去了解SSL/TSL加密的过程。在这里想重点说的是在iOS中使用HTTPS。</p>

<p>在iOS中，常用的是<code>NSURLConnection</code>支持HTTPS的实现。而常用的第三方库<code>AFNetworking</code>封装了使用<code>NSURLConnection</code>实现的逻辑代码，更加完善。在<code>AFNetworking</code>中使用的方法如下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Objective-C
</span><span class='line'>
</span><span class='line'>NSURL * url = [NSURL URLWithString:@"https://www.google.com"];
</span><span class='line'>AFHTTPRequestOperationManager * requestOperationManager = [[AFHTTPRequestOperationManager alloc] initWithBaseURL:url];
</span><span class='line'>dispatch_queue_t requestQueue = dispatch_create_serial_queue_for_name("kRequestCompletionQueue");
</span><span class='line'>requestOperationManager.completionQueue = requestQueue;
</span><span class='line'>
</span><span class='line'>AFSecurityPolicy * securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];
</span><span class='line'>
</span><span class='line'>//allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO
</span><span class='line'>//如果是需要验证自建证书，需要设置为YES
</span><span class='line'>securityPolicy.allowInvalidCertificates = YES;
</span><span class='line'>
</span><span class='line'>//validatesDomainName 是否需要验证域名，默认为YES；
</span><span class='line'>//假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。
</span><span class='line'>//置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。
</span><span class='line'>//如置为NO，建议自己添加对应域名的校验逻辑。
</span><span class='line'>securityPolicy.validatesDomainName = YES;
</span><span class='line'>
</span><span class='line'>//validatesCertificateChain 是否验证整个证书链，默认为YES
</span><span class='line'>//设置为YES，会将服务器返回的Trust Object上的证书链与本地导入的证书进行对比，这就意味着，假如你的证书链是这样的：
</span><span class='line'>//GeoTrust Global CA 
</span><span class='line'>//    Google Internet Authority G2
</span><span class='line'>//        *.google.com
</span><span class='line'>//那么，除了导入*.google.com之外，还需要导入证书链上所有的CA证书（GeoTrust Global CA, Google Internet Authority G2）；
</span><span class='line'>//如是自建证书的时候，可以设置为YES，增强安全性；假如是信任的CA所签发的证书，则建议关闭该验证，因为整个证书链一一比对是完全没有必要（请查看源代码）；
</span><span class='line'>securityPolicy.validatesCertificateChain = NO;
</span><span class='line'>
</span><span class='line'>requestOperationManager.securityPolicy = securityPolicy;
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>杂谈</h2>

<p>关于连接。TCP连接容易在两个地方出问题：初始设置，以及通过连接传输最后一部分的内容。</p>

<hr />

<p>建立连接的时候，TCP由于要进行三次握手，所以在这过程中会有一定的时间损耗。一般一个移动终端向服务发送一个数据包普遍需要250ms, 三次握手的话就是需要750ms。而在HTTPS中则更加夸张。因为HTTPS需要四次握手。。。嗯，在TCP和HTTPS都握手完后，大概需要1750ms.是建立一个HTTP连接的两倍。为了安全，就肯定要牺牲时间效率。</p>

<p>此外，由于TCP需要侦测当前最佳的转发路由，所以在传送大量的数据时，需要不停地去调整以便得到最佳速度。这种算法被称为<code>慢启动</code>。注意到，慢启动在数据链路层传输质量差的网络上表现的更差，无线网络就是典型的例子。(4G说，怪我咯)。</p>

<hr />

<p>通过TCP释放连接的过程，我们也知道可能存在问题</p>

<blockquote><p>如果发送方完成数据发送，接受方自然会停止发送 ACK 确认。在最后四个报文传输的过程中，快速重发算法是没有办法处理这四个报文的数据包的丢失问题的（因为不会收到三个相同的确认 ACK，所以不能界定传输丢包）。在常规网络环境下，四个数据包相当于 5.7kB 的数据规模。总之，在这最后 5.7kB 的传输的过程中，快速重发机制是无效的。针对这种情况，TCP 会启用其他机制来侦测丢包问题。对于这种情况，重传操作可能要消耗几秒钟去执行，这并不奇怪</p></blockquote>

<hr />

<p><em>超时处理</em></p>

<p>在APP实际处理中，经常发生网络请求超时的现象。许多APP大概在15秒后收不到反馈就会提示超时信息。这种设计其实并不是很友好。我们知道，只有TCP连接还在，TCP都会保证将请求发送出去并会等待响应的返回，只是时间长短的问题。</p>

<p>个人在这里参考了一些APP的做法，觉得应该在每次请求的时候设置一个计时器，当计时器到达倒数完成后，可以提示用户是否继续网络请求，如果取消就将TCP连接断开，如果继续就继续等待网络请求响应。</p>

<h2>最后</h2>

<p>了解了IP TCP HTTPS后，接下来想阅读一些文章怎么从这些方面入手去优化网络请求。在互联网时代，数据和网络是承载产品的基础。因此，网络，怎么深入学习都不过分。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面试小计 9.14]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/14/interview-9-dot-14/"/>
    <updated>2015-09-14T23:22:57+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/14/interview-9-dot-14</id>
    <content type="html"><![CDATA[<p>今天是人生第二次面试。约的公司十一点半。十一点就到了公司楼下。公司所在的地方到家里不远，曾经这里也是充满了许多童年的记忆。想不到过了十几年，自己也会来这里面试，也有可能在这里工作，想想一切都充满许多有趣的偶然。</p>

<p>谈起面试，这只是第二次面试。第一次面试让我感觉非常不好，受到了不小的打击，然而不知道为何现在的公司会收留我做实习生（难道是我长的很适合程序员？）经过了半年的实习经历，踏过了许多以前完全想不到的坑，有了一定的收获，但是这次面试还是有些紧张。相比于第一次面试，我对自己的不足有了更多的认识，也就担心了更多，后面发现我担心是对的，但是担心的点完全不对。。</p>

<p>上了楼，被HR妹子领到一个卡座等待面试。不得不说这个公司的环境要比我的现在的实习公司好了不是一个量级，连拿给我的矿泉水都很高级。。等了大概有五分钟到十分钟，来了个哥们，一看上去就是很厉害的程序员（的确我发现厉害的程序员在长相上都能体现出来）。先自我介绍了一下。由于HR那边只有拉勾网的简历，实在是太普通，所以我把自己带的简历从新给面试官看了下。面试官开始说他也不是负责iOS的（当时内心一惊，我其实很怂考算法和数据结构这种所谓的基础- -）</p>

<p>然后开始聊了下自己现在在公司所做的项目。用电脑展示了一下，开始问第一个问题就是自己负责的了哪些功能，答UI和后台都有设计。然后问了一下一些UI设计的问题，接着就提出一个我刚好思考过的问题：UITableView在网络请求的时候加载图片如何保证流畅性。这个问题刚好周末也和同事讨论过问题，之前也有在网上查了一些不同人思考，就讲了下自己的见解，大概就是通过异步的方式，将UI刷新和图片读取放入不同的线程，通过判断滑动状态来决定是否更新UI。然后他提出我的解决方案中存在的一个问题：如果快速的滑动，只会显示一些预设的空白图片，这样不利于用户去搜索的一个固定的目标。这个问题我回答的时候缺乏了思考，我回答的是通过网络异步请求加载，在前几个屏的Cell延后显示，同时将图片下载预存，快速滑动的时候将新滑入屏幕的cell进行设置图片。后来想来其实有个更讨巧的方法，就是通过分页，控制一次刷新的cell的数量，就避免了用户快速滑动的情况出现。</p>

<p>对于项目，由于面试官也不是做iOS开发的，所以就没设计到一些我准备很久的题目，随后他提出了在项目中是如何与后台联调的。这个问题的许多地方我只知道一些概念，所以理解上有点偏差，但是总体还是回答出来了。</p>

<p>然后面试官随后话锋一转开始问HTTP协议。好险之前抽空整理了HTTP相关知识。HTTP协议必问状态码，在解释了状态码的分类和一些常见的状态码后，他问了我3XX状态码的问题。。怕什么来什么，虽然我记得3XX状态码的归类，但是具体到细节上还是有些遗忘（果真必须什么都要掌握啊）。回答稍微差了一点。</p>

<p>随后面试官问了网络优化的问题。这个问题我感觉比较广泛，不是很好回答，面试官也说不仅限于服务器或者客户端。大概谈了一下自己在项目中的一点想法，特别是当网络服务不好的时候，如何去制造一些交互让用户减少对网络不良造成的影响产生不好反应的可能。然后面试官放了大招 &ndash; 请你谈谈网络安全问题。。。当时真的有点慌了，因为和自己准备的东西偏差有点大。随后就从自己的角度谈了下常规的网络攻击的问题。然后。。。然后问了我SQL注入。。这个我真的只是听说啊，臣妾做不到啊。。。</p>

<p>后面还问了一些项目体会，一些经历。。还考了下指针环的判断和一个小球掉落的题目。。那个小球掉落的题目不知道答案应该是什么，感觉就是一个二分查找。。应该问下面试官他的答案的。</p>

<p>到此，第一个面试官问完，走了出去，松了口气，缓一缓。。压力很大，因为和自己想的有点偏差，即使考数据结构和算法都没这样。。因为是没有心理准备。</p>

<p>大概等了有十分钟。来了第二个面试官，上来换了个座位，然后开始让我简单的自我介绍。然后问了下在校成绩和在校所做的项目。。这时候我就有点忧伤了，因为在笑的项目最大的是就是学院的薪资管理系统，但是这个项目时间比较久了而且记忆的东西不多了（所以同学们一定要写自己有把握的项目啊）。然后出了个SQL题目让我写。。。比较没把握的写了，然后提出自己在项目中用的是Hibernate框架，在这个方向上可能不是很对。在之后就是聊天了，大概就是介绍公司的一些状况，一些学习的途径，还问我来深圳工作是否会错过学校的校招，不考研的原因是什么。在这些问题上我都有自己的想法也就简单说了下。最后问我了下现在公司的情况，薪资问题。。然后就问我有事很么了解的（这算过了还是没过。。）然后讨论了一些我在现在公司开发的遇到的坑。。感觉两个面试官能力都很强，思维能力的确看得出来的不一样。最后出来已经是12点15了。</p>

<p>总结这次面试，作为一个应届生应该有更扎实的基础和全面的知识。自己近半年的精力都放在了iOS上，面对一些问题已经很生疏了，但是这不是抛弃其他知识的理由。第二个面试官也谈到了，广泛的涉猎，单一的深入，才能长久的在技术的路上走下去。最后还是希望进入这家公司，无论从环境上还是见到的人上都觉得非常不错。。当然希望自己的薪资也能高一点。</p>

<p>进和没进，都会更新一下。</p>

<hr />

<p>最终担心了两天，还是过了！希望能够在新的团队里面学到更多的知识。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Warning Blog]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/14/warning-blog/"/>
    <updated>2015-09-14T00:00:00+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/14/warning-blog</id>
    <content type="html"><![CDATA[<h2>开头</h2>

<p>这篇文章是在<a href="http://www.cnblogs.com/dsxniubility/p/4757760.html">http://www.cnblogs.com/dsxniubility/p/4757760.html</a>的基础上加入了一点自己的思考，主要内容都转自上文，所以算一篇文章的读后感+转载吧。</p>

<h2>正文</h2>

<h3>iOS警告收录及科学快速的消除方法</h3>

<p>警告，是在编码中出现的最多的问题。不同于error, warning的出现可能不并不影响程序的正常运行，所以很多时候许多程序员都会选择性的去忽略warning。但是作为一个优秀的程序员，我们应该立足于一个优秀的产品开发者，尽可能避免任何有可能使产品崩溃的现象出现。所以对一切warning都要做到尽可能的消除。</p>

<p>在iOS开发中，我也经常碰多许多摸不着头脑的warning。多数是因为版本的问题。由于苹果在不同版本之间会有一些区别，想要兼容多版本就要使用不同版本共有的方法。而一些stroyboard的问题更是没法定位，只能靠经验去分辨，在几个开发中已经发现了很多坑，而今天看到的这篇文章感觉非常不错，所以转载在这里给自己做一个笔记。</p>

<p>(下面为转载内容)</p>

<blockquote><p>详细科学的消除警告</p>

<p>其实笔者本意是想把一些第一眼看不懂比较坑的警告收录进来，但是后来发现那基本没几个需要些写了，所以就采用了全收录的方法，遇到的就记录下以后也会不断更新。 可以直接按command+F 在本页面搜索警告</p>

<p>Unused variable &lsquo;replyURL&rsquo;</p>

<p>1.没有使用</p>

<p>Cannot find protocol definition for &lsquo;TencentSessionDelegate&rsquo;</p>

<p>2.这种明明都能运行还说我没有定义的警告，是因为你这个协议虽然定义了，但是你这个协议可能还遵守了XX协议，然后这个XX协议没有定义导致会报这种警告，所以遇到这种警告要往“父协议”找。 举个栗子，上面这行就是腾讯授权的库里面报的警告，</p>

<p>1 <code>@protocol TencentSessionDelegate</code>
此协议遵守了TencentApiInterfaceDelegate协议，在TencentOAuth.h类中#import &ldquo;TencentApiInterface.h&rdquo; 警告可破</p>

<p>Null passed to a callee that requires a non-null argument</p>

<p>3.这个警告比较新，是xcode6.3开始 为了让OC也能有swift的？和！的功能，你在声明一个属性的时候加上 <strong>nullable（？可以为空）与</strong>nonnull（！不能为空） 如果放在@property里面的话不用写下划线</p>

<p>1 <code>@property (nonatomic, copy, nonnull) NSString * tickets;</code>
2  <code>@property (nonatomic, copy) NSString * __nonnull tickets;</code></p>

<p>或者用宏NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END 包住多个属性全部具备nonnull，然后仅对需要nullable的改下就行，有点类似于f-no-objc-arc那种先整体给个路线在单独改个别文件的思想。 此警告就是某属性说好的不能为空，你又在某地方写了XX = nil 所以冲突了。</p>

<p>Auto property synthesis will not synthesize property &lsquo;privateCacheDirectory&rsquo;; it will be implemented by its superclass, use @dynamic to acknowledge intention</p>

<p>4.他说你的父类实现了setget方法，但是如果你什么都不写，就会系统自动生成出最一般的setget方法，请用@dynamic 来承认父类实现的这个getset方法。</p>

<p>Unsupported Configuration: Scene is unreachable due to lack of entry points and does not have an identifier for runtime access via -instantiateViewControllerWithIdentifier:.</p>

<p>5.一般是storyboard报的警告，简而言之就是你有的页面没有和箭头所指的控制器连起来，导致最终改页面可能无法显示。</p>

<p>Deprecated: Push segues are deprecated in iOS 8.0 and later</p>

<p>6.iOS8之后呢，不要再用push拖线了，统一用show，他会自己根据你是否有导航栏来判断走push还是走modal</p>

<p>Unsupported Configuration: Plain Style unsupported in a Navigation Item</p>

<p>7.导航栏的item 不支持用plain ，那就用Bordered呗。</p>

<p>The launch image set &ldquo;LaunchImage&rdquo; has 2 unassigned images.</p>

<p>The app icon set &ldquo;AppIcon&rdquo; has 2 unassigned images.</p>

<p>8.几张图标还是启动图找不到自己的位置，可能是一次导入了全部尺寸图片，但是右边的设置只勾了iOS8的 那iOS7尺寸的图标就会报此警告。删掉，或者对照右边匹配。</p>

<p>&lsquo;sizeWithFont:constrainedToSize:lineBreakMode:&rsquo; is deprecated: first deprecated in iOS 7.0 - Use -boundingRectWithSize:options:attributes:context:</p>

<p>9.方法废除，旧的方法sizeWithFontToSize在iOS7后就废除了取而代之是boundingRectWithSize方法</p>

<p>Undeclared selector &lsquo;historyAction&rsquo;</p>

<p>10.使用未声明的方法，一般出现在@selector() 括号里写了个不存在的方法或方法名写错了。</p>

<p>PerformSelector may cause a leak because its selector is unknown</p>

<p>11.这个和上面类似就是直接把上面那个@SEL拿来用会报这个警告</p>

<p>&lsquo;strongify&rsquo; macro redefined</p>

<p>12.这个宏声明重复,删一个吧</p>

<p>&lsquo;UITextAttributeFont&rsquo; is deprecated: first deprecated in iOS 7.0 - Use NSFontAttributeName</p>

<p>&lsquo;UITextAttributeTextColor&rsquo; is deprecated: first deprecated in iOS 7.0 - Use NSForegroundColorAttributeName</p>

<p>&lsquo;UITextAttributeTextShadowColor&rsquo; is deprecated: first deprecated in iOS 7.0 - Use NSShadowAttributeName with an NSShadow instance as the value</p>

<p>13.方法废除,一般一起出现</p>

<p>Code will never be executed</p>

<p>14.他说这代码永远也轮不到他执行，估计是有几行代码写在了return之后</p>

<p>Assigning to &lsquo;id&rsquo; from incompatible type &lsquo;SXTabViewController *const __strong&rsquo;</p>

<p>15.一般出现在xxx.delegate = self ，应该在上面遵守协议</p>

<p>Format specifies type &lsquo;unsigned long&rsquo; but the argument has type &lsquo;unsigned int&rsquo;</p>

<p>16.这个警告一般会出现在NSStringWithFormat里面 前面%d %lu 什么的和后面填进去的参数不匹配就报了警告</p>

<p>Values of type &lsquo;NSInteger&rsquo; should not be used as format arguments; add an explicit cast to &lsquo;long&rsquo; instead</p>

<p>17.类似于上面，也是format里面前后写的不匹配</p>

<p>Method &lsquo;dealWithURL:andTitle:andKeyword:&rsquo; in protocol &lsquo;SXPostAdDelegate&rsquo; not implemented</p>

<p>18.经典警告，遵守了协议，但是没有实现协议方法。 也可能你实现了只是又加了个参数或是你写的方法和协议方法名字有点轻微不同</p>

<p>Using integer absolute value function &lsquo;abs&rsquo; when argument is of floating point type</p>

<p>19.这个可以自动修正，就是说abs适用于整数绝对值，要是float取绝对值要用fabsf</p>

<p>Attribute Unavailable: Automatic Preferred Max Layout Width is not available on iOS versions prior to 8.0</p>

<p>20.有的方法你用的太落后了，也有的方法你用的太超前了。 说这个最大宽度在iOS8之前的系统是要坑的</p>

<p>Too many personality routines for compact unwind to encode</p>

<p>21.你可以在otherlink 中加入 -Wl,-no_compact_unwind 去掉该警告，根据苹果的解释，这个是由于某些地方 c/c++/oc/oc++混用会造成编译警告。一般没有什么伤害。</p>

<p>Property &lsquo;ssid&rsquo; requires method &lsquo;ssid&rsquo; to be defined - use @synthesize, @dynamic or provide a method implementation in this class implementation</p>

<p>22.说这个ssid必须要定义个这个属性的getter方法，如果警告是setSsid就是setter方法， 用@synthesize和@dynamic 都行，一个是让编译器生成getter和setter，一个是自己生成，如果你有模型分发或kvc之类的，选@dynamic就行</p>

<p>Unknown escape sequence &lsquo;)&rsquo;</p>

<p>23.未知的转义序列。 一般有个斜杠再加个东西他都会以为是转义字符，一看\）不认识就报警告了，一般正则表达式容易报这种警告</p>

<p>Property &lsquo;LoginPort&rsquo; not found on object of type &lsquo;LoginLvsTestTask *&rsquo;; did you mean to access property loginPort?</p>

<p>24.这种可以点击自动修复，是典型的大小写写错了，他提醒了一下。</p>

<p>Variable &lsquo;type&rsquo; is used uninitialized whenever switch default is taken</p>

<p>25.这是出现在switch语句中的警告， 一般可能是switch外面定义了个type但是并没有初始化（初始化操作都写在switch的各个分支里），然后在最后return type。 但是switch的有个分支没有对type初始化，他说如果你来到这个分支的话，那还没初始化就要被return。</p></blockquote>

<h2>我们该怎么面对warning</h2>

<p>从第一天开始编程，warning几乎比error都要更多的见到我。在正式做项目前，我几乎都是抱着“小婊砸哪里凉快去哪里的”态度的。在进入公司实习后，在某个强迫症的同事带领下，开始重视起来起来对warning的处理。事实上，warning应该比error更要重视。正是因为warning可以使编译通过，但是会造成我们并不知道的问题存在。这种“我知道你要挂但是我就是不告诉你”的事情，只有我们自己去解决warning，才是避免一切可怕的事情出现的根本。</p>

<p>有了强迫症，我们也可以通过warning为我们做点事情，比如通过``#warning TODO 来提示我们要需要注意的地方（特别是挖坑的时候）。</p>

<p>如果是自己写的文件或第三方库，有了新的接口，然后提示旧的接口废除的话需要在方法后加上宏NS_DEPRECATED_IOS和范围</p>

<p><code>- (void)addTapAction:(SEL)tapAction target:(id)target NS_DEPRECATED_IOS(2_0, 4_0);</code></p>

<p>如果需要在此方法后加上带信息的警告则需要这么写</p>

<p><code>
- (void)addTapAction:(SEL)tapAction target:(id)target __attribute((deprecated("这个接口会爆内存 不建议使用")));
-</code></p>

<p>最后想说一句：重视warning，避免Bug，养成强迫症。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[socket]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/13/socket/"/>
    <updated>2015-09-13T05:27:26+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/13/socket</id>
    <content type="html"><![CDATA[<h2>写在前面</h2>

<p>最近一直在找更好的实习，发现网络编程是一个优秀的程序员必备的技能。而自己在学校中学到的东西很少（逃。要不是有之前的实习和做个一个小小的项目，对于很多知识可能还只是停留在书本上（其实就是没进脑）。最近有人问我是否了解socket，我顿时语塞。对与socket的认识还是学习java的时候知道可以使用socket进行客户端与服务器端的通信，可是当时并没有去实践。欠下的债都是要还的。</p>

<p>此外为什么我每篇博文的开头都写点自己的感受。我觉得博客不仅仅是记录自己的技术积累，也是抒发自己心情的一个途经，所以我会在每篇文章前面写一点点自己在写博文的时候的心情。</p>

<h2>正文</h2>

<p>socket，套接字，是基于TCP/IP协议族下的一种网络通信方式。我们知道，在本地，进程之间有多种方法去通信。在网络中，我们同样可以使用socket进行通信。接下来一步步来看socket是如何使网络上的进程相互通信的。</p>

<p>我们知道，要像让进程通信，首先必须确认进程的身份。如同我们只有知道了和自己谈话的是谁，我们才知道谈什么。在本地，进程拥有唯一的标识PID。在网络上，基于TCP/IP协议，通过<em>IP，协议，端口号</em>，我们可以确认一个进程的唯一身份。</p>

<p>使用TCP/IP协议的应用程序通常采用应用编程接口，有本文讲到的socket（套接字）和TIL（被淘汰了）。目前而言，绝多大数的应用程序都是基于socket进行网络通信的，所以了解socket是一个程序员必备的。</p>

<h2>scocket 究竟是什么</h2>

<p>socket起源于UNIX。我们知道UNIX的设计原理就是<em>一切皆文件</em>，操作都是<em>open -> read/write -> close</em>。所以说，我们可以认为socket也是一个文件，是基于上述设计原理的实现。socket函数就是专门来完成相应操作的。</p>

<h2>socket 操作</h2>

<p>在上面我们知道了socket是一个文件，那么socket自然有对应的操作方法，下面是基于TCP的几个基本操作。
(注，本文的方法是使用Objective-C写的，其实socket在任何语言都是差不多的)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// 创建并初始化socket，返回socket的文件描述符，如果返回值为-1则创建失败</span>
</span><span class='line'><span class="kt">int</span> <span class="n">socket</span><span class="p">(</span><span class="kt">int</span> <span class="n">addresFamily</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 关闭socket</span>
</span><span class='line'><span class="kt">int</span> <span class="n">close</span><span class="p">(</span><span class="kt">int</span> <span class="n">socketFileDescriptor</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 将socket与特定的IP地址和端口号绑定，成功返回0，失败返回-1</span>
</span><span class='line'><span class="kt">int</span> <span class="n">bind</span><span class="p">(</span><span class="kt">int</span> <span class="n">socketFileDescriptor</span><span class="p">,</span> <span class="n">sockadd</span> <span class="o">*</span><span class="n">addressToBind</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 接受客户端的请求并且将客户端的网络地址信息存入clientAddress</span>
</span><span class='line'><span class="c1">// 当客户端的连接请求被接受后，双方的通信链路就建立好了，两者就可以开始通信了。</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">accept</span><span class="p">(</span><span class="kt">int</span> <span class="n">socketFileDescriptor</span><span class="p">,</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">clientAddress</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clientAddressStructLength</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 客户端向特定的IP的服务器发送连接请求，成功返回0，失败返回-1</span>
</span><span class='line'><span class="c1">// 当服务器建立好后，客户端就可以通过这个函数与服务器端建立连接。</span>
</span><span class='line'><span class="c1">// 对于UDP来说，该接口是可选的，如果调用了这个接口表明设置了UDP socket默认的网络地址.</span>
</span><span class='line'><span class="c1">// 对于TCP来说，这里就是三次握手发生的地方</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">connect</span><span class="p">(</span><span class="kt">int</span> <span class="n">socketFileDescriptor</span><span class="p">,</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">serverAddress</span><span class="p">,</span> <span class="kt">int</span> <span class="n">serverAddressLength</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 通过DNS查找特定的IP，如果找不到返回NULL</span>
</span><span class='line'><span class="n">hostent</span> <span class="o">*</span><span class="n">gethostbyname</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 发送数据，发送成功后返回成功发送的字节数，否则返回-1</span>
</span><span class='line'><span class="kt">int</span> <span class="n">send</span><span class="p">(</span><span class="kt">int</span> <span class="n">socketFileDescriptor</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 接收数据，成功后返回成功读取的字节数，否则返回-1</span>
</span><span class='line'><span class="kt">int</span> <span class="n">receive</span><span class="p">(</span><span class="kt">int</span> <span class="n">socketFileDesciptor</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 下面两个方法是UDP的方法</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// UDP发送,返回状态同上</span>
</span><span class='line'><span class="kt">int</span> <span class="n">sendto</span><span class="p">(</span><span class="kt">int</span> <span class="n">socketFileDesciptor</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufferLength</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">destinationAddress</span><span class="p">,</span> <span class="kt">int</span> <span class="n">destinationAddressLength</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// UDP读取，返回状态同上</span>
</span><span class='line'><span class="kt">int</span> <span class="n">recvfrom</span><span class="p">(</span><span class="kt">int</span> <span class="n">socketFileDesciptor</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufferLength</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">fromAddress</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fromAddressLength</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过观察方法，我们发现socket其实就是<em>确认目标 ->建立连接 -> 传送/读取 -> 断开</em> 的过程</p>

<p>我们再来看看TCP和UDP下socket操作的不同的地方</p>

<h4>TCP</h4>

<p><img src="http://www.coderyi.com//qiniu/429/image/5269612b25e6df1b3ee5ab8352b2c3b6.jpg" alt="TCP" /></p>

<h4>UDP</h4>

<p><img src="http://www.coderyi.com//qiniu/429/image/cd6d1690d3d6eefd300987e590c1483f.jpg" alt="UDP" /></p>

<h2>最后</h2>

<p>到此，对于socket编程的概念有了个一个初步的认识了。在实际开发中，我们一般不会直接调用这些底层的API。借助于一些开源的第三方库更有利于项目的开发运行。不过，对于基本的理论知识还是必须要掌握的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GCD小结]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/12/gcd/"/>
    <updated>2015-09-12T21:16:43+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/12/gcd</id>
    <content type="html"><![CDATA[<h1>写在最前面</h1>

<p>最近发现自己学东西的效率好像高了，难道是因为写博客做笔记的原因吗？的确通过写博客来记录自己学习的成果能够加强自己对很多问题的理解。只有能够通过自己的语言将学习到的内容讲出来才是真的理解。所以以后看来要多写写。</p>

<h1>正文</h1>

<h2>GCD是什么鬼</h2>

<p>GCD，简单的来说就是苹果自己出的一套多核运算的解决方案。虽然苹果没有安卓那么多核心，但是并行化运算能够提高流程性是不可争辩的事实。GCD内部自动管理线程 的生命周期，不需要我们自己去手动管理。我们只需要调用对应的API就可以了。GCD是基于C语言开发的，不过由于使用了block，所以使用起来很方便。在了解GCD之前，我们需要了解一点多线程运行的原理。</p>

<h2>基本概念</h2>

<p>GCD中有两个重要的概念：<em>任务</em> 和 <em>队列</em></p>

<ol>
<li>任务。我们可以理解任务就是一个动作，放在GCD中就是一个代码块（block）。执行任务有两种，分别为<em>同步执行</em> 和 <em>异步执行</em>。同步和异步的区别其实很好理解。<code>同步执行</code>既是当前任务执行完前会阻塞当前进程，<code>而异步执行</code>就不会。</li>
<li>队列。队列是用来存放任务的。我们可以理解为任务就是队列中排队等待执行。队列分为<em>串行队列</em>和<em>并行队列</em>。</li>
<li>串行队列，就像排队一样，严格遵守FIFO。</li>
<li>并行队列，同样执行FIFO。不同的是，取出来的任务会根据情况放到别的线程上。由于多个线程出队的时间间隔可能很短，所以容易认为是非FIFO的。不过即使这样，系统也会根据硬件条件来判断，并不一定会所有任务都在同时执行。</li>
</ol>


<hr />

<p>  创建队列的操作如下图所示</p>

<p>  <img src="http://i3.tietuku.com/045e13ec06064ef3.png" alt="queue" /></p>

<hr />

<p>  创建任务如下如图所示</p>

<p>  <img src="http://i3.tietuku.com/b2ef139ced93771f.png" alt="task" /></p>

<h4>队列组</h4>

<p>  对列组就是将多个队列添加到一个组里。这样的方式使我们可以在队列里所有的任务都完成后收到一个通知方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  objective-c
</span><span class='line'>  
</span><span class='line'>  // 创建队列组
</span><span class='line'>    dispatch_group_t group = dispatch_group_create();
</span><span class='line'>
</span><span class='line'>    dispatch_group_async(group, globalQueue, ^{
</span><span class='line'>      for (NSInteger i = 0; i &lt; 3; i++)
</span><span class='line'>      {
</span><span class='line'>          NSLog(@"group - queue - %@", [NSThread currentThread]);
</span><span class='line'>      }
</span><span class='line'>    });
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<h2>NSOperation 和 NSOperationQueue</h2>

<p>  NSOperation 和 NSOperationQueue是苹果对GCD的基于面向对象的完全封装，使其更容易理解。操作方式也更简单</p>

<ol>
<li>将要执行的任务封装到一个<code>NSOperation</code>对象中</li>
<li>将任务添加到一个<code>NSOperationQueue</code>中</li>
</ol>


<p>  此后系统将自动在执行任务。</p>

<h3>添加任务</h3>

<p> 由于NSOperation是一个抽象类，所以不能直接封装任务。但是有两个子类用于封装任务：<code>NSInvocationOperation</code> 和 <code>NSBlockOperation</code>。创建一个队列后，需要调动<code>start()</code>方法来启动，<em>默认在当前队列同步执行</em>。同时队列提供<code>cancel()</code>方法在中途取消任务。</p>

<ul>
<li>NSInvocationOperation 传入一个方法名。</li>
<li>NSBlockOperation 传入一个代码块。

<ul>
<li>在NSBlockOperation中，有一个方法<code>addExecutionBlock</code>方法。这个方法使我们可以添加多个block到队列中。<em>这些block将会并发执行**，将在</em>主线程和其他的多个线程``执行任务</li>
</ul>
</li>
</ul>


<h3>添加队列</h3>

<p>   多数时候，我们不希望当前线程被占用，因为会影响到UI的流畅性（UI永远在主线程上）。因此我们需要创建新的队列。只要我们添加任务到队列上，就会自动调用任务的<code>start()</code>方法。如果任务在其他队列上，那么他就会在其他线程上并行执行。</p>

<p>   我们发现，<code>NSOperationQueue</code>并没有设置串行和并行队列的问题，那么<code>NSOperationQueue</code>是怎么确定队列的类型的呢。苹果通过封装巧妙的使调用者不需要特意的去注意队列的性质，只需要设置<code>NSOperationQueue</code>中的<code>maxConcurrentOperationCount</code> &ndash; 最大并发数就可以了。</p>

<h2>总结</h2>

<p>   在上篇block的文章中也谈到了block在gcd的中的应用。通过gcd，我们可以最大化的去使用硬件的性能，避免出现卡顿的现象。多线程用的好不好，也基本上代表了一个开发者的能力水平。虽然多线程编程有许多坑，但只有跨过一个个坑，才能变成大牛，不是吗？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP学习]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/10/http/"/>
    <updated>2015-09-10T23:46:08+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/10/http</id>
    <content type="html"><![CDATA[<h1>HTTP学习</h1>

<p>HTTP协议是网络中最广泛的协议之一，对HTTP协议的了解应该是每一个和网络打交道的程序员必须具备的技能。很多公司面试都要求对网络知识有一定的了解，一个是TCP/IP协议，一个就是HTTP协议，HTTP协议应用层的协议，内容比较少，这周花时间去总结了一下，做一个备忘。</p>

<h2>HTTP简单分析</h2>

<p>HTTP是一个基于请求/响应模式的、无状态的协议。即，浏览器与服务端连接之后，浏览器向服务器发送一个请求，服务器返回响应信息之后，双方的链接就被关闭。</p>

<p>HTTP1.0是典型的请求/响应模式。</p>

<p>HTTP1.1在1.0的基础上进行了改进，加入了“持续连接”的机制。通过这种机制，客户端发送请求得到响应后，连接不会马上关闭，可以继续发送请求，还可以流水线发送多个请求、而不用等待每一个响应的到来。</p>

<ul>
<li><p>URI和URL + URL我们应该是很熟悉的了，全名是统一资源定位符，包含了需要查找的信息的资源。 + 而URI是URL的父集，纯粹是一个WEB的资源符号</p>

<h2>HTTP请求</h2></li>
</ul>


<p><img src="http://i3.tietuku.com/2c834f74cd465d7e.png" alt="HTTP Request" /></p>

<p>简单的来说 HTTP请求可以分为三部分</p>

<ol>
<li><p>请求行</p></li>
<li><p>消息报头</p></li>
<li><p>请求正文</p></li>
</ol>


<h3>请求行</h3>

<hr />

<p>请求行主要的内容是是请求方法和请求的位置（URL）</p>

<p>请求方法主要有以下几种方法（注意方法都是全部字母大写）</p>

<p><img src="http://i3.tietuku.com/05fa7108f6959f91.png" alt="HTTP Request method" /></p>

<p>在APP中，最多用的到的就是POST 和 GET 两种方法。许多地方都要求区别两者的区别，所以在这里做一下重点笔记对比两者方法的不同</p>

<p>（在这里小小的吐槽，在学校计算机网络的学习中，POST和GET的区别基本就是一句话：POST比GET更好更安全。其实在查阅了许多资料后，发现并没有那么简单）</p>

<hr />

<h4>POST</h4>

<ul>
<li><p>根据HTTP规范，POST表示可能修改服务器上的资源的请求，比如提交表格，注册等等都是常用POST</p></li>
<li><p>POST将请求的正文包在HTTP包体中</p></li>
<li><p>POST没有大小限制</p></li>
</ul>


<hr />

<h4>GET</h4>

<ul>
<li>GET操作，根据HTTP规范，仅仅用于信息获取，而且是应该是安全的幂等。</li>
<li><p>GET操作会将请求的数据附在URL后面，参数之间以&amp;相连（这就是为什么很多人认为GET不安全了）</p></li>
<li><p>GET的数据限制，由于浏览器或者服务器可能会对URL存在长度限制，所以有可能会产生影响</p></li>
</ul>


<p> 通过对比，我们发现常见的误区有两个</p>

<ol>
<li><p>POST比GET更安全。通过上面对比，我们发现，虽然POST没有将参数直接放在URL中，但是通过抓包的手段，我们依然可以获得HTTP包体中的参数。由此看来，想依靠POST就简单保证安全是不可能的。</p></li>
<li><p>POST能比GET传输更多。通过上面的叙述也可以得知，其实HTTP协议本身没有进行限制，POST和GET都没有大小限制，而是第三方的浏览器和服务器造成了差别</p></li>
</ol>


<p>什么时候用POST，什么时候用GET，我们要依据不同的使用场景来区分。如果有缓存的需求，那自然就不能用POST方法。如果必须要用表格，GET也不行了。</p>

<h2>HTTP响应</h2>

<p>请求响应类似与请求。如图所示</p>

<p>可以看到，HTTP响应的第一行叫状态行，包含了HTTP版本，状态码，状态描述信息。</p>

<p>状态码是判断请求状态的重要标志，由三位数字组成，有五种定义：</p>

<ol>
<li>1XX &mdash;- 请示信息，表示请求已经接受，可以继续处理</li>
<li>2XX &mdash;- 成功状态，表示请求被服务器接受</li>
<li>3XX &mdash;- 重定向，要完成请求的话需要更进一步的操作</li>
<li>4XX &mdash;- 客户端错误，请求错误或者请求无法被实现</li>
<li>5XX &mdash;- 服务器端错误，服务器未能完成合法的请求</li>
</ol>


<p>全部取值如下：</p>

<blockquote><pre><code>   100——客户必须继续发出请求
   101——客户要求服务器根据请求转换HTTP协议版本


    200——交易成功
    201——提示知道新文件的URL
    202——接受和处理、但处理未完成
    203——返回信息不确定或不完整
    204——请求收到，但返回信息为空
    205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
    206——服务器已经完成了部分用户的GET请求

    300——请求的资源可在多处得到
    301——删除请求数据
    302——在其他地址发现了请求数据
    303——建议客户访问其他URL或访问方式
    304——客户端已经执行了GET，但文件未变化
    305——请求的资源必须从服务器指定的地址得到
    306——前一版本HTTP中使用的代码，现行版本中不再使用
    307——申明请求的资源临时性删除

    400——错误请求，如语法错误
    401——请求授权失败
    402——保留有效ChargeTo头响应
    403——请求不允许
    404——没有发现文件、查询或URl
    405——用户在Request-Line字段定义的方法不允许
    406——根据用户发送的Accept拖，请求资源不可访问
    407——类似401，用户必须首先在代理服务器上得到授权
    408——客户端没有在用户指定的饿时间内完成请求
    409——对当前资源状态，请求不能完成
    410——服务器上不再有此资源且无进一步的参考地址
    411——服务器拒绝用户定义的Content-Length属性请求
    412——一个或多个请求头字段在当前请求中错误
    413——请求的资源大于服务器允许的大小
    414——请求的资源URL长于服务器允许的长度
    415——请求资源不支持请求项目格式
    416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段
    417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求

    500——服务器产生内部错误
    501——服务器不支持请求的函数
    502——服务器暂时不可用，有时是为了防止发生系统过载
    503——服务器过载或暂停维修
    504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长
    505——服务器不支持或拒绝支请求头中指定的HTTP版本
</code></pre></blockquote>

<p> 常见的错误主要有400 404 403 500 503等等</p>

<p>相应正文，包含了请求获得的资源，有HTML文件，JSON格式数据，文件的URL等等</p>

<h3>消息报头</h3>

<hr />

<p>HTTP请求和HTTP响应都有消息报头。而消息报头是由众多报头域组成。每一个报头域都由名字＋“：”＋空格组成，消息报头域的名字是大小写无关的。</p>

<p>HTTP消息报头包括普通报头、请求报头、响应报头和实体报头。</p>

<hr />

<h4>普通报头：</h4>

<p>在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。</p>

<p>常见的普通报头：</p>

<p>1）Cache-Control</p>

<pre><code>Cache-Control用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。

请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;
响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.
</code></pre>

<p>2）Date</p>

<pre><code>Date普通报头域表示消息产生的日期和时间
</code></pre>

<p>3）Connection</p>

<pre><code>Connection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接
</code></pre>

<hr />

<h4>请求报头</h4>

<p>请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。
（在APP中，一些身份验证的信息可能需要在header中添加）</p>

<p>常见的请求报头：</p>

<p>1)Accept</p>

<pre><code>Accept请求报头域用于指定客户端接受哪些类型的信息。
</code></pre>

<p>2)Accept-Charset</p>

<pre><code>Accept-Charset请求报头域用于指定客户端接受的字符集。如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。
</code></pre>

<p>3）Accept-Encoding</p>

<pre><code>Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。
</code></pre>

<p>4）Accept-Language</p>

<pre><code>Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。
</code></pre>

<p>5）Authorization</p>

<pre><code>Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。
</code></pre>

<p>6）Host</p>

<pre><code>发送请求时，该报头域是必需的。Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。
</code></pre>

<p>7）User-Agent</p>

<pre><code>User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。
</code></pre>

<hr />

<h4>响应报头</h4>

<p>响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。</p>

<p>常见的实体报头：</p>

<p>1）Location</p>

<pre><code>Location响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。
</code></pre>

<p>2）Server</p>

<pre><code>Server响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。
</code></pre>

<p>3）WWW-Authenticate</p>

<pre><code>WWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。
</code></pre>

<hr />

<h4>实体报头</h4>

<p>请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。</p>

<p>实体报头包括：</p>

<p>常见的实体报头：</p>

<p>1）Content-Encoding</p>

<pre><code>Content-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding主要用于记录文档的压缩方法。
</code></pre>

<p>2）Content-Language</p>

<pre><code>Content-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言
</code></pre>

<p>阅读者。</p>

<p>3）Content-Length</p>

<pre><code>Content-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。即一个数字字符占一个字节，用其对应的ASCII码来存储传输。
</code></pre>

<p>4）Content-Type</p>

<pre><code>Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。
</code></pre>

<p>5）Expires</p>

<pre><code>Expires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。
</code></pre>

<p>6）Last-Modified</p>

<pre><code>Last-Modified实体报头域用于指示资源的最后修改日期和时间。
</code></pre>

<h2>总结</h2>

<p>HTTP协议的内容不是多，常用的内容就几个，但是需要非常熟悉，因为HTTP协议是网络交互重要的协议之一。</p>

<p>接下来花一些时间去回顾TCP/IP协议，内容多就会有几篇文章来记录学习的一些笔记心得。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[block]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/07/block/"/>
    <updated>2015-09-07T17:25:40+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/07/block</id>
    <content type="html"><![CDATA[<h2>Block是个什么</h2>

<p>和kvo/kvc一样，block的使用也是我在学习Objective-C的过程中碰到的一个大拦路虎。第一遍过语法的时候并没有太注意这部分的内容。而到了后面阅读各类大神的源码的时候，发现block的应用非常多。而对这块内容的疏忽导致自己一直不能很顺利的阅读各类代码，在项目中也是一知半解的应用，所以在这里想总结下。</p>

<h3>Blcok 是什么</h3>

<p>block是在iOS SDK 4.0引入的黑魔法。从他诞生的时候，Apple就倾注了大量的心血。字面上看，block就是一个代码块。在许多语言中都可以看到相似的语法设计。但是block自身由于可以在内联执行的时候还可以传递参数，同时自身可以作为参数在函数之间来传递，所有有了许多神奇的用法（好吧是我觉得很神奇）</p>

<p>一个典型的block的应用如下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> BOOL (^isName)(NSString *) = ^(NSString *name) {
</span><span class='line'>      if ([name isEqualToString:@"csb"])
</span><span class='line'>      {
</span><span class='line'>          return YES;
</span><span class='line'>      }
</span><span class='line'>      else
</span><span class='line'>      {
</span><span class='line'>          return NO;
</span><span class='line'>      }
</span><span class='line'>    };</span></code></pre></td></tr></table></div></figure>


<p>定义一个block开头是和函数一样是返回类型，（^）跟着是block的名字，后面跟着是传入的数据类型。括号里面是代码块。</p>

<p>一个完整的例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>- (void)blockTest
</span><span class='line'>{
</span><span class='line'>    BOOL (^isName)(NSString *) = ^(NSString *name) {
</span><span class='line'>      if ([name isEqualToString:@"csb"])
</span><span class='line'>      {
</span><span class='line'>          return YES;
</span><span class='line'>      }
</span><span class='line'>      else
</span><span class='line'>      {
</span><span class='line'>          return NO;
</span><span class='line'>      }
</span><span class='line'>    };
</span><span class='line'>
</span><span class='line'>    self.sark.name = @"csb";
</span><span class='line'>    NSLog(@"is csb ? %@", isName(self.sark.name) ? @"yes" : @"no");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>那么block有什么特别之处？前面提到了，block能够使用block外的参数，我们来实验下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)blockTest
</span><span class='line'>{
</span><span class='line'>    NSString *csbName = @"csbzhixing";
</span><span class='line'>    BOOL (^isName)(NSString *) = ^(NSString *name) {
</span><span class='line'>      if ([name isEqualToString:csbName])
</span><span class='line'>      {
</span><span class='line'>          return YES;
</span><span class='line'>      }
</span><span class='line'>      else
</span><span class='line'>      {
</span><span class='line'>          return NO;
</span><span class='line'>      }
</span><span class='line'>    };
</span><span class='line'>
</span><span class='line'>    self.sark.name = @"csbzhixing";
</span><span class='line'>    NSLog(@"is csb ? %@", isName(self.sark.name) ? @"yes" : @"no");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>输出
<code>
2015-09-07 16:48:25.452 CSBRepository[83032:1549339] is csb ? yes
</code></p>

<p>注意到，定义了block后，修改了block中引用的局部变量，那么block中的局部变量仍然会保持不变。</p>

<p><img src="http://i3.tietuku.com/a60eb087f6bfd358.png" alt="pic1" /></p>

<p>好吧，如果我们的确有这个需求怎么弄呢？使用<code>_block</code>修饰符来修饰局部变量可以解决这个问题</p>

<p><img src="http://i3.tietuku.com/ba1814837f233066.png" alt="pic2" /></p>

<p>block调用实例变量，这个没有好说的。。直接用就是了。</p>

<h2>小小的问题，循环引用</h2>

<p>需要注意的一个问题是block的retain cycle问题，即循环引用。</p>

<p>如果要细究这个问题，要回到老生常谈的引用计数的问题上。有许多很详细的文章解释了为何存在这种问题，在这里我只简单的谈下我的理解。</p>

<p>retain cycle的问题根源在于block和object可能会互相强引用，互相retain了对方，这样就导致了retain cycle的问题。到了最后就发现两者谁也释放不了谁，导致了崩溃。（你不让我，我不让你怎么行）。</p>

<p>解决的方法就是打破这种循环，使用弱引用。这点可以参考最有名的第三方库AFNetworking的源码，在block上afn的写法最值得参考学习。</p>

<h2>Block该用在什么地方</h2>

<p>在项目中，主要应用block的地方有场景之间的数据传输，UI刷新，网络请求等等。在参考官方的建议和大神的博客后，总结了一下几个方面</p>

<ol>
<li>枚举 &ndash; 通过block获取对象和控制枚举进程</li>
<li>View动画 &ndash; 规定动画，参考官方的demo可以很快的了解</li>
<li>通知 &ndash; 事件完成后执行block内的代码，比如网络请求成功后</li>
<li>完成 &ndash; 同上</li>
<li>GCD多线程 &ndash; 这个是下一篇想要去了解学习的内容</li>
<li>错误处理 &ndash; 错误发生的时候执行</li>
<li>排序</li>
</ol>


<p>深入学习block还有很多的内容，比如block是怎么实现，block的类型等等。这里只是我目前学习的一个小结，有机会还要再深入的学习。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[kvo/kvc小结]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/07/kvo-kvc/"/>
    <updated>2015-09-07T11:50:52+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/07/kvo-kvc</id>
    <content type="html"><![CDATA[<p>从学习Objective-C以来，有两个地方一直搞不明白。一个是KVO和KVC的应用和与Delegate的应用场景的区别，一个是Block的应用场景。总结起来就死对Objective-C的数据传送的应用不理解。乘着放假几天对这个知识点进行了一些学习和总结，学习了一个小demo，在这里记录一下自己的学习情况。</p>

<p>参考</p>

<ol>
<li>&ndash; <a href="http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/">http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/</a></li>
<li>&ndash; <a href="http://objccn.io/issue-7-3/">http://objccn.io/issue-7-3/</a></li>
</ol>


<h1>KVO</h1>

<h2>KVO简单使用</h2>

<h4>KVO(Key Value Observing)，是观察者模式在Foundation中的实现</h4>

<p>观察者模式，比较容易理解，就是一方对另一方观察，如果进行了改变，那么就要观察者接收到了消息就用进行相应的操作。在KVO中，总结起来就死以下几个操作。</p>

<ol>
<li>当一个object有观察者的时候，动态创建这个object的子类。</li>
<li>对于每一个被观察的属性Property,重写他的set方法</li>
<li>在重写的set方法中，调用 <code>- willChangeValueForKey</code> 和 <code>- didChangeValueForKey</code> 方法</li>
<li>当一个属性Property没有被观察的时候，删除重写的方法</li>
<li>当没有observer观察任何一个property的时候，删除动态创建的子类</li>
</ol>


<p>使用的时候，主要通过以下几个方法来使用</p>

<p><code>addObserver:&lt;#(NSObject *)#&gt; forKeyPath:&lt;#(NSString *)#&gt; options:&lt;#(NSKeyValueObservingOptions)#&gt; context:&lt;#(void *)#&gt;</code></p>

<p>通过这个方法来为一个对象添加观察者，观察减值“key”,option是观察返回的类型字典，总共有以下几种</p>

<ol>
<li>NSKeyValueObservingOptionOld &ndash; 变化前的值</li>
<li>NSKeyValueObservingOptionNew &ndash; 变化后的值</li>
<li>NSKeyValueObservingOptionPrior &ndash; 值变化前进行通知</li>
<li>NSKeyValueObservingOptionInitial &ndash; 在添加观察者的时候出发相关方法</li>
</ol>


<p>context 是一个指针当<code>observeValueForKeyPath:ofObject:change:context:</code>方法执行时context会提供给观察者。context可以是C指针或者一个对象引用，既可以当作一个唯一的标识来分辨被观察的变更，也可以向观察者提供数据。</p>

<h4>当观察者接受到消息的时</h4>

<p>当被观察的属性变更时，观察者会接到<code>observeValueForKeyPath:ofObject:change:context:</code>消息，所有的观察者都必须实现这个方法。
观察者会被提供触发通知的对象和keyPath，一个包含变更详细信息的字典，还有一个注册观察者时提供的context指针。</p>

<p>关于change字典，总共包含以下五个键值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString *const NSKeyValueChangeKindKey;  
</span><span class='line'>NSString *const NSKeyValueChangeNewKey;  
</span><span class='line'>NSString *const NSKeyValueChangeOldKey;  
</span><span class='line'>NSString *const NSKeyValueChangeIndexesKey;  
</span><span class='line'>NSString *const NSKeyValueChangeNotificationIsPriorKey;</span></code></pre></td></tr></table></div></figure>


<ol>
<li>NSKeyValueChangeKindKey</li>
</ol>


<p>指明了变更的类型，值为“NSKeyValueChange”枚举中的某一个，类型为NSNumber。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum {
</span><span class='line'>   NSKeyValueChangeSetting = 1,
</span><span class='line'>   NSKeyValueChangeInsertion = 2,
</span><span class='line'>   NSKeyValueChangeRemoval = 3,
</span><span class='line'>   NSKeyValueChangeReplacement = 4
</span><span class='line'>};
</span><span class='line'>typedef NSUInteger NSKeyValueChange;</span></code></pre></td></tr></table></div></figure>


<ol>
<li>NSKeyValueChangeNewKey</li>
</ol>


<p>如果 <code>NSKeyValueChangeKindKey</code>的值为 <code>NSKeyValueChangeSetting</code>，并且 <code>NSKeyValueObservingOptionNew</code>选项在注册观察者时也指定了，那么这个键的值就是属性变更后的新值。
对于 <code>NSKeyValueChangeInsertion</code>或者<code>NSKeyValueChangeReplacement</code>，如果 <code>NSKeyValueObservingOptionNew</code>选项在注册观察者时也指定了，这个键的值是一个数组，其包含了插入或替换的对象</p>

<ol>
<li>NSKeyValueChangeOldKey</li>
</ol>


<h2>移除观察者</h2>

<p>你可以通过发送removeObserver:forKeyPath:消息来移除观察者，你需要指明观察对象和路径</p>

<p>注意，在移除观察者之前，如果context是一个对象的引用，那么必须保持对它的强引用直到观察者被移除。</p>

<h2>注册依赖键</h2>

<p>有时候，有些属性的值取决于一个或者多个属性的值，一旦某个依赖的属性的值改变了，依赖它的属性的值需要被通知进行改变。</p>

<h3>To - One</h3>

<p>要触发to - one 关系，有两种方法
1. 定义名称为 <code>keyPathForValueAffecting&lt;key&gt;</code>方法
2. 重写 <code>keyPathForValueAffectingForKey:</code> 方法</p>

<h3>To - Many</h3>

<p>由于<code>keyPathForValueAffectingForKey</code>不支持包含to-many关系的keypath。如果一个类的属性对另一个类的多个属性有依赖关系的时候，必须通过其他方法来实现KVO。</p>

<ol>
<li><p>将parent类作为所有children类的相关属性的观察者。此时必须注意如果将将child类添加或者删除的时候必须对parent类对child类的观察者添加或者删除。此时通过<code>observeValueForKeyPath:ofObject:change:context:</code>可以通过对被依赖属性的变化来更新依赖属性的值。</p></li>
<li><p>Core Data中有另外一种实现观察者模式的方法，由于我还没有使用过Core Data,暂且不谈</p></li>
</ol>


<h2>调试KVO</h2>

<p>在LLDB中，我们可以通过<code>po [object observationInfo]</code>来获取观察者信息</p>

<h1>KVC</h1>

<h2>KVC简单使用</h2>

<p>KVC即是键值编码。以字符串的形式向对象发送消息，这个字符串是我们关注的焦点。</p>

<p>基本调用是<code>-valueForKey</code> 和 <code>-setValue:forKey</code></p>

<p>对于KVC，Cocoa自动放入和取出标量值（int，float和struct）放入NSNumber和NSValue中，当使用<code>-setValue:forKey</code>的使用，他自动将标量值从这些对象中取出。</p>

<p>使用KVC访问属性的代价比直接使用存取方法要大，所以只有在需要的时候才使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用markdown来写博客]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/05/markdown/"/>
    <updated>2015-09-05T22:05:38+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/05/markdown</id>
    <content type="html"><![CDATA[<h2>用Markdown来写作</h2>

<p>在实习的时候第一次接触了这种语法，在CSDN中也用过一些。感觉用这种语法来写作更有利自己的编写格式，能够根据不同的场景进行一定的标记。在这里借用 <em>markdown.tw</em>的语法说明，为自己以后更好的写作作一个小小的开始</p>

<h4>Markdown: 语法</h4>

<hr />

<ul>
<li><a href="#overview">概述</a>

<ul>
<li><a href="#philosophy">哲學</a></li>
<li><a href="#html">行內 HTML</a></li>
<li><a href="#autoescape">特殊字元自動轉換</a></li>
</ul>
</li>
<li><a href="#block">區塊元素</a>

<ul>
<li><a href="#p">段落和換行</a></li>
<li><a href="#header">標題</a></li>
<li><a href="#blockquote">區塊引言</a></li>
<li><a href="#list">清單</a></li>
<li><a href="#precode">程式碼區塊</a></li>
<li><a href="#hr">分隔線</a></li>
</ul>
</li>
<li><a href="#span">區段元素</a>

<ul>
<li><a href="#link">連結</a></li>
<li><a href="#em">強調</a></li>
<li><a href="#code">程式碼</a></li>
<li><a href="#img">圖片</a></li>
</ul>
</li>
<li><a href="#misc">其它</a>

<ul>
<li><a href="#backslash">跳脫字元</a></li>
<li><a href="#autolink">自動連結</a></li>
</ul>
</li>
<li><a href="#acknowledgement">感謝</a></li>
</ul>


<p><strong>注意：</strong>這份文件是用 Markdown 寫的，你可以<a href="https://github.com/othree/markdown-syntax-zhtw/blob/master/syntax.md">看看它的原始檔</a> 。</p>

<hr />

<h2 id="overview">概述</h2>




<h3 id="philosophy">哲學</h3>


<p>Markdown 的目標是實現「易讀易寫」。</p>

<p>不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。Markdown 語法受到一些既有 text-to-HTML 格式的影響，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/">atx</a>、<a href="http://textism.com/tools/textile/">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/">EtText</a>，然而最大靈感來源其實是純文字的電子郵件格式。</p>

<p>因此 Markdown 的語法全由標點符號所組成，並經過嚴謹慎選，是為了讓它們看起來就像所要表達的意思。像是在文字兩旁加上星號，看起來就像*強調*。Markdown 的清單看起來，嗯，就是清單。假如你有使用過電子郵件，區塊引言看起來就真的像是引用一段文字。</p>

<h3 id="html">行內 HTML</h3>


<p>Markdown 的語法有個主要的目的：用來作為一種網路內容的<em>寫作</em>用語言。</p>

<p>Markdown 不是要來取代 HTML，甚至也沒有要和它相似，它的語法種類不多，只和 HTML 的一部分有關係，重點<em>不是</em>要創造一種更容易寫作 HTML 文件的語法，我認為 HTML 已經很容易寫了，Markdown 的重點在於，它能讓文件更容易閱讀、編寫。HTML 是一種<em>發佈</em>的格式，Markdown 是一種<em>編寫</em>的格式，因此，Markdown 的格式語法只涵蓋純文字可以涵蓋的範圍。</p>

<p>不在 Markdown 涵蓋範圍之外的標籤，都可以直接在文件裡面用 HTML 撰寫。不需要額外標註這是 HTML 或是 Markdown；只要直接加標籤就可以了。</p>

<p>只有區塊元素──比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等標籤，必須在前後加上空行，以利與內容區隔。而且這些（元素）的開始與結尾標籤，不可以用 tab 或是空白來縮排。Markdown 的產生器有智慧型判斷，可以避免在區塊標籤前後加上沒有必要的 <code>&lt;p&gt;</code> 標籤。</p>

<p>舉例來說，在 Markdown 文件裡加上一段 HTML 表格：</p>

<pre><code>This is a regular paragraph.

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;Foo&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

This is another regular paragraph.
</code></pre>

<p>請注意，Markdown 語法在 HTML 區塊標籤中將不會被進行處理。例如，你無法在 HTML 區塊內使用 Markdown 形式的<code>*強調*</code>。</p>

<p>HTML 的區段標籤如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 則不受限制，可以在 Markdown 的段落、清單或是標題裡任意使用。依照個人習慣，甚至可以不用Markdown 格式，而採用 HTML 標籤來格式化。舉例說明：如果比較喜歡 HTML 的  <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 標籤，可以直接使用這些標籤，而不用 Markdown 提供的連結或是影像標示語法。</p>

<p>HTML 區段標籤和區塊標籤不同，在區段標籤的範圍內， Markdown 的語法是有效的。</p>

<h3 id="autoescape">特殊字元自動轉換</h3>


<p>在 HTML 文件中，有兩個字元需要特殊處理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符號用於起始標籤，<code>&amp;</code> 符號則用於標記 HTML 實體，如果你只是想要使用這些符號，你必須要使用實體的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p>

<p><code>&amp;</code> 符號其實很容易讓寫作網路文件的人感到困擾，如果你要打「AT&amp;T」 ，你必須要寫成「<code>AT&amp;amp;T</code>」 ，還得轉換網址內的 <code>&amp;</code> 符號，如果你要連結到：</p>

<pre><code>http://images.google.com/images?num=30&amp;q=larry+bird
</code></pre>

<p>你必須要把網址轉成：</p>

<pre><code>http://images.google.com/images?num=30&amp;amp;q=larry+bird
</code></pre>

<p>才能放到連結標籤的 <code>href</code> 屬性裡。不用說也知道這很容易忘記，這也可能是 HTML 標準檢查所檢查到的錯誤中，數量最多的。</p>

<p>Markdown 允許你直接使用這些符號，但是你要小心跳脫字元的使用，如果你是在HTML 實體中使用 <code>&amp;</code> 符號的話，它不會被轉換，而在其它情形下，它則會被轉換成 <code>&amp;amp;</code>。所以你如果要在文件中插入一個著作權的符號，你可以這樣寫：</p>

<pre><code>&amp;copy;
</code></pre>

<p>Markdown 將不會對這段文字做修改，但是如果你這樣寫：</p>

<pre><code>AT&amp;T
</code></pre>

<p>Markdown 就會將它轉為：</p>

<pre><code>AT&amp;amp;T
</code></pre>

<p>類似的狀況也會發生在 <code>&lt;</code> 符號上，因為 Markdown 支援 <a href="#html">行內 HTML</a> ，如果你是使用 <code>&lt;</code> 符號作為 HTML 標籤使用，那 Markdown 也不會對它做任何轉換，但是如果你是寫：</p>

<pre><code>4 &lt; 5
</code></pre>

<p>Markdown 將會把它轉換為：</p>

<pre><code>4 &amp;lt; 5
</code></pre>

<p>不過需要注意的是，code 範圍內，不論是行內還是區塊， <code>&lt;</code> 和 <code>&amp;</code> 兩個符號都<em>一定</em>會被轉換成 HTML 實體，這項特性讓你可以很容易地用 Markdown 寫 HTML code （和 HTML 相對而言， HTML 語法中，你要把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都轉換為 HTML 實體，才能在 HTML 文件裡面寫出 HTML code。）</p>

<hr />

<h2 id="block">區塊元素</h2>




<h3 id="p">段落和換行</h3>


<p>一個段落是由一個以上相連接的行句組成，而一個以上的空行則會切分出不同的段落（空行的定義是顯示上看起來像是空行，便會被視為空行。比方說，若某一行只包含空白和 tab，則該行也會被視為空行），一般的段落不需要用空白或斷行縮排。</p>

<p>「一個以上相連接的行句組成」這句話其實暗示了 Markdown 允許段落內的強迫斷行，這個特性和其他大部分的 text-to-HTML 格式不一樣（包括 MovableType 的「Convert Line Breaks」選項），其它的格式會把每個斷行都轉成 <code>&lt;br /&gt;</code> 標籤。</p>

<p>如果你<em>真的</em>想要插入 <code>&lt;br /&gt;</code> 標籤的話，在行尾加上兩個以上的空白，然後按 enter。</p>

<p>是的，這確實需要花比較多功夫來插入 <code>&lt;br /&gt;</code> ，但是「每個換行都轉換為 <code>&lt;br /&gt;</code>」的方法在 Markdown 中並不適合， Markdown 中 email 式的 <a href="#blockquote">區塊引言</a> 和多段落的 <a href="#list">清單</a> 在使用換行來排版的時候，不但更好用，還更好閱讀。</p>

<h3 id="header">標題</h3>


<p>Markdown 支援兩種標題的語法，<a href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a> 和 <a href="http://www.aaronsw.com/2002/atx/">atx</a> 形式。</p>

<p>Setext 形式是用底線的形式，利用 <code>=</code> （最高階標題）和 <code>-</code> （第二階標題），例如：</p>

<pre><code>This is an H1
=============

This is an H2
-------------
</code></pre>

<p>任何數量的 <code>=</code> 和 <code>-</code> 都可以有效果。</p>

<p>Atx 形式則是在行首插入 1 到 6 個 <code>#</code> ，對應到標題 1 到 6 階，例如：</p>

<pre><code># This is an H1

## This is an H2

###### This is an H6
</code></pre>

<p>你可以選擇性地「關閉」atx 樣式的標題，這純粹只是美觀用的，若是覺得這樣看起來比較舒適，你就可以在行尾加上 <code>#</code>，而行尾的 <code>#</code> 數量也不用和開頭一樣（行首的井字數量決定標題的階數）：</p>

<pre><code># This is an H1 #

## This is an H2 ##

### This is an H3 ######
</code></pre>

<h3 id="blockquote">Blockquotes</h3>


<p>Markdown 使用 email 形式的區塊引言，如果你很熟悉如何在 email 信件中引言，你就知道怎麼在 Markdown 文件中建立一個區塊引言，那會看起來像是你強迫斷行，然後在每行的最前面加上 <code>&gt;</code> ：</p>

<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&gt; 
&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&gt; id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>Markdown 也允許你只在整個段落的第一行最前面加上 <code>&gt;</code> ：</p>

<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>區塊引言可以有階層（例如：引言內的引言），只要根據層數加上不同數量的 <code>&gt;</code> ：</p>

<pre><code>&gt; This is the first level of quoting.
&gt;
&gt; &gt; This is nested blockquote.
&gt;
&gt; Back to the first level.
</code></pre>

<p>引言的區塊內也可以使用其他的 Markdown 語法，包括標題、清單、程式碼區塊等：</p>

<pre><code>&gt; ## This is a header.
&gt; 
&gt; 1.   This is the first list item.
&gt; 2.   This is the second list item.
&gt; 
&gt; Here's some example code:
&gt; 
&gt;     return shell_exec("echo $input | $markdown_script");
</code></pre>

<p>任何標準的文字編輯器都能簡單地建立 email 樣式的引言，例如 BBEdit ，你可以選取文字後然後從選單中選擇<em>增加引言階層</em>。</p>

<h3 id="list">清單</h3>


<p>Markdown 支援有序清單和無序清單。</p>

<p>無序清單使用星號、加號或是減號作為清單標記：</p>

<pre><code>*   Red
*   Green
*   Blue
</code></pre>

<p>等同於：</p>

<pre><code>+   Red
+   Green
+   Blue
</code></pre>

<p>也等同於：</p>

<pre><code>-   Red
-   Green
-   Blue
</code></pre>

<p>有序清單則使用數字接著一個英文句點：</p>

<pre><code>1.  Bird
2.  McHale
3.  Parish
</code></pre>

<p>很重要的一點是，你在清單標記上使用的數字並不會影響輸出的 HTML 結果，上面的清單所產生的 HTML 標記為：</p>

<pre><code>&lt;ol&gt;
&lt;li&gt;Bird&lt;/li&gt;
&lt;li&gt;McHale&lt;/li&gt;
&lt;li&gt;Parish&lt;/li&gt;
&lt;/ol&gt;
</code></pre>

<p>如果你的清單標記寫成：</p>

<pre><code>1.  Bird
1.  McHale
1.  Parish
</code></pre>

<p>或甚至是：</p>

<pre><code>3. Bird
1. McHale
8. Parish
</code></pre>

<p>你都會得到完全相同的 HTML 輸出。重點在於，你可以讓 Markdown 文件的清單數字和輸出的結果相同，或是你懶一點，你可以完全不用在意數字的正確性。</p>

<p>如果你使用懶惰的寫法，建議第一個項目最好還是從 1. 開始，因為 Markdown 未來可能會支援有序清單的 start 屬性。</p>

<p>清單項目標記通常是放在最左邊，但是其實也可以縮排，最多三個空白，項目標記後面則一定要接著至少一個空白或 tab。</p>

<p>要讓清單看起來更漂亮，你可以把內容用固定的縮排整理好：</p>

<pre><code>*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
    viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
    Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>但是如果你很懶，那也不一定需要：</p>

<pre><code>*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>如果清單項目間用空行分開， Markdown 會把項目的內容在輸出時用 <code>&lt;p&gt;</code>
標籤包起來，舉例來說：</p>

<pre><code>*   Bird
*   Magic
</code></pre>

<p>會被轉換為：</p>

<pre><code>&lt;ul&gt;
&lt;li&gt;Bird&lt;/li&gt;
&lt;li&gt;Magic&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>但是這個：</p>

<pre><code>*   Bird

*   Magic
</code></pre>

<p>會被轉換為：</p>

<pre><code>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>清單項目可以包含多個段落，每個項目下的段落都必須縮排 4 個空白或是一個 tab ：</p>

<pre><code>1.  This is a list item with two paragraphs. Lorem ipsum dolor
    sit amet, consectetuer adipiscing elit. Aliquam hendrerit
    mi posuere lectus.

    Vestibulum enim wisi, viverra nec, fringilla in, laoreet
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
    sit amet velit.

2.  Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>如果你每行都有縮排，看起來會看好很多，當然，再次地，如果你很懶惰，Markdown 也允許：</p>

<pre><code>*   This is a list item with two paragraphs.

    This is the second paragraph in the list item. You're
only required to indent the first line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.

*   Another item in the same list.
</code></pre>

<p>如果要在清單項目內放進引言，那 <code>&gt;</code> 就需要縮排：</p>

<pre><code>*   A list item with a blockquote:

    &gt; This is a blockquote
    &gt; inside a list item.
</code></pre>

<p>如果要放程式碼區塊的話，該區塊就需要縮排<em>兩次</em>，也就是 8 個空白或是兩個 tab：</p>

<pre><code>*   A list item with a code block:

        &lt;code goes here&gt;
</code></pre>

<p>當然，項目清單很可能會不小心產生，像是下面這樣的寫法：</p>

<pre><code>1986. What a great season.
</code></pre>

<p>換句話說，也就是在行首出現<em>數字-句點-空白</em>，要避免這樣的狀況，你可以在句點前面加上反斜線。</p>

<pre><code>1986\. What a great season.
</code></pre>

<h3 id="precode">程式碼區塊</h3>


<p>和程式相關的寫作或是標籤語言原始碼通常會有已經排版好的程式碼區塊，通常這些區塊我們並不希望它以一般段落文件的方式去排版，而是照原來的樣子顯示，Markdown 會用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 標籤來把程式碼區塊包起來。</p>

<p>要在 Markdown 中建立程式碼區塊很簡單，只要簡單地縮排 4 個空白或是 1 個 tab 就可以，例如，下面的輸入：</p>

<pre><code>This is a normal paragraph:

    This is a code block.
</code></pre>

<p>Markdown 會轉換成：</p>

<pre><code>&lt;p&gt;This is a normal paragraph:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This is a code block.
&lt;/code&gt;&lt;/pre&gt;
</code></pre>

<p>這個每行一階的縮排（4 個空白或是 1 個 tab），都會被移除，例如：</p>

<pre><code>Here is an example of AppleScript:

    tell application "Foo"
        beep
    end tell
</code></pre>

<p>會被轉換為：</p>

<pre><code>&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tell application "Foo"
    beep
end tell
&lt;/code&gt;&lt;/pre&gt;
</code></pre>

<p>一個程式碼區塊會一直持續到沒有縮排的那一行（或是文件結尾）。</p>

<p>在程式碼區塊裡面， <code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 會自動轉成 HTML 實體，這樣的方式讓你非常容易使用 Markdown 插入範例用的 HTML 原始碼，只需要複製貼上，再加上縮排就可以了，剩下的 Markdown 都會幫你處理，例如：</p>

<pre><code>    &lt;div class="footer"&gt;
        &amp;copy; 2004 Foo Corporation
    &lt;/div&gt;
</code></pre>

<p>會被轉換為：</p>

<pre><code>&lt;pre&gt;&lt;code&gt;&amp;lt;div class="footer"&amp;gt;
    &amp;amp;copy; 2004 Foo Corporation
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</code></pre>

<p>程式碼區塊中，一般的 Markdown 語法不會被轉換，像是星號便只是星號，這表示你可以很容易地以 Markdown 語法撰寫 Markdown 語法相關的文件。</p>

<h3 id="hr">分隔線</h3>


<p>你可以在一行中用三個或以上的星號、減號、底線來建立一個分隔線，行內不能有其他東西。你也可以在星號中間插入空白。下面每種寫法都可以建立分隔線：</p>

<pre><code>* * *

***

*****

- - -

---------------------------------------
</code></pre>

<hr />

<h2 id="span">區段元素</h2>




<h3 id="link">連結</h3>


<p>Markdown 支援兩種形式的連結語法： <em>行內</em>和<em>參考</em>兩種形式。</p>

<p>不管是哪一種，連結的文字都是用 [方括號] 來標記。</p>

<p>要建立一個行內形式的連結，只要在方塊括號後面馬上接著括號並插入網址連結即可，如果你還想要加上連結的 title 文字，只要在網址後面，用雙引號把 title 文字包起來即可，例如：</p>

<pre><code>This is [an example](http://example.com/ "Title") inline link.

[This link](http://example.net/) has no title attribute.
</code></pre>

<p>會產生：</p>

<pre><code>&lt;p&gt;This is &lt;a href="http://example.com/" title="Title"&gt;
an example&lt;/a&gt; inline link.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://example.net/"&gt;This link&lt;/a&gt; has no
title attribute.&lt;/p&gt;
</code></pre>

<p>如果你是要連結到同樣主機的資源，你可以使用相對路徑：</p>

<pre><code>See my [About](/about/) page for details.   
</code></pre>

<p>參考形式的連結使用另外一個方括號接在連結文字的括號後面，而在第二個方括號裡面要填入用以辨識連結的標籤：</p>

<pre><code>This is [an example][id] reference-style link.
</code></pre>

<p>你也可以選擇性地在兩個方括號中間加上空白：</p>

<pre><code>This is [an example] [id] reference-style link.
</code></pre>

<p>接著，在文件的任意處，你可以把這個標籤的連結內容定義出來：</p>

<pre><code>[id]: http://example.com/  "Optional Title Here"
</code></pre>

<p>連結定義的形式為：</p>

<ul>
<li>方括號，裡面輸入連結的辨識用標籤</li>
<li>接著一個冒號</li>
<li>接著一個以上的空白或 tab</li>
<li>接著連結的網址</li>
<li>選擇性地接著 title 內容，可以用單引號、雙引號或是括弧包著</li>
</ul>


<p>下面這三種連結的定義都是相同：</p>

<pre><code>[foo]: http://example.com/  "Optional Title Here"
[foo]: http://example.com/  'Optional Title Here'
[foo]: http://example.com/  (Optional Title Here)
</code></pre>

<p><strong>請注意：</strong>有一個已知的問題是 Markdown.pl 1.0.1 會忽略單引號包起來的連結 title。</p>

<p>連結網址也可以用方括號包起來：</p>

<pre><code>[id]: &lt;http://example.com/&gt;  "Optional Title Here"
</code></pre>

<p>你也可以把 title 屬性放到下一行，也可以加一些縮排，網址太長的話，這樣會比較好看：</p>

<pre><code>[id]: http://example.com/longish/path/to/resource/here
    "Optional Title Here"
</code></pre>

<p>網址定義只有在產生連結的時候用到，並不會直接出現在文件之中。</p>

<p>連結辨識標籤可以有字母、數字、空白和標點符號，但是並<em>不</em>區分大小寫，因此下面兩個連結是一樣的：</p>

<pre><code>[link text][a]
[link text][A]
</code></pre>

<p><em>預設的連結標籤</em>功能讓你可以省略指定連結標籤，這種情形下，連結標籤和連結文字會視為相同，要用預設連結標籤只要在連結文字後面加上一個空的方括號，如果你要讓 &ldquo;Google&rdquo; 連結到 google.com，你可以簡化成：</p>

<pre><code>[Google][]
</code></pre>

<p>然後定義連結內容：</p>

<pre><code>[Google]: http://google.com/
</code></pre>

<p>由於連結文字可能包含空白，所以這種簡化的標籤內也可以包含多個文字：</p>

<pre><code>Visit [Daring Fireball][] for more information.
</code></pre>

<p>然後接著定義連結：</p>

<pre><code>[Daring Fireball]: http://daringfireball.net/
</code></pre>

<p>連結的定義可以放在文件中的任何一個地方，我比較偏好直接放在連結出現段落的後面，你也可以把它放在文件最後面，就像是註解一樣。</p>

<p>下面是一個參考式連結的範例：</p>

<pre><code>I get 10 times more traffic from [Google] [1] than from
[Yahoo] [2] or [MSN] [3].

  [1]: http://google.com/        "Google"
  [2]: http://search.yahoo.com/  "Yahoo Search"
  [3]: http://search.msn.com/    "MSN Search"
</code></pre>

<p>如果改成用連結名稱的方式寫：</p>

<pre><code>I get 10 times more traffic from [Google][] than from
[Yahoo][] or [MSN][].

  [google]: http://google.com/        "Google"
  [yahoo]:  http://search.yahoo.com/  "Yahoo Search"
  [msn]:    http://search.msn.com/    "MSN Search"
</code></pre>

<p>上面兩種寫法都會產生下面的 HTML。</p>

<pre><code>&lt;p&gt;I get 10 times more traffic from &lt;a href="http://google.com/"
title="Google"&gt;Google&lt;/a&gt; than from
&lt;a href="http://search.yahoo.com/" title="Yahoo Search"&gt;Yahoo&lt;/a&gt;
or &lt;a href="http://search.msn.com/" title="MSN Search"&gt;MSN&lt;/a&gt;.&lt;/p&gt;
</code></pre>

<p>下面是用行內形式寫的同樣一段內容的 Markdown 文件，提供作為比較之用：</p>

<pre><code>I get 10 times more traffic from [Google](http://google.com/ "Google")
than from [Yahoo](http://search.yahoo.com/ "Yahoo Search") or
[MSN](http://search.msn.com/ "MSN Search").
</code></pre>

<p>參考式的連結其實重點不在於它比較好寫，而是它比較好讀，比較一下上面的範例，使用參考式的文章本身只有 81 個字元，但是用行內形式的連結卻會增加到 176 個字元，如果是用純 HTML 格式來寫，會有 234 個字元，在 HTML 格式中，標籤比文字還要多。</p>

<p>使用 Markdown 的參考式連結，可以讓文件更像是瀏覽器最後產生的結果，讓你可以把一些標記相關的資訊移到段落文字之外，你就可以增加連結而不讓文章的閱讀感覺被打斷。</p>

<h3 id="em">強調</h3>


<p>Markdown 使用星號（<code>*</code>）和底線（<code>_</code>）作為標記強調字詞的符號，被 <code>*</code> 或 <code>_</code> 包圍的字詞會被轉成用 <code>&lt;em&gt;</code> 標籤包圍，用兩個 <code>*</code> 或 <code>_</code> 包起來的話，則會被轉成 <code>&lt;strong&gt;</code>，例如：</p>

<pre><code>*single asterisks*

_single underscores_

**double asterisks**

__double underscores__
</code></pre>

<p>會轉成：</p>

<pre><code>&lt;em&gt;single asterisks&lt;/em&gt;

&lt;em&gt;single underscores&lt;/em&gt;

&lt;strong&gt;double asterisks&lt;/strong&gt;

&lt;strong&gt;double underscores&lt;/strong&gt;
</code></pre>

<p>你可以隨便用你喜歡的樣式，唯一的限制是，你用什麼符號開啟標籤，就要用什麼符號結束。</p>

<p>強調也可以直接插在文字中間：</p>

<pre><code>un*frigging*believable
</code></pre>

<p>但是如果你的 <code>*</code> 和 <code>_</code> 兩邊都有空白的話，它們就只會被當成普通的符號。</p>

<p>如果要在文字前後直接插入普通的星號或底線，你可以用反斜線：</p>

<pre><code>\*this text is surrounded by literal asterisks\*
</code></pre>

<h3 id="code">程式碼</h3>


<p>如果要標記一小段行內程式碼，你可以用反引號把它包起來（<code>`</code>），例如：</p>

<pre><code>Use the `printf()` function.
</code></pre>

<p>會產生：</p>

<pre><code>&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt;
</code></pre>

<p>如果要在程式碼區段內插入反引號，你可以用多個反引號來開啟和結束程式碼區段：</p>

<pre><code>``There is a literal backtick (`) here.``
</code></pre>

<p>這段語法會產生：</p>

<pre><code>&lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt;
</code></pre>

<p>程式碼區段的起始和結束端都可以放入一個空白，起始端後面一個，結束端前面一個，這樣你就可以在區段的一開始就插入反引號：</p>

<pre><code>A single backtick in a code span: `` ` ``

A backtick-delimited string in a code span: `` `foo` ``
</code></pre>

<p>會產生：</p>

<pre><code>&lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;
</code></pre>

<p>在程式碼區段內，<code>&amp;</code> 和方括號都會被轉成 HTML 實體，這樣會比較容易插入 HTML 原始碼，Markdown 會把下面這段：</p>

<pre><code>Please don't use any `&lt;blink&gt;` tags.
</code></pre>

<p>轉為：</p>

<pre><code>&lt;p&gt;Please don't use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;
</code></pre>

<p>你也可以這樣寫：</p>

<pre><code>`&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`.
</code></pre>

<p>以產生：</p>

<pre><code>&lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encoded
equivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt;
</code></pre>

<h3 id="img">圖片</h3>


<p>很明顯地，要在純文字應用中設計一個 「自然」的語法來插入圖片是有一定難度的。</p>

<p>Markdown 使用一種和連結很相似的語法來標記圖片，同樣也允許兩種樣式： <em>行內</em>和<em>參考</em>。</p>

<p>行內圖片的語法看起來像是：</p>

<pre><code>![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg "Optional title")
</code></pre>

<p>詳細敘述如下：</p>

<ul>
<li>一個驚嘆號 <code>!</code></li>
<li>接著一對方括號，裡面放上圖片的替代文字</li>
<li>接著一對普通括號，裡面放上圖片的網址，最後還可以用引號包住並加上
選擇性的 &lsquo;title&rsquo; 文字。</li>
</ul>


<p>參考式的圖片語法則長得像這樣：</p>

<pre><code>![Alt text][id]
</code></pre>

<p>「id」是圖片參考的名稱，圖片參考的定義方式則和連結參考一樣：</p>

<pre><code>[id]: url/to/image  "Optional title attribute"
</code></pre>

<p>到目前為止， Markdown 還沒有辦法指定圖片的寬高，如果你需要的話，你可以使用普通的 <code>&lt;img&gt;</code> 標籤。</p>

<hr />

<h2 id="misc">其它</h2>




<h3 id="autolink">自動連結</h3>


<p>Markdown 支援比較簡短的自動連結形式來處理網址和電子郵件信箱，只要是用方括號包起來， Markdown 就會自動把它轉成連結，連結的文字就和連結位置一樣，例如：</p>

<pre><code>&lt;http://example.com/&gt;
</code></pre>

<p>Markdown 會轉為：</p>

<pre><code>&lt;a href="http://example.com/"&gt;http://example.com/&lt;/a&gt;
</code></pre>

<p>自動的郵件連結也很類似，只是 Markdown 會先做一個編碼轉換的過程，把文字字元轉成 16 進位碼的 HTML 實體，這樣的格式可以混淆一些不好的信箱地址收集機器人，例如：</p>

<pre><code>&lt;address@example.com&gt;
</code></pre>

<p>Markdown 會轉成：</p>

<pre><code>&lt;a href="&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;
&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;
&amp;#109;"&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;
&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;
</code></pre>

<p>在瀏覽器裡面，這段字串會變成一個可以點擊的「address@example.com」連結。</p>

<p>（這種作法雖然可以混淆不少的機器人，但並無法全部擋下來，不過這樣也比什麼都不做好些。無論如何，公開你的信箱終究會引來廣告信件的。）</p>

<h3 id="backslash">跳脫字元</h3>


<p>Markdown 可以利用反斜線來插入一些在語法中有其它意義的符號，例如：如果你想要用星號加在文字旁邊的方式來做出強調效果（但不用 <code>&lt;em&gt;</code> 標籤），你可以在星號的前面加上反斜線：</p>

<pre><code>\*literal asterisks\*
</code></pre>

<p>Markdown 支援在下面這些符號前面加上反斜線來幫助插入普通的符號：</p>

<pre><code>\   反斜線
`   反引號
*   星號
_   底線
{}  大括號
[]  方括號
()  括號
#   井字號
+   加號
-   減號
.   英文句點
!   驚嘆號
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[新的开始]]></title>
    <link href="http://csbzhixing.github.io/blog/2015/09/05/%E5%BC%80%E5%A7%8B/"/>
    <updated>2015-09-05T16:32:12+08:00</updated>
    <id>http://csbzhixing.github.io/blog/2015/09/05/开始</id>
    <content type="html"><![CDATA[<p>这是我的新的github的博客，挖坑，看自己能保持更新多久</p>
]]></content>
  </entry>
  
</feed>
